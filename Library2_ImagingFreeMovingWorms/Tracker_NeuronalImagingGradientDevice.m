function [File, All_Files] = Tracker_NeuronalImagingGradientDevice % This function uses two EXTERNAL FUNCTIONS. %    1) SegmentationSettings_ImagingSetup_v02%    2) The identity of this tracker function is defined in the function 'Initialize_Tracking_Variables'    % September 2019, Sagi Levy%% Initialization:  Define Constants & Initialize variables and Tracker function name. Information saved in TrackingVariables_SL.mat in TempFolder TrackingVariablesFile = Initialize_Tracking_Variables_SLI_AWC_ON; load (TrackingVariablesFile,'TempFolder','check_status_interval','TrackerFunctionName','StatusFile','Background_params');  warning('off','MATLAB:load:variableNotFound')SortFileNames.Sort  = false;  try load (TrackingVariablesFile,'SortFileNames');  end     % If variable exist --> sort the filenames to fit real frame timing using pre-defined identifiersavi_format          = false;  try load (TrackingVariablesFile,'avi_format');     end     % If variable exist and true --> The full movie is a set of '.avi' movies. warning('on','MATLAB:load:variableNotFound')              %%   Check for existing files that are still not analyzed.[FinishPreviousTrackingSession, All_Files] = Check_incomplete_tracking_files (TempFolder);  % 0= new movie, 1= uncompleted fragements analysis, 2= unstitched fragements    %% In case of a NEW movie (not yet analyzed)- get movie parameters manuallyif ~FinishPreviousTrackingSession       clear All_Files;    [FileNum, Name] = GetFileNames(SortFileNames, avi_format);    % Get User Input for each movie    for MovieNum = 1:FileNum        CurrentFile         = GetUserInput (Name(MovieNum), TrackingVariablesFile);    % User interface + additional manual variables        All_Files(MovieNum) = CurrentFile;    end    save(StatusFile,'All_Files');end%% Track all movies for which the tracking is not yet finished MoviesCompletionStatus = [All_Files.Stitched];for MovieNum = find(~MoviesCompletionStatus)        File = All_Files(MovieNum);   % The 'File' structure contains data for only ONE movie    disp([datestr(now), '  Starting movie number ',num2str(MovieNum),' -- ', File.MovieName]);        % Avoid re-analyzing completed fragements. If it's the first uncompleted movie- use the 'File' variable from the StatusFile (inprogress.mat)     if FinishPreviousTrackingSession && (MovieNum==find(~MoviesCompletionStatus,1))         load(StatusFile,'File');        if ~strcmp(File.MoviePath, All_Files(MovieNum).MoviePath)       % If names doesn't match (shouldn't happen...) reanalyze the fragements.            disp('filenames mismatch... ');            File = All_Files(MovieNum);   % The 'File' structure contains data for only ONE movie        end    else        save(File.StatusFile,'File','All_Files');        % Calculate background and save variable. ONLY IF IT WASN'T DONE PREVIOUSLY !!           if ~Background_params.UseOnlyFramesInFragement      % Do not caluclate background if the user prefers to re-calculated background independently for each movie fragment (fluctuating background)               [~, File] = getbackground_inline(File, Background_params);                    All_Files(MovieNum).BackgroundFile = File.BackgroundFile;            if isfield(File,'DyePattern_MidPixelFrames')                All_Files(MovieNum).DyePattern_MidPixelFrames = File.DyePattern_MidPixelFrames;                All_Files(MovieNum).DyePattern_MidPixelValues = File.DyePattern_MidPixelValues;                save(File.StatusFile,'File','All_Files');            end        end            end     if ~isfield(File,'InBoundBox')       pause;       close all;       File = DefineInBoundAreas(File);        save(File.StatusFile,'File','All_Files');    end         % Initiate the FragmentTracker function for each fragmented movie file    if ~File.Stitched                % Movie names and make directory for analysis files         [TrackName, FragmentSaveNames, File, All_Files] =  MovieNames_MakeDir (File, All_Files, MovieNum);               % Initiate the FragmentTracker function for each fragmented movie file        load (TrackingVariablesFile,'num_processors','max_processors');        InitiateFragmentTracker (File, All_Files, MovieNum, TrackerFunctionName, num_processors, max_processors)    % 'File' and 'All_Files' are also saved here        % Status Monitoring - Show status window and waits until all fregments analysis is done.           StatusMonitoring (TempFolder, check_status_interval, File, MovieNum, length(MoviesCompletionStatus));        % NEED TO BE DEBUGED  !!!!!!!!!!!!!!!            success=false; while ~success, load(File.StatusFile,'File'); success = true; end                File.Stitched = true;        TrackDye_ImagingSetup_inline(File);                disp([datestr(now), '  Finished movie number ',num2str(MovieNum),' -- ', File.MovieName]);        if length(All_Files)>1            All_Files(MovieNum) = File;        else            All_Files = File;        end                    save(File.StatusFile,'File','All_Files');    end        FinishPreviousTrackingSession = false;        end   disp([datestr(now), '  Finished tracking all movies']);return%% Tracking variable files function TrackingVariablesFile = Initialize_Tracking_Variables_SLI_AWC_ON  %% This function define Constants & Initialize variables for the Fragments tracker%  Parameters that should be optimized based on computer performance:%    max_processors:           %    DefaultFragmentLength     %    MaxRelativeSizeChange      can probably be omitted%% Which tracker to use, how to define arenas and pixelsize and which worm data neet to be collectedUserInterfaceMode.UseFirstFrameInsteadOfBackground = true;     % If true --> skip the background calculationn and the user interface is done on the first frame. Much faster for Long/high resolution movies.UserInterfaceMode.AutoDefine_Image_as_OneArena     = true;     % If true --> skip the arenas location definitions. The whole image will be considered as one arena (number 1).UserInterfaceMode.DefineOutOfBoundPolygons         = false;UserInterfaceMode.AutoDefine_PixelSize             = true;     % If true --> skip the pixel size definition. The pixel size MUST BE PRE-DEFINED in this field: 'PixelSize'. UserInterfaceMode.PixelSize                        = 163.6;    % Pixel size. opposite UNITS! = pixel per mmUserInterfaceMode.DefineInBoundArena               = true;SingleWormTrack                                = false;TrackerFunctionName    = ';FragmentTracker_SL_ImagingSetup_v09(Fragment);';    % external function     % DetectionMode = 'Minimal';                          % Minimal features are calculated and stored, such as centroid, eccentricity and area of each worm.% DetectionMode = 'AddBasicMorphologyProperties';     % Adding basic morphological features such as skeleton and perimeter. The skeleton is not corrected for possible bugs. % DetectionMode = 'AddAdvancedMorphologyProperties';  % Adding also advanced morphological features such as exact midline caluclation, Head and tail, and gray scale pattern in regular coordinates. % %                                                       optional: head vs. tail based on gray scale along the midline.DetectionMode = 'AddAllProperties';                   % Adding also gray scale pattern of the worm in the worms' coordinate system. This can be used for Worm barcoding.  %% Which type of movie files is it? File names definition.%%%%%%%%%%%%%%%%   For the screening setup    %%%%%%%%%%%%%%%    single or multiple 'avi' files are generated. Each avi file contain a subset of the full experiment movie.  avi_format = false;%%%%%%%%%%%%%%%%   For small arenas in the imaging scope    %%%%%%%%%%%%%%% There are two format types: %    (1) Separate tif files for each frame  (e.g. 'Experiment4_t10001.TIF', 'Experiment4_t10002.TIF'...  )%    (2) One multiple-tif file which consists of all frames.% For (1), seperate tif files, make sure that the files are SORTED. Use SortFileNames below. % Sort file names:  % If variable exist --> sort the filenames to fit real frame timing using pre-defined identifiers% SortFileNames.Sort      = false;SortFileNames.Sort      = true;SortFileNames.BeforeTimeString     = 'StreamEXP_';        % example: for file name such as 'StreamEXP_09180.TIF' representing the 10001 frame --> Use '_t'   SortFileNames.AfterTimeString      = '.tif';              % example: for file name such as 'Experiment4_t10001.TIF' representing the 10001 frame --> Use '.TIF'   SortFileNames.BeforeTimeString_DYE = 'StreamDYE_';       %%%%%%%%%%%%%%%%   Files names definition    %%%%%%%%%%%%%%TempFolder            = 'C:\Matlab_Temporary_Files';     % Another option is to use the Matlabroot work folder:   TempFolder = fullfile(matlabroot,'work');StatusFile            = fullfile(TempFolder,'inprogress.mat');TrackingVariablesFile = fullfile(TempFolder,'TrackingVariables_SL.mat');%% Movie and device information %%%%%%%%%%%%%%%%  Temporal resolution  %%%%%%%%%%%%%%%%FrameRate           = 30;     % Frame rate (Hz)%%%%%%%%%%%%%%%%  Frames of interest for worm tracking, background calculation and for dye patterns calculation  %%%%%%%%%%%%%%%%% Default: all frames of the movie are used for background and for worm tracking, and no dye patterns are calculated. %          If default parameters are needed comment the commands below (until Tracker Behavior section). TimeOfInterest.WormTracking             = [0 35];      % minutesTimeOfInterest.BackgroundCalculation    = [0 35];      % minutesTimeOfInterest.DyePatterns              = [0 18]+35;      % minutes. Dye analysis: t=0=gradient; t=7m=all; t=14m=none; t=18m=endTimeOfInterest.OnlyDye                  = [13.8 15.5]+35; % minutes. Estimated... FramesOfInterest.WormTracking           = round(FrameRate*60* TimeOfInterest.WormTracking);FramesOfInterest.BackgroundCalculation  = round(FrameRate*60* TimeOfInterest.BackgroundCalculation);FramesOfInterest.DyePatterns            = round(FrameRate*60* TimeOfInterest.DyePatterns);FramesOfInterest.OnlyDye                = round(FrameRate*60* TimeOfInterest.OnlyDye);if FramesOfInterest.WormTracking(1)==0,           FramesOfInterest.WormTracking(1)=1;           endif FramesOfInterest.BackgroundCalculation(1)==0,  FramesOfInterest.BackgroundCalculation(1)=1;  endif FramesOfInterest.DyePatterns(1)==0,            FramesOfInterest.DyePatterns(1)=1;            endif FramesOfInterest.OnlyDye(1)==0,                FramesOfInterest.OnlyDye(1)=1;            end%% Tracker behavior, display and CPU usage%%%%%%%%%%%%%%%%      For tracker     %%%%%%%%%%%%%%%%QuitMatlabWhenFinished  = true;PlotFrameRate           = 30;    % Display tracking results every 'PlotFrameRate' framesMAX_PerFrame_Calculation_Time = 100;  % Maximum allowed average calculation time per-frame [sec]. If more than that: script will stop.  %%%%%%%%%%%%%%%%   For 'Spawn' function    %%%%%%%%%%%%%%DefaultFragmentLength   = 400; % framesmax_processors          = 7; % For object detection: hard-drive access and memory is limiting. The sctipt slows down if too many processors are used.max_processors_ID       = 5; % For ID tracker: CPU is time is limiting and not memory or hard-drive access. The sctipt can use more CPU power in parallel.num_processors          = str2num(getenv('NUMBER_OF_PROCESSORS'));comp_name               = getenv('COMPUTERNAME');check_status_interval   = 30; %seconds%%%%%%%%%%%%%%%%   Set screen info  %%%%%%%%%%%%%%%%FigHandle = 1; %% Worms detection parameters: worm size, number, error accepted, background calculation and auto-threshold calculations %%%%%%%%%%%%%%%%     Worm size and number      %%%%%%%%%%%%%%%%MinWorm_size  = 0.035;MaxWorm_size  = 0.075;MaxNumOfWorms         = 2;    % Maximal number of worms in all arenas. Choose 1 for single worm analysis   DetectionErrorAllowed = 1;    % If more than this number of worms are missed- recalculate the threshold. Choose 1 for single worm analysis   %%%%%%%%%%%%%%%%     Movie Background      %%%%%%%%%%%%%%% Background_params.method        = 'median';% Background_params.method        = 'mean';    % mean is good enough for brightfield imagesBackground_params.method        = 'percentile_10';Background_params.FrameInterval = 200;Background_params.save          = false;Background_params.plot          = true;Background_params.UseOnlyFramesInFragement = false;  % When false --> All frames in the movie are used for background calculation                                                     % When true  --> Only frames within the current movie fragment are used for background calculation. Corrrected for short last fragements...   Background_params.CalcMaskAndVignetting_fromDye = true;        % when true  --> masks will be calculated from the arena image during dye flow.                                                                % This mask will be used to limit the worm-features during feature processing.                                                         if exist('FramesOfInterest','var')                                                         if isfield(FramesOfInterest,'BackgroundCalculation')        Background_params.StartFrame = FramesOfInterest.BackgroundCalculation(1);        Background_params.EndFrame   = FramesOfInterest.BackgroundCalculation(2);            endend        %%%%%%%%%%%%%%%%    Auto-threshold    %%%%%%%%%%%%%%AutoThreshold_params.ForceOneRealObject = false;          % if true, force Single WormAutoThreshold_params.use_filter      = 1;                      % averaging filter, disk(3)AutoThreshold_params.thrlist         = [1e-3:(-1e-4):5e-4, 4.5e-4, 4e-4:(-0.2e-4):1e-4];AutoThreshold_params.MinWorm_size    = MinWorm_size;           % Units =  mm^2. AutoThreshold_params.MaxWorm_size    = MaxWorm_size;           % Units =  mm^2. FLUORESCENCE_STREL1      = strel('disk',1);                          FLUORESCENCE_STREL2      = strel('disk',1);                        %%%%%%%%%%%%%%%%       Midline and worm matrix calculations    %%%%%%%%%%%%%%MidlineCalculationParams.ScalingFactor                    = 10;    % The midline will be oversampled by this factor in order to increase accuracy of transformation to worms coordinates;MidlineCalculationParams.InterpolationFactor              = 5e-2;  % for csaps spline function of midline X-Y coordinateMidlineCalculationParams.InterpolationFactorBodyAngle     = 2e-4;  % for csaps spline function of midline angles. More smoothed!MidlineCalculationParams.PlotCalculationFigures           = false;  % optional parameter. set 'true' for plotting calculation figures  MidlineCalculationParams.WormMatrixWidth                  = 35  ; MidlineCalculationParams.WormMatrixLength                 = 460 ;MidlineCalculationParams.WormRealWidth                    = 70;    % estimation with overshoot,  micro-metersMidlineCalculationParams.MaximumDeviationFromMedianLength = 20;% % This are the relative distances from the midline edges that will be used to quantify midline gray scale and use it for head vs. tail segmentation. % %   e.g. [0.055 0.11] --> look at a distance of between 5.5% to 11% of the midline length, from each edge. What are the grey scale values there?   % MidlineCalculationParams.DistanceAlongMidline_ForHeadvsTail = [0.055 0.11];    % MidlineCalculationParams.MaximumDeviationFromMedianLength   = 20;           % Maximum deviation allowed (in [%]) from the median midline lengths that was found in all worms within the arena.%                                                                             % This is used to flag out all Midlines that were 'too short' due to error in morphology calculations.  %% Parameters for tracks linkingMaxSpeedForTrackLinking_mm_sec = 1.5;  % max allowed speed (mm/sec) for connecting a new worm object to an existing track (without IDing).                                        % This is converted to pixels per frame within the function.                                        % NOTE THAT THIS IS A VERY HIGH TOLERANCE SINCE POSSIBLE MULTIPLE POSSIBLE LINKING IS WELL MONITORED!!  MaxRelativeSizeChange = 50;            % [%] Maximal Relative size changed for connecting a new worm object to an existing track (without IDing).                                        %   max change between two consecutive frames: (current_area-previous_area)/previous_area <  (MaxRelativeSizeChange/100)                                       MinTrackLength        = 2;             % Min Length of a valid track (in FRAMES)                               NumberOfWormsInFOVIsConstant          = true;MaxTimeForLinkingBasedOnLocationVec   = [0.3 1   2    5  ];MaxSpeedForTrackLinking_mm_sec_Link2  = [1.5 0.7 0.4  0.4];MaxSpeedForTrackLinking_mm_sec_Link1  = MaxSpeedForTrackLinking_mm_sec_Link2/3;MaxAbsoluteDistanceForTrackLinking_mm = [inf inf inf  0.2]  ;%% Behavior segmentation settingsSegmentationSettings = SegmentationSettings_ImagingSetup_v02;SegmentationSettings.AllowVeryLongTracks = true;%% save (TrackingVariablesFile);pause(6);         % Make sure the mat file is saved before continuing the program. return%% User interface files and file/directory generationfunction [FinishPreviousTrackingSession, All_Files] = Check_incomplete_tracking_files (TempFolder)%  Check for incomplete tracking filesFinishPreviousTrackingSession = 0;StatusFile = fullfile(TempFolder,'inprogress.mat');delete(fullfile(TempFolder,'_F*')); % temporary files to monitor progressif exist(StatusFile,'file')==2    load(StatusFile);               if exist('All_Files','var') && ~all([All_Files.BehaviorSegmented])   % Uncompleted fragments        FinishPreviousTrackingSession = 1;        MoviesCompletionStatus = [All_Files.BehaviorSegmented];        Num_UnfinishedMovies   = length(find(~MoviesCompletionStatus));        Num_Movies             = length(MoviesCompletionStatus);         disp(['*** Unfinished jobs found: ,',num2str(Num_UnfinishedMovies),'/',num2str(Num_Movies),' movies']);                    else        All_Files = [];    endelse    All_Files = [];endreturnfunction [FileNum, Name] = GetFileNames (SortFileNames, avi_format)% modified from the functgion 'GetFileNames_Fluor'    if SortFileNames.Sort     BeforeTimeString = SortFileNames.BeforeTimeString;   % example: for file name such as 'Experiment4_t10001.TIF' representing the 10001 frame --> Use '_t'       AfterTimeString  = SortFileNames.AfterTimeString;    % example: for file name such as 'Experiment4_t10001.TIF' representing the 10001 frame --> Use '.TIF'       if isfield(SortFileNames,'BeforeTimeString_DYE')        BeforeTimeString_DYE = SortFileNames.BeforeTimeString_DYE;       endendFileNum = str2num(cell2mat(inputdlg('How many movies do you want to track?')));if FileNum>1    button = questdlg({'Select a parent directory that contains all relevant movies directories?','NOTE: ALL sub-directories will be considered as pathes for movies'},'','Yes','No','No');     if strcmpi(button,'Yes')        UserPrompt     = 'Select a parent directory that contains all relevant movies directories';        ParentPathName = uigetdir('', UserPrompt);        AllMoviesNames = dir(ParentPathName);        AllMoviesNames = {AllMoviesNames(3:end).name};        FileNum        = length(AllMoviesNames);    endendfor MovieNum = 1:FileNum    if ~exist('AllMoviesNames','var')        UserPrompt = ['Select Directory with Files For Analysis of Movie #' num2str(MovieNum)];        PathName   = uigetdir('', UserPrompt);    else        PathName = [ParentPathName,'\',AllMoviesNames{MovieNum}];    end       index = strfind(PathName,'\');     index = index(end)+1;    Name(MovieNum).MoviePath  = PathName;    Name(MovieNum).MovieName  = PathName(index:end);        cd (PathName);      ALLFILES = dir;    ALLFILES = ALLFILES(3:end);  % exclude the '.' and '..'    Name(MovieNum).FileNames  = {ALLFILES.name};        Name(MovieNum).TrackFile  = [Name(MovieNum).MoviePath, '\',  Name(MovieNum).MovieName, '.mat'];            if avi_format           % Keep Only '.avi'        C           = strfind(Name(MovieNum).FileNames,'.avi');                 AviFile_TF  = false(1,length(C));            for file_ind = 1:length(C)            AviFile_TF(file_ind) = ~ isempty(C{file_ind});         end                    TrueFiles = AviFile_TF;            else                            % Keep Only '.tif' or '.TIF' files !!!!!        C           = strfind(Name(MovieNum).FileNames,'.tif');                 TiffFile_TF = false(1,length(C));            for file_ind = 1:length(C)            TiffFile_TF(file_ind) = ~ isempty(C{file_ind});         end            if isempty(find(TiffFile_TF,1))            C       = strfind(Name(MovieNum).FileNames,'.TIF');             for file_ind = 1:length(C)                TiffFile_TF(file_ind) = ~ isempty(C{file_ind});             end        end        TrueFiles = TiffFile_TF;    end                    Name(MovieNum).FileNames = Name(MovieNum).FileNames(TrueFiles);        if SortFileNames.Sort           if ~exist('BeforeTimeString_DYE','var')                      FileNames = Name(MovieNum).FileNames;                    C_after   = strfind(Name(MovieNum).FileNames,AfterTimeString);             C_before  = strfind(Name(MovieNum).FileNames,BeforeTimeString);            last_ind  = cell2mat(C_after)-1;            first_ind = cell2mat(C_before)+length(BeforeTimeString);            Time = zeros(1,length(FileNames));            for file_ind = 1:length(FileNames)                Time(file_ind) = str2num(FileNames{file_ind}(first_ind(file_ind):last_ind(file_ind)));            end            [~, Sorted_indices] = sort(Time);            FileNames = FileNames(Sorted_indices);            Name(MovieNum).FileNames =  FileNames;                       [~, Sorted_indices] = sort(Time);            FileNames = FileNames(Sorted_indices);            Name(MovieNum).FileNames =  FileNames;            else            AllFileNames = Name(MovieNum).FileNames;                    C_after   = strfind(Name(MovieNum).FileNames,AfterTimeString);             C_before  = strfind(Name(MovieNum).FileNames,BeforeTimeString);            C_beforeDYE = strfind(Name(MovieNum).FileNames,BeforeTimeString_DYE);            TrueIfExp_FalseIfDye = false(1,length(AllFileNames));            Time                 = zeros(1,length(AllFileNames));            % Experiment files            for file_ind = 1:length(AllFileNames)                first_ind = C_before{file_ind}+length(BeforeTimeString);                if isempty(first_ind)                    continue                end                last_ind                       = C_after{file_ind}-1;                                Time(file_ind)                 = str2num(AllFileNames{file_ind}(first_ind:last_ind));                TrueIfExp_FalseIfDye(file_ind) = true;            end            % Dye files            for file_ind = 1:length(AllFileNames)                first_ind = C_beforeDYE{file_ind}+length(BeforeTimeString);                if isempty(first_ind)                    continue                end                last_ind                       = C_after{file_ind}-1;                                Time(file_ind)                 = str2num(AllFileNames{file_ind}(first_ind:last_ind));            end            ExperimentFiles     = AllFileNames(TrueIfExp_FalseIfDye);            ExperimentTime      = Time(TrueIfExp_FalseIfDye);                                    [~, Sorted_indices] = sort(ExperimentTime);            Name(MovieNum).ExpFileNames =  ExperimentFiles(Sorted_indices);                            DyeFiles            = AllFileNames(~TrueIfExp_FalseIfDye);            DyeTime             = Time(~TrueIfExp_FalseIfDye);                                    [~, Sorted_indices] = sort(DyeTime);            Name(MovieNum).DyeFileNames =  DyeFiles(Sorted_indices);                           Name(MovieNum).FileNames =  [Name(MovieNum).ExpFileNames, Name(MovieNum).DyeFileNames];           end                endendcd ..returnfunction File = GetUserInput (Name, TrackingVariablesFile)load (TrackingVariablesFile);  % All additional manual data -- INCLUDING 'avi_format' !!!!!!!!!AutoDefine_Image_as_OneArena    = false;     % If true --> skip the arenas location definitions. The whole image will be considered as one arena (number 1).AutoDefine_PixelSize            = false;     % If true --> skip the pixel size definition. The pixel size MUST BE PRE-DEFINED in this field: 'PixelSize'. UseFirstFrameInsteadOfBackground = false;    % If true --> skip the background calculationn and the user interface is done on the first frame. Much faster for Long/high resolution movies.DefineOutOfBoundPolygons        = true;     % If true --> define additional locations within the arenas that are considered out-of-bound for behavior segmentation                                             % Necessary of SLG7 gradient devices  DefineInBoundArena              = false;if exist('UserInterfaceMode','var')    if isfield(UserInterfaceMode,'UseFirstFrameInsteadOfBackground')                UseFirstFrameInsteadOfBackground = UserInterfaceMode.UseFirstFrameInsteadOfBackground;     end            if isfield(UserInterfaceMode,'AutoDefine_Image_as_OneArena')                AutoDefine_Image_as_OneArena = UserInterfaceMode.AutoDefine_Image_as_OneArena;        if AutoDefine_Image_as_OneArena            arena = 1;        end    end     if isfield(UserInterfaceMode,'DefineOutOfBoundPolygons')                DefineOutOfBoundPolygons = UserInterfaceMode.DefineOutOfBoundPolygons;    end     if isfield(UserInterfaceMode,'DefineInBoundArena')                DefineInBoundArena = UserInterfaceMode.DefineInBoundArena;    end     if isfield(UserInterfaceMode,'AutoDefine_PixelSize')                if UserInterfaceMode.AutoDefine_PixelSize            AutoDefine_PixelSize        = UserInterfaceMode.AutoDefine_PixelSize;  % If true --> skip the pixel size definition. The pixel size MUST BE PRE-DEFINED in this field: 'PixelSize'.             PixelSize_AutoDefinedValue  = UserInterfaceMode.PixelSize ;            % Pixel size. UNITS = pixel per mm        end    endendif ~exist('ScalingTitle','var')    ScalingTitle='';end% Get User Input for a single movie frameif ~ avi_format    if length(Name.FileNames)>1        MovieFirstFrame         = fullfile(Name.MoviePath, Name.FileNames{2});  % use second frame for arena definitions due to camera error in the first frame of some movies (bug in the imaging scope)    else        MovieFirstFrame         = fullfile(Name.MoviePath, Name.FileNames{1});  % First frame = first tiff    endendShortMovieName          = Name.MovieName;TrackSettingsName       = fullfile(Name.MoviePath,[ShortMovieName,'_TrackSettings.mat']);CollectTrackingSettings = true;%% Try to use existing tracking settings --> NEED TO BE DEBUGGED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  if exist(TrackSettingsName) == 2    ButtonName = questdlg('Use existing tracking settings?','','Yes', 'No', 'Yes');    if strcmp(ButtonName,'Yes')        try            load(TrackSettingsName,'FileSettings');            File = FileSettings;            % check filenames            disp('Filenames are not checked !!!!');            if strcmp (Name.MoviePath, File.MoviePath) % if there is a match between the name of the chosen file and the name in the setting file                                CollectTrackingSettings = false;            else                disp('Filenames don''t match... reselect manually.');            end            if ~isfield(File,'ClaimedFragments') || isempty(File.ClaimedFragments)                File.ClaimedFragments = File.CompletedFragments;  % redo all fragment that were not completed in previous run            end        catch            disp('Error loading settings.  Select manually...');        end    endend%% Manual settings collectionif CollectTrackingSettings    % Assign Movie names to File    File.MoviePath      = Name.MoviePath;    File.MovieFileNames = Name.FileNames;        %% Find whether the file format is a MULTIPLE_TIFF file         if avi_format   %%%%%   avi format    %%%%%                    if length(Name.FileNames)==1    % The full movie is a SINGLE .avi movie            File.VideoFormat  = 'avi';            File.MovieName    = [File.MoviePath,'\',File.MovieFileNames{1}];            MovieObj          = VideoReader(File.MovieName);            FrameNum          = MovieObj.Duration * MovieObj.FrameRate;  % duration of movie display * FrameRate of movie display = number of frames. THIS IS NOT THE REAL TIME AND TEMPORAL RESOLUTION !                               else                            % The full movie is a SEQUENCE of short .avi movies                        File.VideoFormat  = 'multi-avi';                                    File.MovieName    = Name.MovieName;            % Cell array of avi movies            FramesPerAviFile  = zeros(1,length(File.MovieFileNames));                                    disp('Reading files and assigning movie parameters');            NextFirstFrame = 1;            for file_ind = 1:length(File.MovieFileNames)                                MovieObj                   = VideoReader([File.MoviePath,'\',File.MovieFileNames{file_ind}]);                NumOfFrames                = round(MovieObj.Duration * MovieObj.FrameRate);  % duration (of movie display) * FrameRate (of movie display) = number of frames. THIS IS NOT THE REAL TIME AND TEMPORAL RESOLUTION !                                         FramesPerAviFile(file_ind) = NumOfFrames;%                 MultiAviFrameConversion.MovieFileNumber(NextFirstFrame:(NextFirstFrame+NumOfFrames-1)) = file_ind;%                 MultiAviFrameConversion.MovieFileNumber(NextFirstFrame:(NextFirstFrame+NumOfFrames-1)) = 1:NumOfFrames;                NextFirstFrame             = NextFirstFrame + NumOfFrames;            end                                             FrameNum                = sum(FramesPerAviFile);    % This is the TOTAL number of frames in all avi files.                         File.FramesPerAviFile   = FramesPerAviFile;                        MultiAviFrameConversion.MovieFileNumber   = single(zeros(1,FrameNum));            MultiAviFrameConversion.FrameNumberInFile = single(zeros(1,FrameNum));            NextFirstFrame = 1;            CumSumFrames   = cumsum(FramesPerAviFile);            for file_ind = 1:length(File.MovieFileNames)                MultiAviFrameConversion.MovieFileNumber(NextFirstFrame:(CumSumFrames(file_ind)))   = file_ind;                MultiAviFrameConversion.FrameNumberInFile(NextFirstFrame:(CumSumFrames(file_ind))) = 1:FramesPerAviFile(file_ind);                NextFirstFrame = CumSumFrames(file_ind)+1;            end                    end         File.FrameSize               = [MovieObj.Height  MovieObj.Width];        File.MultiAviFrameConversion = MultiAviFrameConversion;    else           %%%%%   tif format    %%%%%                   info = imfinfo(MovieFirstFrame);            File.info_firstframe = info(1);        if length(info) > 1                     % ONE multiple-tiff file            File.VideoFormat        = 'multi-tiff';                        File.MovieName          = [File.MoviePath,'\',File.MovieFileNames{1}];            FrameNum                = length(info);        else                                    % SEQUENCE of tiff files            File.VideoFormat        = 'tiff';                       File.MovieName          = Name.MovieName;            FrameNum                = length(Name.FileNames);        end                 File.FrameSize              = [File.info_firstframe.Height  File.info_firstframe.Width];    end    File.NumberOfFramesInMovie_IncludingDyeAnalysis = FrameNum;   % All frames in the movie    File.NumberOfFrames                             = FrameNum;   % All frames that are going to be worm-tracked         if exist('FramesOfInterest','var')                                                             if isfield(FramesOfInterest,'WormTracking')            if FramesOfInterest.WormTracking(2) <= FrameNum                File.NumberOfFrames = FramesOfInterest.WormTracking(2);                disp(['Only the first ',num2str(File.NumberOfFrames),' frames are analyzed for worm behavior'])            else                disp(['Movie is truncated after ', num2str(File.NumberOfFrames),' frames. CHECK DEFINITIONS FOR FRAMES RELEVANT TO WORM TRACKING !!! '])            end        end        if isfield(FramesOfInterest,'DyePatterns')            File.DyePatternsFrames = FramesOfInterest.DyePatterns;            if File.DyePatternsFrames(2)>FrameNum                File.DyePatternsFrames(2)=FrameNum;            end            disp(['Frames [',num2str(File.DyePatternsFrames),'] are analyzed for dye patterns'])        end            end    figure(FigHandle);     set(FigHandle,'MenuBar','none','Toolbar','none','Position',[150 100 1020 900],'name',['Movie name: ',ShortMovieName]);    %%    if UseFirstFrameInsteadOfBackground        FileFullName   = [File.MoviePath,'\', File.MovieFileNames{1}];        if     strcmpi(File.VideoFormat,'multi-tiff')         % A single multiple-tiff file            MovFrame       = imread(FileFullName, 2);       % due to bug in imaging scope: read the second frame        elseif strcmpi(File.VideoFormat,'tiff')               % A sequence of tiff files            MovFrame       = imread(FileFullName);                     elseif strcmpi(File.VideoFormat,'avi')||strcmpi(File.VideoFormat,'multi-avi')            % A single avi movie file or A sequence of avi movie files                        MovieObj       = VideoReader(FileFullName);            MovFrame       = read(MovieObj, 1);               end                     else        background = getbackground_inline(File, Background_params);        MovFrame   = background;    end    figure(FigHandle);     imshow(MovFrame,[]);                       %   imshow(background,[400 700]);                 %% --------get information----------    buttony = 10;    MovSize = File.FrameSize;    FrameStart = 1;    NumFragments = max(ceil(File.NumberOfFrames/DefaultFragmentLength),1);          uicontrol('Style','text','Position',[110 buttony 170 20],'String','Frames for worm tracking');    h2a = uicontrol('style','edit','Position',[270 buttony 50 20],'String',num2str(FrameStart));    h2  = uicontrol('style','edit','Position',[320 buttony 50 20],'String',num2str(File.NumberOfFrames));    h2b = uicontrol('style','edit','Position',[380 buttony 20 20],'String',num2str(NumFragments));          uicontrol('Style','text','Position',[500 buttony 60 20],'String','Arena(mm)');    h4  = uicontrol('style','edit','Position',[560 buttony 40 20],'String',num2str(arena));          uicontrol('Style','text','Position',[640 buttony 60 20],'String','FrameRate');    h5  = uicontrol('style','edit','Position',[700 buttony 30 20],'String',num2str(FrameRate));        %% Get arena tracking regions    if AutoDefine_Image_as_OneArena        ar = 1;        File.Arena(ar).TrackBox = [1 1 MovSize(2) MovSize(1)];    else        ar = 0;        txt = 'SELECT TRACKING AREAS: click inside to confirm, outside to redo, Enter to end.';        title(txt);         label = text(MovSize(2)/2,MovSize(1)*0.4,txt,'FontSize',18,'HorizontalAlignment','center');        success = 0;         while success == 0            box = getrect(FigHandle); box = box+(box==0); h = rectangle('Position',box); set(h,'EdgeColor',[1,0,0]);            [X,Y,button] = ginput(1);             if isempty(button)                success = true;            elseif button == 1 && (X-box(1) >= 0 && X-box(1) <= box(3) && Y-box(2) >= 0 && Y-box(2) <= box(4))                ar = ar+1; % arena #                File.Arena(ar).TrackBox = box+(box==0);                set(h,'EdgeColor',[0,0,1]);                 ht = text(box(1)+box(3)/2,box(2)+box(4)/2,num2str(ar)); set(ht,'FontSize',36,'Color',[0 0 1]);            end        end    end               %% assign information into 'File'    File.NumArenas            = ar;    File.ArenaSize            = str2num(get(h4,'String'));     File.TrackFile            = Name.TrackFile;    File.TempFolder           = TempFolder;    File.StatusFile           = StatusFile;    File.TrackingVariablesFile= TrackingVariablesFile;    File.TrackFrames          = str2num(get(h2,'String'));    File.StartFrame           = str2num(get(h2a,'String'));    File.ImageSize            = MovSize;    File.FrameRate            = str2num(get(h5,'String'));    File.Fragments            = str2num(get(h2b,'String'));    File.StartFragment        = 1;    File.CompletedFragments   = zeros(1,File.Fragments);    File.ClaimedFragments     = zeros(1,File.Fragments);    File.BehaviorSegmentation.ClaimedArenas   = false(1,ar);    File.BehaviorSegmentation.CompletedArenas = false(1,ar);    File.Stitched             = 0;    File.BehaviorSegmented    = 0;    %% get scale info . Assign into File       if AutoDefine_PixelSize        PixelSize  = PixelSize_AutoDefinedValue;    else               txt = ['GET SCALING: ',ScalingTitle,' = ',get(h4,'String'),'mm'];                imshow(imadjust(MovFrame,stretchlim(MovFrame,[0.01 0.9995])));                title(txt);  label = text(MovSize(2)/2,MovSize(1)*0.4,txt,'FontSize',18,'HorizontalAlignment','center');        [X,Y] = ginput(2);         arenapix  = sqrt((Y(2)-Y(1))^2+(X(2)-X(1))^2);         PixelSize = arenapix / File.ArenaSize;   % UNITS = pixel per mm    end    File.PixelSize            = PixelSize;                      % UNITS = pixel per mm           %% Fragement Frames information         hi              = File.TrackFrames;    lo              = File.StartFrame;    NumFragments    = File.Fragments;    perfrag         = ceil((hi-lo+1)/NumFragments);    frfr            = [lo+(0:(NumFragments-1))*perfrag]';    frfr            = [frfr, [frfr(2:NumFragments)-1; hi]];          File.FragmentFrames = frfr;    disp([datestr(now),' Image Data Collected for Movie: ',ShortMovieName]);    FileSettings = File;    save(TrackSettingsName,'FileSettings');else        % just get the movie frame    if UseFirstFrameInsteadOfBackground        FileFullName   = [File.MoviePath,'\', File.MovieFileNames{1}];        if     strcmpi(File.VideoFormat,'multi-tiff')         % A single multiple-tiff file            MovFrame       = imread(FileFullName, 2);       % due to bug in imaging scope: read the second frame        elseif strcmpi(File.VideoFormat,'tiff')               % A sequence of tiff files            MovFrame       = imread(FileFullName);                     elseif strcmpi(File.VideoFormat,'avi')||strcmpi(File.VideoFormat,'multi-avi')            % A single avi movie file or A sequence of avi movie files                        MovieObj       = VideoReader(FileFullName);            MovFrame       = read(MovieObj, 1);               end                     else        background = getbackground_inline(File, Background_params);        MovFrame   = background;    end    endFile.VariablesInformation = load (File.TrackingVariablesFile);File                      = DefineArenaAreas (File, MovFrame);% Define necessray filenames and fields        NumArenas     = File.NumArenas;File.FileNames.ConcatinatedTracks               = cell(1,NumArenas);File.FileNames.SafeStitchedTracks               = cell(1,NumArenas);File.FileNames.SegmentedTracks                  = cell(1,NumArenas);File.FileNames.SegmentedAndForcedStitchedTracks = cell(1,NumArenas);File.FileNames.DataMatrices                     = cell(1,NumArenas);File.FileNames.DataMatrices_ArenaDelayCorrected = cell(1,NumArenas);File.FileNames.DataMatrices_AllDelaysCorrected  = cell(1,NumArenas);File.NumberOfTracks                             = zeros(1,NumArenas);File.MaxNumOfWorms                              = zeros(1,NumArenas);for ar = 1:NumArenas                 File.FileNames.ConcatinatedTracks{ar}               = [File.TrackFile(1:end-4),'_Concatinated_NotStitched_Arena',num2str(ar),'.mat'];    File.FileNames.SafeStitchedTracks{ar}               = [File.TrackFile(1:end-4),'_SafeStitchedTracks_Arena',num2str(ar),'.mat'];        File.FileNames.SegmentedTracks{ar}                  = [File.TrackFile(1:end-4),'_SegmentedTracks_Arena',num2str(ar),'.mat'];        File.FileNames.SegmentedAndForcedStitchedTracks{ar} = [File.TrackFile(1:end-4),'_SegmentedAndForcedStitchedTracks_Arena',num2str(ar),'.mat'];        File.FileNames.DataMatrices{ar}                     = [File.TrackFile(1:end-4),'_DataMatrices_Arena',num2str(ar),'.mat'];    File.FileNames.DataMatrices_ArenaDelayCorrected{ar} = [File.TrackFile(1:end-4),'_DataMatrices_ArenaDelayCorrected',num2str(ar),'.mat'];        File.FileNames.DataMatrices_AllDelaysCorrected{ar}  = [File.TrackFile(1:end-4),'_DataMatrices_AllDelaysCorrected',num2str(ar),'.mat'];    endif DefineOutOfBoundPolygons    File = DefineOutOfBoundsForBehaviorSegmentation(File, MovFrame);endclose;return function File = DefineInBoundAreas (File)load (File.TrackingVariablesFile);  % All additional manual data -- INCLUDING 'avi_format' !!!!!!!!!if isfield(File,'InBoundBox')    DefineInBoundArena = false;    for ar=1:length(File.Arena)        File.Arena(ar).InBoundBox = File.Arena(ar).TrackBox;    end        disp('In bound regions are already defined. skipping in-bound definition');    else    DefineInBoundArena = true;endtry     load(File.BackgroundFile,'Mask')    MovFrame = Mask;catch    load(File.BackgroundFile,'background')    MovFrame = background;end    %% Get arena IN-BOUND regionsif DefineInBoundArena       figure;     imshow(MovFrame,[]);      MovSize = size(MovFrame);    ar = 0;    txt = 'Select IN-BOUND tracking areas: click inside to confirm, outside to redo, Enter to end.';    title(txt);     label = text(MovSize(2)/2,MovSize(1)*0.4,txt,'FontSize',18,'HorizontalAlignment','center');    success = 0;     while success == 0        box = getrect(FigHandle); box = box+(box==0); h = rectangle('Position',box); set(h,'EdgeColor',[1,0,0]);        [X,Y,button] = ginput(1);         if isempty(button)            success = true;        elseif button == 1 && (X-box(1) >= 0 && X-box(1) <= box(3) && Y-box(2) >= 0 && Y-box(2) <= box(4))            ar = ar+1; % arena #            File.Arena(ar).InBoundBox = box+(box==0);            set(h,'EdgeColor',[0,0,1]);             ht = text(box(1)+box(3)/2,box(2)+box(4)/2,num2str(ar)); set(ht,'FontSize',36,'Color',[0 0 1]);        end    end    close;end       return function File = DefineOutOfBoundsForBehaviorSegmentation(File, MovFrame)if isfield(File,'OutOfBoundPolygons')    ButtonName = questdlg('Use existing Out-Of-Bound Polygons settings?','','Yes', 'No', 'Yes');    if strcmp(ButtonName,'Yes')        return    else        disp('redefining polygons');    end    endMovSize = File.FrameSize;figure; imshow(MovFrame,[]);for ar=1:File.NumArenas    h     = rectangle('Position',File.Arena(ar).TrackBox); set(h,'EdgeColor',[1,0,0]);        for polygon_number=1:2        if polygon_number==1            side = 'left';        else            side = 'right';        end        txt = ['Select ' side,' polygon area (arena ',num2str(ar),'). Enter to end.'];        title(txt);         txt = ['Select ' side,' polygon area (arena ',num2str(ar),...               ')',char(10),'This area is out of bound for behaviour segmentation. Enter to end.'];        label = text(MovSize(2)/2,MovSize(1)*0.4,txt,'FontSize',18,'HorizontalAlignment','center');        success = false;         while success == 0                    [X,Y,button] = ginput;             X = [X(1:end); X(1)];            Y = [Y(1:end); Y(1)];            line_handle(ar) = line(X,Y,'color','b');            txt = 'Click inside to confirm first polygon or outside to redefine it';            set(label,'String',txt);            [x,y]=ginput(1);            in = inpolygon(x,y,X,Y);            if in                success = true;                set(line_handle(ar),'color','r');                 File.OutOfBoundPolygons{ar,polygon_number} = [X,Y];                delete(label);            else                delete(line_handle(ar));                txt = ['Select ', side,' polygon area (arena ',num2str(ar),...                       ')',char(10),'This area is out of bound for behaviour segmentation. Enter to end.'];                set(label,'String',txt);            end        end    end    delete(h);       clear h line_handle        endreturnfunction [TrackName, FragmentSaveNames, File, All_Files] =  MovieNames_MakeDir (File_in, All_Files_in, MovieNum)File      = File_in;All_Files = All_Files_in;% Movie file and track namesTrackName               = File.TrackFile;[pathname,filename,ext] = fileparts(TrackName);partsfolder             = '\trackfile parts\';FragmentSaveNames       = cell(File.Fragments,1); for i = 1:File.Fragments;    FragmentSaveNames(i) = {[pathname,partsfolder,filename,'_part',num2str(i),ext]}; endfor a = 1:length(File.Arena)    TrackBox                 = File.Arena(a).TrackBox;    File.TrackBox(a,:)       = TrackBox;    File.TrackBoxAxis(a,:)   = [TrackBox(1)  TrackBox(1)+TrackBox(3)  TrackBox(2)  TrackBox(2)+TrackBox(4)];      InBoundBox               = File.Arena(a).InBoundBox;    File.InBoundBox(a,:)     = InBoundBox;    File.InBoundBoxAxis(a,:) = [InBoundBox(1)  InBoundBox(1)+InBoundBox(3)  InBoundBox(2)  InBoundBox(2)+InBoundBox(4)];  endFile.FragmentSaveNames = FragmentSaveNames;% update All_FilesAll_Files(MovieNum).TrackBox          = File.TrackBox; All_Files(MovieNum).TrackBoxAxis      = File.TrackBoxAxis; All_Files(MovieNum).InBoundBox        = File.InBoundBox; All_Files(MovieNum).InBoundBoxAxis    = File.InBoundBoxAxis; All_Files(MovieNum).FragmentSaveNames = File.FragmentSaveNames; % make directory if it doesn't existsif ~exist([pathname,partsfolder],'dir')      mkdir([pathname,partsfolder]); endreturn function [File , Settings] = DefineArenaAreas (File, MovFrame)Settings                = File.VariablesInformation.SegmentationSettings;Settings.FrameRate      = File.FrameRate;Settings.PixelSize      = File.PixelSize;Settings.NumberOfFrames = File.NumberOfFrames;Settings.ImageSize      = File.ImageSize;File.VariablesInformation.SegmentationSettings = Settings;RedefineArenaPosition     = Settings.RedefineArenaPosition;DefineIDingArenaPosition  = Settings.DefineIDingArenaPosition;if (~RedefineArenaPosition)&&(~DefineIDingArenaPosition)    returnelse    MovSize = size(MovFrame);  end%% BEHAVIOR SEGMENTATIONf= figure('position',get(0,'ScreenSize'),'name',[File.MovieName,'- BEHAVIOR SEGMENTATION arenas']);    if RedefineArenaPosition    %% show background             imshow(MovFrame,[],'InitialMagnification','fit');%     imshow(background,[],'InitialMagnification','fit');                       %     imshow(background,[400 700]);      %% Show existing track box, is it OK or redefine it?     if isfield(File.Arena(1),'TrackBox')        clear h;        for ar=1:length(File.Arena)            h(ar) = rectangle('Position',File.Arena(ar).TrackBox); set(h,'EdgeColor',[1,0,0]);        end        ButtonName = questdlg('Are the arenas for BEHAVIOR SEGMENTATION well defined?','','Yes', 'No', 'No');                if strcmp(ButtonName,'No')            delete(h);            RedefineArenaPosition = true;        else            RedefineArenaPosition = false;        end    else        RedefineArenaPosition = true;    endend%% redefine the tracking boxif RedefineArenaPosition        ar = 0;    txt = 'SELECT TRACKING AREAS: click inside to confirm, outside to redo, Enter to end.';    title(txt);     text(MovSize(2)/2,MovSize(1)*0.4,txt,'FontSize',18,'HorizontalAlignment','center');    success = 0;     while success == 0        box = getrect(1); box = box+(box==0); h = rectangle('Position',box); set(h,'EdgeColor',[1,0,0]);        [X,Y,button] = ginput(1);         if isempty(button)            success = true;        elseif (button == 1) && (X-box(1) >= 0) && (X-box(1) <= box(3)) && (Y-box(2) >= 0) && (Y-box(2) <= box(4))            ar = ar+1; % arena #            File.Arena(ar).TrackBox = box+(box==0);            set(h,'EdgeColor',[0,0,1]);             ht = text(box(1)+box(3)/2,box(2)+box(4)/2,num2str(ar)); set(ht,'FontSize',36,'Color',[0 0 1]);        end    end     disp('Tracking areas for BEHAVIOUR SEGMENTATION were re-defined');  endFile.NumArenas = length(File.Arena);% Add File.TrackBoxAxis field. It needs to be fixed if the arenas are% redefined or if using Dirk's code that doesn't generate this fieldfor ar = 1:length(File.Arena)    Arena_Position          = File.Arena(ar).TrackBox;    File.TrackBoxAxis(ar,:) = [ceil(Arena_Position(1)) floor(Arena_Position(1)+Arena_Position(3)) ceil(Arena_Position(2)) floor(Arena_Position(2)+Arena_Position(4))]; endclose(f);    %% OUT OF BOUNDSf= figure('position',get(0,'ScreenSize'),'name',[File.MovieName,'- OUT OF BOUNDS and IDing arenas']);    if DefineIDingArenaPosition    %% show background             imshow(MovFrame,[],'InitialMagnification','fit');%     imshow(background,[],'InitialMagnification','fit');                       %     imshow(background,[400 700]);      %% Show existing track box, is it OK or redefine it?     if isfield(File,'IDingArena')        CurrentArenas = File.IDingArena;    else        CurrentArenas = File.Arena;    end                        clear h;    for ar=1:length(CurrentArenas)        h(ar) = rectangle('Position',CurrentArenas(ar).TrackBox); set(h,'EdgeColor',[1,0,0]);    end    ButtonName = questdlg('Are the arenas for OUT OF BOUNDS and for IDing well defined?','','Yes', 'No', 'No');            if strcmp(ButtonName,'No')        delete(h);        DefineIDingArenaPosition = true;    else        DefineIDingArenaPosition = false;    end               end%% redefine the tracking boxif DefineIDingArenaPosition        ar = 0;    txt = 'SELECT TRACKING AREAS: click inside to confirm, outside to redo, Enter to end.';    title(txt);     text(MovSize(2)/2,MovSize(1)*0.4,txt,'FontSize',18,'HorizontalAlignment','center');    success = 0;     while success == 0        box = getrect(1); box = box+(box==0); h = rectangle('Position',box); set(h,'EdgeColor',[1,0,0]);        [X,Y,button] = ginput(1);         if isempty(button)            success = true;        elseif (button == 1) && (X-box(1) >= 0) && (X-box(1) <= box(3)) && (Y-box(2) >= 0) && (Y-box(2) <= box(4))            ar = ar+1; % arena #            File.IDingArena(ar).TrackBox = box+(box==0);            set(h,'EdgeColor',[0,0,1]);             ht = text(box(1)+box(3)/2,box(2)+box(4)/2,num2str(ar)); set(ht,'FontSize',36,'Color',[0 0 1]);        end    end         NumOOBArenas = length(File.IDingArena);    if NumOOBArenas ~=  length(File.Arena)        disp('WARNING !!!  No match between Out of bounds arenas and behavior segmentation arenas.')    endelse    File.IDingArena   = File.Arena;end% Add File.TrackBoxAxis field. It needs to be fixed if the arenas are% redefined or if using Dirk's code that doesn't generate this fieldfor ar = 1:length(File.Arena)    Arena_Position          = File.IDingArena(ar).TrackBox;    File.IDingBoxAxis(ar,:) = [ceil(Arena_Position(1)) floor(Arena_Position(1)+Arena_Position(3)) ceil(Arena_Position(2)) floor(Arena_Position(2)+Arena_Position(4))]; endFile.InBoundArena    = File.IDingArena;File.InBoundBoxAxis  = File.IDingBoxAxis;close(f);    return%% Background calculation function [background, File] = getbackground_inline(File, Background_params)% This function is modified from the function getbackground_Fluor_v02% This function:%   Calculate the background from the median/mean/or percentile pixel levels depending on the user preference.    %   Uses gray scale pictures rather than a single channel.%-----------------------------------------------------------------------DirName     = File.MoviePath;FileNames   = File.MovieFileNames;FrameNum    = File.NumberOfFrames;  % This is the total number of frames in the movie, NOT the number of frames that are analyzed for background calculationMATSIZE     = File.FrameSize;if isfield(Background_params,'method')          % mean or median over the frames?     method = Background_params.method;else    method = 'median';endtry         load(File.BackgroundFile, 'background');    disp(['background file was already calculated for ',File.MovieName,'. Skipping background calculation.', char(10)])    returncatch    disp(['Calculating background for ',File.MovieName,' using ''',method,''' approach', char(10)])    end        if isfield(Background_params,'FrameInterval')   % Usually 50 frames    FrameInterval = Background_params.FrameInterval;else    FrameInterval = 50;endif isfield(Background_params,'StartFrame')      % First frame     StartFrame = Background_params.StartFrame;else    StartFrame = 1;endif isfield(Background_params,'EndFrame')        % Last frame     EndFrame = Background_params.EndFrame;else    EndFrame = FrameNum;endif isfield(Background_params,'plot')            % plot background     plot_background = Background_params.plot;else    plot_background = false;endif isfield(Background_params,'UseGaussianFilter')   % Usually 50 frames    UseGaussianFilter = Background_params.UseGaussianFilter;    GaussianFilter    = fspecial('gaussian', Background_params.GaussianFilter.hsize, Background_params.GaussianFilter.sigma); else    UseGaussianFilter = false;endif UseGaussianFilter    disp('A Gaussian filter is applied to the movie frames and background');end% Assign Movie Format Codeif     strcmpi(File.VideoFormat,'tiff')    VideoFormat   = 1;elseif strcmpi(File.VideoFormat,'multi-tiff')    VideoFormat   = 2;    FileFullName  = [DirName,'\',FileNames{1}]; elseif strcmpi(File.VideoFormat,'avi')    VideoFormat   = 3;    FileFullName  = [DirName,'\',FileNames{1}];     MovieObj      = VideoReader(FileFullName);elseif strcmpi(File.VideoFormat,'multi-avi')    VideoFormat   = 4;    PreviousMovieObjFile = 0; % read new file object if and when it is needed else    disp('unknown format. aborting @ background calculation ...');    returnenddisp(['Background calculating from ',int2str(StartFrame),' to ',int2str(EndFrame),' in increments of ',int2str(FrameInterval)]);NumOfFrames = round((EndFrame-StartFrame+1)/FrameInterval);progbars    = 10;if strcmpi(method,'median') || strcmpi(method,'percentile_10')        MaxAllowedNumOfFrames   = 100;    if NumOfFrames > MaxAllowedNumOfFrames        FrameInterval = round((EndFrame-StartFrame+1) / MaxAllowedNumOfFrames);        NumOfFrames   = round((EndFrame-StartFrame+1)/FrameInterval);        disp(['To avoid large computation time, FrameInterval is enlarged to ',int2str(FrameInterval)]);    end        cdata_mat   = uint16(zeros(MATSIZE(1),MATSIZE(2),NumOfFrames));    ind         = 0;    for Frame = StartFrame:FrameInterval:EndFrame        ind = ind+1;        % Read frame, depending on the video format        if VideoFormat==2                       % A single multiple-tiff file            Mov                = imread(FileFullName, Frame);             elseif VideoFormat==1                   % A sequence of tiff files            FileFullName       = [DirName,'\',FileNames{Frame}];             Mov                = imread(FileFullName);                                  elseif VideoFormat==3                   % A single avi movie file            Mov                = read(MovieObj, Frame);                 Mov                = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!        elseif VideoFormat==4                   % A sequence of avi movie files            CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);                        if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                FileFullName         = [DirName,'\',FileNames{CurrentMovieObjFile}];                 PreviousMovieObjFile = CurrentMovieObjFile;                MovieObj             = VideoReader(FileFullName);            end            CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);            Mov                      = read(MovieObj, CurrentFrameNumberInFile);                 Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                   end                if UseGaussianFilter           Mov = imfilter(Mov,GaussianFilter);         end                % store frame data        cdata_mat(:,:,ind) = Mov;              if mod(Frame * progbars,(EndFrame-StartFrame+1)) < progbars*FrameInterval     % Progress bar- 10x ':'            fprintf(':');         end        end    cdata_mat = single(cdata_mat);        if UseGaussianFilter        cdata_mat = imfilter(cdata_mat,GaussianFilter);    end        fprintf('\nCalculating median\n');    cdatamean       = mean(cdata_mat,3);    background_mean = uint16(round(cdatamean));    cdatamedian       = median(cdata_mat,3);    background_median = uint16(round(cdatamedian));            if strcmpi(method,'median')         background = background_median;    elseif strcmpi(method,'percentile_10')        fprintf('\nCalculating percentile [10%] \n');        % prctile returns percentiles of the values in cdata along the 3rd dimention. p is a scalar or a vector of percent values.        % BEWARE!!! This is a Matlab Function but may be called to Dirk's one on the path !!         p                     = 10;        cdata_percentile      = prctile(double(cdata_mat),p,3);                     background_percentile = uint16(round(cdata_percentile));        background            = background_percentile;    end           if plot_background        figure('name','background');         if strcmpi(method,'percentile_10')            subplot(1,3,1); h(1)=imshow(background_mean,[]);       title('mean');               subplot(1,3,2); h(2)=imshow(background_median,[]);     title('median');             subplot(1,3,3); h(3)=imshow(background_percentile,[]); title([num2str(p),' percent']);         else            subplot(1,2,1); h(1)=imshow(background_mean,[]);       title('mean');               subplot(1,2,2); h(2)=imshow(background_median,[]);     title('median');         end                  % figure; imagesc(background_mean - background_median); colorbar; set(gca,'Clim',[0 10])    end    else   % MEAN    if ~strcmpi(method,'mean')             disp('Background calculation method is not properly defined. Using mean...');    end        MaxAllowedNumOfFrames   = 400;    if NumOfFrames > MaxAllowedNumOfFrames        FrameInterval = round((EndFrame-StartFrame+1) / MaxAllowedNumOfFrames);        NumOfFrames   = round((EndFrame-StartFrame+1)/FrameInterval);        disp(['To avoid large computation time, FrameInterval is enlarged to ',int2str(FrameInterval)]);    end        cdata_mat = single(zeros(MATSIZE));    for Frame = StartFrame:FrameInterval:EndFrame         % Read frame, depending on the video format         if VideoFormat==2                       % A single multiple-tiff file            Mov                = imread(FileFullName, Frame);             elseif VideoFormat==1                   % A sequence of tiff files            FileFullName      = [DirName,'\',FileNames{Frame}];             Mov                = imread(FileFullName);                                  elseif VideoFormat==3                   % A single avi movie file            Mov                = read(MovieObj, Frame);                 Mov                = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!        elseif VideoFormat==4                   % A sequence of avi movie files            CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);            if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                FileFullName        = [DirName,'\',FileNames{CurrentMovieObjFile}];                 PreviousMovieObjFile = CurrentMovieObjFile;                MovieObj             = VideoReader(FileFullName);            end            CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);            Mov                      = read(MovieObj, CurrentFrameNumberInFile);                 Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                   end                if UseGaussianFilter           Mov = imfilter(Mov,GaussianFilter);         end                % Add to previous frames        cdata_mat     = cdata_mat + single(Mov);        if mod(Frame * progbars,(EndFrame-StartFrame+1)) < progbars*FrameInterval     % Progress bar- 10x ':'            fprintf(':');         end        end    if UseGaussianFilter        cdata_mat = imfilter(cdata_mat,GaussianFilter);    end    background = uint16(cdata_mat/NumOfFrames);    fprintf('\n');    if plot_background        figure('name','background (mean)'); %         imagesc(background);  set(gca,'Clim',[0 255]); title('mean');   colorbar        imshow (background,[]);  set(gca,'Clim',[0 255]); title('mean');   colorbar    endend% Transfer background to uint8 if movie was in uint8 formatX=whos('Mov'); CLASS = X.class;if strcmpi(CLASS,'uint8')    background = uint8(background);end% save background mat fileFile.BackgroundFile = [File.TrackFile(1:end-4),'_background.mat'];save(File.BackgroundFile, 'background');% save background image if Background_params.save       [FileName,PathName] = uiputfile('*.bmp', 'Save Background Image');    if FileName ~= 0        imwrite(uint8(background),[PathName, FileName], 'bmp');    endendif isfield(Background_params,'CalcMaskAndVignetting_fromDye')    if Background_params.CalcMaskAndVignetting_fromDye        %%        % Step 1: Define area in the middle of FOV that consist of both a post and non-post areas.            % Step 2: Find frames with maximal dye intensity            % Step 3: Define maximal intensity of dye and maximal intensity of posts. Use them to generate Masks and vignetting reference.           %              Maximal post intensity is used as Mask threhold           %              Maximal dye intensity is used as a reference for vignetting calculation         %   NOTE !!! I assume that minimal dye pattern values (at frame edges) are larger than maximal post levels (in the middle)            %% Step 1: Define area in the middle of FOV that consist of both a post and non-post areas.        Midpoint_Coordinates      = round(MATSIZE/2);         TwiceRadiusOfPostInPixels = File.PixelSize*0.4/2;       % PixelSize == pixel/mm        MidCircle                 = false(MATSIZE);        MidCircle(Midpoint_Coordinates(1),Midpoint_Coordinates(2)) = 1;               SE                        = strel('disk', round(TwiceRadiusOfPostInPixels),0);        MidCircle                 = imdilate(MidCircle,SE);        % figure; imshow(MidCircle,[])        %% Step 2: Find frames with maximal dye intensity        EndFrame        = File.VariablesInformation.FramesOfInterest.DyePatterns(2);        StartFrame      = File.VariablesInformation.FramesOfInterest.DyePatterns(1);            FrameInterval   = File.FrameRate; % 1 second        FramesToAnalyze = StartFrame:FrameInterval:EndFrame;        NumOfFrames     = length(FramesToAnalyze);        DyeIntensity  = zeros(1,NumOfFrames,'single');        ind=0;        for Frame = FramesToAnalyze            ind = ind+1;            % Read frame, depending on the video format            if VideoFormat==2                       % A single multiple-tiff file                Mov                = imread(FileFullName, Frame);                 elseif VideoFormat==1                   % A sequence of tiff files                FileFullName       = [DirName,'\',FileNames{Frame}];                 Mov                = imread(FileFullName);                                      elseif VideoFormat==3                   % A single avi movie file                Mov                = read(MovieObj, Frame);                     Mov                = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!            elseif VideoFormat==4                   % A sequence of avi movie files                CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);                            if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                    FileFullName         = [DirName,'\',FileNames{CurrentMovieObjFile}];                     PreviousMovieObjFile = CurrentMovieObjFile;                    MovieObj             = VideoReader(FileFullName);                end                CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);                Mov                      = read(MovieObj, CurrentFrameNumberInFile);                     Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                       end            Mov              = single(imsubtract(Mov,background));            vec              = Mov(MidCircle(:));            DyeIntensity(ind)= prctile(vec,90);                end        InterpolationFactor = 0.01;        Smoothed_DyeIntensity = csaps(1:length(DyeIntensity),double(DyeIntensity),InterpolationFactor,1:length(DyeIntensity));        [MaxDyeIntensity, MaxInd] = max(Smoothed_DyeIntensity);        LastAllDyeFrame_index  = find(Smoothed_DyeIntensity(MaxInd:end)>0.98*MaxDyeIntensity,1,'last')+MaxInd-1;        FirstAllDyeFrame_index = find(Smoothed_DyeIntensity(1:MaxInd)>0.98*MaxDyeIntensity,1,'first');        LastAllDyeFrame  = FramesToAnalyze(LastAllDyeFrame_index);        FirstAllDyeFrame = FramesToAnalyze(FirstAllDyeFrame_index);    %     figure; plot(DyeIntensity,'b-'); hold on; plot(Smoothed_DyeIntensity,'r-');        File.VariablesInformation.FramesOfInterest.OnlyDye(2) = LastAllDyeFrame;        File.VariablesInformation.FramesOfInterest.OnlyDye(1) = FirstAllDyeFrame;        File.DyePattern_MidPixelValues = Smoothed_DyeIntensity;         File.DyePattern_MidPixelFrames = FramesToAnalyze;         EndFrame      = LastAllDyeFrame;        StartFrame    = FirstAllDyeFrame;        %% Step 3: Define maximal intensity of dye and maximal intensity of posts. Use them to generate Masks and vignetting reference.           %              Maximal post intensity is used as Mask threhold           %              Maximal dye intensity is used as a reference for vignetting calculation         %   NOTE !!! I assume that minimal dye pattern values (at frame edges) are larger than maximal post levels (in the middle)            FrameInterval   = File.FrameRate; % 2 seconds        FramesToAnalyze = StartFrame:FrameInterval:EndFrame;        NumOfFrames     = length(FramesToAnalyze);        cdata_mat   = uint16(zeros(MATSIZE(1),MATSIZE(2),NumOfFrames));        ind         = 0;        for Frame = FramesToAnalyze            ind = ind+1;            % Read frame, depending on the video format            if VideoFormat==2                       % A single multiple-tiff file                Mov                = imread(FileFullName, Frame);                 elseif VideoFormat==1                   % A sequence of tiff files                FileFullName       = [DirName,'\',FileNames{Frame}];                 Mov                = imread(FileFullName);                                      elseif VideoFormat==3                   % A single avi movie file                Mov                = read(MovieObj, Frame);                     Mov                = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!            elseif VideoFormat==4                   % A sequence of avi movie files                CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);                            if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                    FileFullName         = [DirName,'\',FileNames{CurrentMovieObjFile}];                     PreviousMovieObjFile = CurrentMovieObjFile;                    MovieObj             = VideoReader(FileFullName);                end                CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);                Mov                      = read(MovieObj, CurrentFrameNumberInFile);                     Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                       end            % store frame data            cdata_mat(:,:,ind) = Mov;                  if mod(Frame * progbars,(EndFrame-StartFrame+1)) < progbars*FrameInterval     % Progress bar- 10x ':'                fprintf(':');             end            end        cdata_mat          = double(cdata_mat);                  %     cdatamedian        = median(cdata_mat,3);    %     DyeMinusBackground = imsubtract(uint16(round(cdatamedian)),background);          cdata_prctile90    = prctile(cdata_mat,90,3);        DyeMinusBackground = imsubtract(uint16(round(cdata_prctile90)),background);          % Within the MidCircle defined in step 1: there will be a bistable histogram of maximal dye levels and maximal posts level.         MAT            = single(DyeMinusBackground);         MAT(~MidCircle)= NaN;        vec            = MAT(~isnan(MAT(:)));        [N, X] = hist(vec,100); N = N/sum(N); % this gives a two peak histogram: for dye value and post values in the middle of the field of view.          [pks,locs]=findpeaks(N,'MinPeakHeight',0.05);    %     figure; plot(X,N); hold on; plot( X(locs),pks,'r*')        if length(locs)~=2            disp('Problems with Mask generation. need to be debugged...')            Mask = true(MATSIZE);            keyboard;            % figure; plot(X,N); hold on; plot( X(locs),pks,'r*')            % locs = locs(1:2); pks = pks(1:2);        else            MedianPostValue = X(locs(1));            MedianDyeValue  = X(locs(2));    %         MaxDyeValue     = max(vec);            ThresholdForMask = 1.5*MedianPostValue;            % Mask: true within the worms crawling area, false elsewhere             Mask =  true(MATSIZE);            Mask(DyeMinusBackground<ThresholdForMask)=false;            Mask = ~(imclose(~Mask,strel('disk',1,0)));            VignettingPattern        = single(DyeMinusBackground);            VignettingPattern(~Mask) = NaN;            VignettingPattern        = VignettingPattern / prctile(VignettingPattern(:),99);                end        if plot_background            figure; plot(DyeIntensity,'b-'); hold on; plot(Smoothed_DyeIntensity,'r-');            figure; plot(X,N); hold on; plot( X(locs),pks,'r*')            figure; imshow(DyeMinusBackground,[]);            figure; imshow(Mask,[]);            figure; imshow(VignettingPattern,[]);            figure; imagesc(VignettingPattern); set(gca,'clim',[0 1]); axis equal; colorbar                end               % save background mat file        save(File.BackgroundFile, 'DyeMinusBackground','Mask','VignettingPattern','-append');            endend% imshow(background);% pause;return%% Initiate trackers and status monitoringfunction InitiateFragmentTracker (File, All_Files, MovieNum, TrackerFunctionName, num_processors, max_processors)  disp(['Initiating Trackers in seperate Matlab sessions. Tracker name: ',TrackerFunctionName,char(10)]);StatusFile = File.StatusFile;% Free parameters for Spawning the tracker functionsSpawnSetting.Save           = 1;  % save master workspace; slaves will loadSpawnSetting.Exit           = 0;  % don't exit from master tracker NumFragments  = File.Fragments;    claimed       = (File.ClaimedFragments).*(File.CompletedFragments);   % Fragments that were not completed will not be considered as claimed. This is important if the movie is re-analyzed.disp(['Seeding fragments for Movie: ',File.MovieName,'. Number of fragements = ',num2str(NumFragments)]);while ~all(claimed)  % if any unclaimed fragments left...    completed      = File.CompletedFragments;    fragments_left = find(~claimed);    next_fragment  = min(fragments_left);    processors_used = sum(claimed & ~completed);           if processors_used < min(num_processors, max_processors)        claimed(next_fragment) = 1;        File.ClaimedFragments  = claimed;        if length(All_Files)>1            All_Files(MovieNum)= File;        else            All_Files          = File;        end                    save(StatusFile,'File','All_Files');        % SPAWN new FragmentTracker        Fragment = next_fragment;        disp([datestr(now), '  spawning for fragment ',int2str(Fragment),'/',int2str(NumFragments)]);        disp(['  Fragments completed: ',sprintf('%1d ',completed)]);        disp(['  Fragments analyzing: ',sprintf('%1d ',claimed & ~completed)]);        fprintf('\n\n');        %% This paragraph opens a new Matlab window to track the worms using the function given by: 'TrackerFunctionName'        SpawnSetting.Startup        = ['Fragment=',int2str(Fragment), TrackerFunctionName];                                                      spawn2(SpawnSetting, File.TempFolder)         pause(4);    else        disp(['waiting for processors to finish fragements before seeding fragment number ',num2str(next_fragment)]);        pause(30);    end      success = 0;    while ~ success        try            load(StatusFile,'File');            success = 1;        catch            disp('problem loading ''File''. retrying in 2 seconds');            pause(2);        end    endend   disp('all fragments seeded. waiting for slaves to finish computation...')returnfunction spawn2(SpawnSetting, TempFolder)if ~(exist('SpawnSetting') && isfield(SpawnSetting,'Save') && isfield(SpawnSetting,'Startup'))    SpawnSetting.Save    = 1;    SpawnSetting.Startup = 'load';endif ~isfield(SpawnSetting,'Exit')    SpawnSetting.Exit = 0;endif ~isfield(SpawnSetting,'MatlabFlags')    SpawnSetting.MatlabFlags = [];endif SpawnSetting.Save    cd(TempFolder)    %save;    save('matlab.mat');    if ~any(strfind(SpawnSetting.Startup,'load'))        SpawnSetting.Startup = ['load;',SpawnSetting.Startup];    endendMatlabfile = [fullfile(matlabroot,'bin','win64','MATLAB.exe')];    % Matlab 64 bitif  ~exist(Matlabfile,'file') % The current Matlab version is a 32 bit version    disp('Running Matlab 32 bit');    Matlabfile = [fullfile(matlabroot,'bin','win32','MATLAB.exe')];   end    com = sprintf('!"%s" -nosplash %s -r %s &',Matlabfile,SpawnSetting.MatlabFlags,SpawnSetting.Startup);    eval(com);if SpawnSetting.Exit    exitendreturnfunction StatusMonitoring (TempFolder, check_status_interval, File, MovieNum, TotalMovieNum)load TrackingVariables_SL  FigHandleNumFragments            = File.Fragments;   TrackName               = File.TrackFile;[pathname,filename]     = fileparts(TrackName);partsfolder             = '\trackfile parts\';    % Check that all fragments are completedwhile length(dir([pathname,partsfolder,filename,'*'])) < NumFragments    pause(check_status_interval)    load (File.StatusFile);    % parse fragment status files    StatusD = dir(fullfile(TempFolder,'_F*')); StatusLine = [StatusD.name];    StatusM = zeros(1,NumFragments);    a = strfind(StatusLine,'.'); b = [strfind(StatusLine,'_'),length(StatusLine)+1]; b = circshift(b,[0 -1]); aF = strfind(StatusLine,'F');    for c = 1:length(a); StatusM(str2num(StatusLine(aF(c)+1:a(c)-1))) = str2num(StatusLine(a(c)+1:b(c)-1)); end % get percent progress from each fragment tracker        StatusM(File.CompletedFragments==1) = 100;        % show status window    figure(FigHandle);    bar(StatusM); set(gca,'YLim',[0 100]);     ylabel('Completed (%)'); xlabel('Fragment Number');     title({datestr(now),['Movie number [',num2str(MovieNum),'/',num2str(TotalMovieNum),'],    ', File.TrackFile]},'Interpreter','none');enddisp([datestr(now), '   found all files. start stitching in 10 seconds.']);pause(10);return%% Dye trackerfunction TrackDye_ImagingSetup_inline(File)% This function assumes that the first 7 minutes there is a gradient dye pattern which is the switched to full dye over all the arena chip % Correct the switching time below according to your protocol.SwitchingTimeFromGradientToAllDye = 7*60; t0 = clock; QuitMatlabWhenFinished = false;%% load 'File' if it's not provided as an input variablewhile ~exist('File','var')    try        load('inprogress.mat','File');            catch        disp('error loading ''File'', retrying in 2 seconds')        pause(2);    end           enddisp([datestr(now),'   Dye analysis of the movie: ''',File.MovieName,'''']);MoviePath       = File.MoviePath;MovieFileNames  = File.MovieFileNames;MATSIZE         = File.FrameSize;EndFrame        = File.VariablesInformation.FramesOfInterest.DyePatterns(2);StartFrame      = File.VariablesInformation.FramesOfInterest.DyePatterns(1);    FrameInterval   = File.FrameRate/10; % every 1/3 secondFramesToAnalyze = StartFrame:FrameInterval:EndFrame;NumOfFrames     = length(FramesToAnalyze);       if     strcmpi(File.VideoFormat,'tiff')    VideoFormat   = 1;                                  % read new file every loop iteration elseif strcmpi(File.VideoFormat,'multi-tiff')    VideoFormat   = 2;    FileFullName  = [MoviePath,'\',MovieFileNames{1}];  % one fileelseif strcmpi(File.VideoFormat,'avi')    VideoFormat   = 3;    FileFullName  = [MoviePath,'\',MovieFileNames{1}];  % one file    MovieObj      = VideoReader(FileFullName);          % one objectelseif strcmpi(File.VideoFormat,'multi-avi')    VideoFormat   = 4;    PreviousMovieObjFile = 0;                           % read new file object if and when it is needed end          load(File.BackgroundFile, 'background','VignettingPattern','Mask');% Note: % X of mask is the gradient axis. When using 'imshow(Mask)' it appears as the Y axis of the picture;  % Y of mask is the flow axis.     When using 'imshow(Mask)' it appears as the X axis of the picture;  % From this point on, X and Y refers to the coordinates as they appear in imshow(Mask) function.    % i.e.  X referes to the FLOW axis,   Y refers to the GRADIENT axis% Flow Indices% mean(Mask,1)= Average over X = result values relate to Y indices in Mask = X indices in 'imshow(Mask)'    Xmin =  find(mean(Mask,1)>0.9,1,'first');Xmax =  find(mean(Mask,1)>0.9,1,'last');% Find Ymin, Ymax. This is the gradient axis limits.   % Note!! it is the 'row' dimension in Mask but in imshow(Mask) it is the Y axis.    % % MaxPossibleIndexForYmin = find(mean(Mask,2)>0.6,1,'first');% % find(mean(Mask(1:MaxPossibleIndexForYmin,:),2)<0.5,1,'last')+1Ymin =  find(mean(Mask,2)>=0.55,1,'first');Ymax =  find(mean(Mask,2)>=0.55,1,'last');figure; Vec=mean(Mask,2); plot(1:length(Vec),Vec); hold on; plot([Ymin Ymax],Vec([Ymin Ymax]),'r*')figure; Vec=mean(Mask,1); plot(1:length(Vec),Vec); hold on; plot([Xmin Xmax],Vec([Xmin Xmax]),'r*')figure; imshow(Mask,[]); hold on; rectangle('Position',[Xmin,Ymin,Xmax-Xmin,Ymax-Ymin],'edgecolor','r','linewidth',2)%% binning indices info - 2 FREE PARAMETERS, optimization depends on microfluidic device dimensions and imaging parametersbinning.Xmin          = Xmin;binning.Xmax          = Xmax;binning.Ymin          = Ymin;binning.Ymax          = Ymax;binning.NumOfBins_X   = 5;binning.NumOfBins_Y   = 50;Xedges                = round(linspace(Xmin,Xmax,binning.NumOfBins_X+1));  % Here X axis is the gradient axis -- not like the screening setupYedges                = round(linspace(Ymin,Ymax,binning.NumOfBins_Y+1));binning.NumOfPixels_X = min(diff(Xedges))+1;binning.NumOfPixels_Y = min(diff(Yedges))+1;binning.Xedges        = Xedges;binning.Yedges        = Yedges;binning.FramesToAnalyze = FramesToAnalyze;LinearCoordinates_InFrame   = zeros(binning.NumOfBins_X,binning.NumOfBins_Y, binning.NumOfPixels_X*binning.NumOfPixels_Y,'single')*NaN;for x_ind = 1:binning.NumOfBins_X         CurrentXcoordinates = Xedges(x_ind):Xedges(x_ind+1);    for y_ind = 1:binning.NumOfBins_Y        CurrentYcoordinates = Yedges(y_ind):Yedges(y_ind+1);        MAT = false(MATSIZE);        MAT(CurrentYcoordinates,CurrentXcoordinates)=true; % Coordinates of 'imshow(Mask)' are opposite than 'Mask'         Indices = find(MAT(:));        Indices = Indices(round(linspace(1,length(Indices), binning.NumOfPixels_X*binning.NumOfPixels_Y)));        LinearCoordinates_InFrame(x_ind,y_ind,:) = Indices;    endend%% (1) Generate 'PatternMatrix'         >> Load and calculate DyePattern for each frame%%     Generate 'FilteredPatternMatrix' >> upply a 1 second window averaging filter on 'PatternMatrix'   disp([datestr(now), '  Analyzing dye patterns in each frame', char(10)]);frame_index     = 0;PatternMatrix   = zeros(length(FramesToAnalyze),binning.NumOfBins_X,binning.NumOfBins_Y,'single');tic;for Frame = FramesToAnalyze         frame_index = frame_index+ 1;           %% Current frame analysis    switch VideoFormat        case 2                             % A single multiple-tiff file            Mov           = imread(FileFullName, Frame);             case 1                             % A sequence of tiff files            FileFullName  = [MoviePath,'\',MovieFileNames{Frame}];             Mov           = imread(FileFullName);                                  case 3                             % A single avi movie file            Mov           = read(MovieObj, Frame);                 Mov           = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!        case 4                             % A sequence of avi movie files            CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);            if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                FileFullName        = [MoviePath,'\',MovieFileNames{CurrentMovieObjFile}];                 PreviousMovieObjFile = CurrentMovieObjFile;                MovieObj             = VideoReader(FileFullName);            end            CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);            Mov                      = read(MovieObj, CurrentFrameNumberInFile);                 Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                    end     Mov = single(imsubtract(Mov,background))./VignettingPattern;        % calculate dye pattern in each bin    FrameBins         = Mov(LinearCoordinates_InFrame);    % FrameBins is a 3-D matrix of size [ NumOfBins_X, NumOfBins_Y, (NumOfPixels_X * NumOfPixels_Y) ] ;    MedianOfFrameBins = nanmedian(FrameBins,3);            % MedianOfFrameBins and FilteredMedians are 2-D matrices of size [ NumOfBins_X, NumOfBins_Y ] ;        PatternMatrix(frame_index,:,:) = MedianOfFrameBins;     % NOT FILTERED !!!!!           endtoc% figure;% for frame = 1:10:size(PatternMatrix,1)%     imagesc(squeeze(PatternMatrix(frame,:,:))); set(gca,'clim',[0 900]); colorbar;%     title(frame)%     pause(0.1);% end%%%%%% Filter PatternMatrixwindowSize            = File.FrameRate;  % filter on time scale of 1 second;b                     = (1/windowSize)*ones(1,windowSize);a                     = 1;FilteredPatternMatrix = filter(b,a,PatternMatrix);%% (2) Generate 'MaxValue_reference' >> Reference pattern when dye is flowing in all inlets (last minute in the session) %%     Generate 'NormPatternMatrix'  >> 'FilteredPatternMatrix'/'MaxValue_reference'  % MaxValue_referencedisp([datestr(now), '  Generate ''MaxValue_reference'' and ''NormPatternMatrix''']);MaxValue_reference            = squeeze(prctile(FilteredPatternMatrix,99,1));% figure; imagesc(MaxValue_reference); colorbarNormPatternMatrix = FilteredPatternMatrix./shiftdim(repmat(MaxValue_reference,[1 1 NumOfFrames]),2);ArenasDyePatterns = squeeze(nanmedian(NormPatternMatrix,2));%% Calculate Flow Delays %   >> the time that it takes for the odor to reach the device.PatternsOnset.Frames =  FramesToAnalyze;PatternsOnset.Time   =  (PatternsOnset.Frames-PatternsOnset.Frames(1))/File.FrameRate;Vec                  = ArenasDyePatterns(:,end);RealZero             = median(Vec(PatternsOnset.Time<20));RealOne              = 1;Vec                  = (Vec-RealZero)/(RealOne-RealZero); PatternsOnset.Values =  Vec;SecondsUntil_90_percent                     = PatternsOnset.Time(find(PatternsOnset.Values>0.9,1,'first'));SecondsUntil_75_percent                     = PatternsOnset.Time(find(PatternsOnset.Values>0.75,1,'first'));SecondsUntil_50_percent                     = PatternsOnset.Time(find(PatternsOnset.Values>0.5,1,'first'));SecondsUntil_25_percent                     = PatternsOnset.Time(find(PatternsOnset.Values>0.25,1,'first'));SecondsUntil_10_percent                     = PatternsOnset.Time(find(PatternsOnset.Values>0.1,1,'first'));SecondsUntilDyePatternInitiation_UpperLimit = PatternsOnset.Time(find(PatternsOnset.Values>0.05,1,'first'));% Smooth pattern onset and find when the smoothed data start increasing significantly InterpolationFactor   = 1e-6;ThresholdForDyeChange = 1e-5;X                     = 1:length(PatternsOnset.Values);PatternsOnset.SmoothedValues     = csaps(X,double(PatternsOnset.Values),InterpolationFactor,X);SecondsUntilDyePatternInitiation = PatternsOnset.Time(find(diff(PatternsOnset.SmoothedValues(1:find(PatternsOnset.Values>0.5,1,'first')))< ThresholdForDyeChange ,1,'last'));RiseTime_InitiationTo90Percent   = SecondsUntil_90_percent- SecondsUntilDyePatternInitiation;RiseTime_InitiationTo75Percent   = SecondsUntil_75_percent- SecondsUntilDyePatternInitiation;RiseTime_InitiationTo50Percent   = SecondsUntil_50_percent- SecondsUntilDyePatternInitiation;RiseTime_InitiationTo25Percent   = SecondsUntil_25_percent- SecondsUntilDyePatternInitiation;RiseTime_InitiationTo10Percent   = SecondsUntil_10_percent- SecondsUntilDyePatternInitiation;RiseTime_10To90Percent           = SecondsUntil_90_percent- SecondsUntil_10_percent;% Gradient Pattern analysisRelevantGradientIndices(2) = (SwitchingTimeFromGradientToAllDye+SecondsUntilDyePatternInitiation-10) * File.FrameRate / FrameInterval;RelevantGradientIndices(1) = RelevantGradientIndices(2)-30*File.FrameRate/FrameInterval;RelevantGradientIndices    = round(RelevantGradientIndices);GradientPattern.Indices       = RelevantGradientIndices;GradientPattern.FrameInterval = PatternsOnset.Frames(RelevantGradientIndices);GradientPattern.TimeInterval  = PatternsOnset.Time(RelevantGradientIndices);GradientPattern.GradientProfile = nanmean(ArenasDyePatterns(RelevantGradientIndices(1):RelevantGradientIndices(2),:));%% assign to structuresDyeStats.SecondsUntil_50_percent                     = SecondsUntil_50_percent;DyeStats.SecondsUntilDyePatternInitiation_UpperLimit = SecondsUntilDyePatternInitiation_UpperLimit;DyeStats.SecondsUntilDyePatternInitiation            = SecondsUntilDyePatternInitiation;DyeStats.RiseTime_InitiationTo90Percent              = RiseTime_InitiationTo90Percent;DyeStats.RiseTime_InitiationTo75Percent              = RiseTime_InitiationTo75Percent;DyeStats.RiseTime_InitiationTo50Percent              = RiseTime_InitiationTo50Percent;DyeStats.RiseTime_InitiationTo25Percent              = RiseTime_InitiationTo25Percent;DyeStats.RiseTime_InitiationTo10Percent              = RiseTime_InitiationTo10Percent;DyeStats.RiseTime_10To90Percent                      = RiseTime_10To90Percent;DyeStats.binning                                     = binning;FlowDelay.DeviceType                                = 'SLI01';FlowDelay.DelayBetweenValveAndArenas                = SecondsUntilDyePatternInitiation;                        % seconds  FlowDelay.ArenaSize                                 = 4640;                % micrometers. Distance on the Flow axis from barriers (in) to barriers (out)FlowDelay.RiseTime_InitiationTo90Percent            = RiseTime_InitiationTo90Percent;  FlowDelay.RiseTime_InitiationTo75Percent            = RiseTime_InitiationTo75Percent;  FlowDelay.RiseTime_InitiationTo50Percent            = RiseTime_InitiationTo50Percent;  FlowDelay.RiseTime_InitiationTo25Percent            = RiseTime_InitiationTo25Percent;  FlowDelay.RiseTime_InitiationTo10Percent            = RiseTime_InitiationTo10Percent;  FlowDelay.RiseTime_10To90Percent                    = RiseTime_10To90Percent;  FlowDelay.PatternsOnset                             = PatternsOnset;FlowDelay.GradientPattern                           = GradientPattern;%% Plots% Plot: Dye onset dynamicsFILEPATH = File.MoviePath;FigureString = 'Dye onset dynamics- raw';f=figure('name',FigureString);plot(PatternsOnset.Time, PatternsOnset.SmoothedValues,'color','k'); hold on;ylimits = get(gca,'ylim');line([SecondsUntil_50_percent       SecondsUntil_50_percent],       ylimits,'color','k','linestyle',':');line([SecondsUntilDyePatternInitiation SecondsUntilDyePatternInitiation], ylimits,'color','k','linestyle','--');xlabel('seconds'); ylabel('dye level');title(['Dye Inititation Time = ',num2str(min(SecondsUntilDyePatternInitiation))]);FigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);% Plot: Dye patternFigureString = 'Dye pattern';f=figure('name',FigureString);plot(GradientPattern.GradientProfile,'color','k'); hold on;xlabel('position'); ylabel('dye level');FigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);%% SAVE and exitdisp([datestr(now), '  Saving ''ArenasDyePatterns''']);DyeFileName = [File.TrackFile(1:end-4),'_DyePatterns.mat'];File.DyeFileName = DyeFileName;save(DyeFileName, 'File','ArenasDyePatterns','DyeStats','FlowDelay','GradientPattern',...                  'PatternMatrix','NormPatternMatrix','MaxValue_reference','FilteredPatternMatrix');   disp([datestr(now), '  Dye file saved']);% % Uncomment this for dye-movie:% figure;% for frame = 1:20:GradientPattern.Indices % size(PatternMatrix,1)% %     imagesc(squeeze(PatternMatrix(frame,:,:))); set(gca,'clim',[0 900]); colorbar;% %     imagesc(squeeze(FilteredPatternMatrix(frame,:,:))); set(gca,'clim',[0 900]); colorbar;%     imagesc(squeeze(NormPatternMatrix(frame,:,:))); set(gca,'clim',[0 1]); colorbar;     % Arena image%     plot(ArenasDyePatterns(frame,:)); ylim([0 1])                                        % profile plot         %     title(frame/(File.FrameRate/FrameInterval))% %     title(frame)%     pause(0.1);% endreturn
function FragmentTracker_SL_ImagingSetup_v09(Fragment,File)%  Sagi Levy, September 2019%% load 'File' if it's not provided as an input variablewhile ~exist('File','var')    try        load('inprogress.mat','File');            catch        disp('error loading ''File'', retrying in 2 seconds')        pause(2);    end           enddisp([datestr(now),'   Analyzing fragment number ',num2str(Fragment),' of the movie: ''',File.MovieName,'''']);%% InitializationSingleWormMode             = false; subplot_mode               = false;LimitCommandWindowFeedback = false;    MarkerSizeForDisplay       = 3;     % This is a good value when you want to look at a large field of view with all worms     % MarkerSizeForDisplay       = 5;    % This is a good value when you want to zoom on single worms to evaluate the head vs. tail segmentation      SaveOnlyOneFile_NoArenaSpecificFiles = true;    % MoviePath      = File.MoviePath;MovieFileNames = File.MovieFileNames;PixelSize      = File.PixelSize;              % PixelSize == # pixels per mm (1D length) FragmentFrames = File.FragmentFrames;RelevantFrames = FragmentFrames(Fragment,1):FragmentFrames(Fragment,2);t0 = clock;load (File.TrackingVariablesFile,   'Background_params','DetectionMode','AutoThreshold_params','FLUORESCENCE_STREL1','FLUORESCENCE_STREL2',...                                    'MaxNumOfWorms','MinWorm_size','MaxWorm_size','PlotFrameRate','DetectionErrorAllowed','FigHandle','TempFolder',...                                    'MAX_PerFrame_Calculation_Time','MinTrackLength','MaxSpeedForTrackLinking_mm_sec', 'MaxRelativeSizeChange', ...                                    'QuitMatlabWhenFinished', 'MidlineCalculationParams','SegmentationSettings');                                                            % For head vs. tail detection. This will be calculated ONLY in advanced 'DetectionMode' (AddProps>=2)   PlotHeadVsTail = false;if exist('MidlineCalculationParams','var')    if isfield(MidlineCalculationParams,'DistanceAlongMidline_ForHeadvsTail')        MidlineCalculationParams.UseMidlineGrayScale_ForHeadvsTail = true;        PlotHeadVsTail = true;    else        MidlineCalculationParams.UseMidlineGrayScale_ForHeadvsTail = false;            endendfigure (FigHandle);MaxDistance = MaxSpeedForTrackLinking_mm_sec * File.PixelSize / File.FrameRate;  % File.PixelSize is actually How many pixels per mm. MaxDistance has units of pixels/frame MidlineCalculationParams.WormRealWidthInPixels = MidlineCalculationParams.WormRealWidth /1000* File.PixelSize;disp(['Detection mode: ',DetectionMode, char(10)]);if strcmpi(DetectionMode, 'AddAllProperties')    AddProps = 3;elseif strcmpi(DetectionMode, 'AddAdvancedMorphologyProperties')    AddProps = 2;elseif strcmpi(DetectionMode, 'AddBasicMorphologyProperties')    AddProps = true; else    AddProps = false;endif isfield(AutoThreshold_params,'ForceOneRealObject')    if AutoThreshold_params.ForceOneRealObject        SingleWormMode = true;    endendSettings = single([RelevantFrames', NaN*ones(length(RelevantFrames),1), NaN*ones(length(RelevantFrames),1), NaN*ones(length(RelevantFrames),1) ]);                   if ~exist('FLUORESCENCE_STREL1','var')        FLUORESCENCE_STREL1  = strel('disk',1,0);endif subplot_mode    SCSZ      = get(0,'screensize');       Height    = (SCSZ(4)-50) / 4 * 0.9;    LL_Height = 50 + (SCSZ(4)-50) / size(FragmentFrames,1) * (Fragment-1);     Width     = (SCSZ(3)-20) / 4;        PositionMovieFigure         = round([20            LL_Height  Width   Height]);      PositionAutoThresholdFigure = round([30+SCSZ(3)/4  LL_Height  Width   Height]);          set(FigHandle,'position',PositionMovieFigure);    if ~isempty(threshold_figure_handle)        set(threshold_figure_handle,'position',PositionAutoThresholdFigure);    endend        if     strcmpi(File.VideoFormat,'tiff')    VideoFormat   = 1;                                  % read new file every loop iteration elseif strcmpi(File.VideoFormat,'multi-tiff')    VideoFormat   = 2;    FileFullName  = [MoviePath,'\',MovieFileNames{1}];  % one fileelseif strcmpi(File.VideoFormat,'avi')    VideoFormat   = 3;    FileFullName  = [MoviePath,'\',MovieFileNames{1}];  % one file    MovieObj      = VideoReader(FileFullName);          % one objectelseif strcmpi(File.VideoFormat,'multi-avi')    VideoFormat   = 4;    PreviousMovieObjFile = 0;                           % read new file object if and when it is needed end           %% Calculating video Background and Maskif isfield(Background_params,'UseOnlyFramesInFragement')    UseOnlyFramesInFragement = Background_params.UseOnlyFramesInFragement;else    UseOnlyFramesInFragement = false;  end if UseOnlyFramesInFragement      %%%%  background is calculated independently for each movie fragment (fluctuating background)       Background_params.StartFrame =  FragmentFrames(Fragment,1);    Background_params.EndFrame   =  FragmentFrames(Fragment,2);    if Fragment == File.Fragments     % Correct first frame for last fragement. Make sure that the background is calculated using the same number of frames...           Background_params.StartFrame = Background_params.EndFrame - FragmentFrames(1,2);    end    background = getbackground_inline(File, Background_params);        disp([datestr(now),' Background Processed for fragment ',num2str(Fragment),char(10)]);     else                             %%%%  background was already calculated based on all movie frames        try        load(File.BackgroundFile, 'background');    catch        disp('background file was not found. Re-calculating the background using all movie frames.')        background = getbackground_inline(File, Background_params);            disp([datestr(now),' Background Processed']);     end      if isfield(Background_params,'CalcMaskAndVignetting_fromDye')        if Background_params.CalcMaskAndVignetting_fromDye            load(File.BackgroundFile, 'Mask', 'VignettingPattern');            dilatedMask = ~imdilate(~Mask,strel('disk',1,0));            VignettingPattern(~dilatedMask)=NaN;    %             figure; imagesc(VignettingPattern); set(gca,'clim',[0 1]); axis equal; colorbar        end    endendif ~exist('VignettingPattern','var')    VignettingPattern = ones(size(background),'single');end%% Find worm objects in each frameTracks          = [];frame_index     = 0;TotalNumOfWorms = single(zeros(1,length(RelevantFrames)))*NaN;tic; c1=clock;for Frame = RelevantFrames         frame_index = frame_index+ 1;    %% Current frame analysis    % Get Frame and normalize it           switch VideoFormat        case 2                             % A single multiple-tiff file            Mov           = imread(FileFullName, Frame);             case 1                             % A sequence of tiff files            FileFullName  = [MoviePath,'\',MovieFileNames{Frame}];             Mov           = imread(FileFullName);                                  case 3                             % A single avi movie file            Mov           = read(MovieObj, Frame);                 Mov           = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!        case 4                             % A sequence of avi movie files            CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);            if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                FileFullName        = [MoviePath,'\',MovieFileNames{CurrentMovieObjFile}];                 PreviousMovieObjFile = CurrentMovieObjFile;                MovieObj             = VideoReader(FileFullName);            end            CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);            Mov                      = read(MovieObj, CurrentFrameNumberInFile);                 Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                    end                   Mov = imsubtract(Mov,background);    if exist('Mask','var')        Mov(~Mask)=0;    end%     figure; imshow(Mov,[])%     Mov = uint16(single(Mov)./VignettingPattern);        [STATS, AnimalPix, threshold, NUM] = ...        AutoThreshold_AndFindWormProps_Imaging_v01(Mov, AutoThreshold_params, PixelSize, LimitCommandWindowFeedback, FLUORESCENCE_STREL1, FLUORESCENCE_STREL2, MaxNumOfWorms, AddProps, MidlineCalculationParams, VignettingPattern );       TotalNumOfWorms(frame_index) = single(NUM);        Settings(frame_index,:)      = single([Frame, threshold, AnimalPix, NUM]);                   %% Basic worms tracking        if NUM         % At least one worm object was found                               % Update active tracks with new coordinates        if ~isempty(Tracks)            [Tracks, WormCoordinates] = UpdateActiveTracks_Fluor (Tracks , STATS, Frame, AddProps, MaxDistance, MaxRelativeSizeChange, MinTrackLength, SingleWormMode, MidlineCalculationParams);               % WormCoordinates will have NaNs for worms assigned to existing Tracks.         else            WormCoordinates           = STATS.Coordinates;        end        % Start new tracks for worm objects that are not assigned to existing tracks           Tracks = DefineNewTracks_Fluor (Tracks , WormCoordinates, STATS, Frame, AddProps, MidlineCalculationParams);                end                  %% Display and memory    break_now = ProgressDisplay_and_Memory (Frame, Mov, FileFullName, Tracks, Settings(frame_index,:), FragmentFrames, Fragment, PlotFrameRate, FigHandle, TempFolder, MAX_PerFrame_Calculation_Time, PlotHeadVsTail, MarkerSizeForDisplay, frame_index) ;     if break_now  % Script is too slow        break    end        endetime(clock,c1)/60% Get rid of too short tracks (in our case we exclude tracks with a single frame)DeleteTracks = [];for i = 1:length(Tracks)    if length(Tracks(i).Frames) < MinTrackLength        DeleteTracks = [DeleteTracks, i];    endendTracks(DeleteTracks) = [];SegmentationSettings    = File.VariablesInformation.SegmentationSettings;PlotArenasCalculation   = SegmentationSettings.PlotInfo.TracksAssociationToArenas;[Tracks, TrackArena]    = AssociateTracksToArenas (Tracks, File, PlotArenasCalculation);%% SAVESaveAndUpdateStatus (File, Fragment, Settings , Tracks, background,  AddProps, SaveOnlyOneFile_NoArenaSpecificFiles)  % settings contain the thresholds values that were usedt1=clock; disp(['Total cpu time for this fragment = ',num2str(etime(t1,t0)/60),char(10)])if QuitMatlabWhenFinished    quitendreturn%% Inline functionsfunction [background, File] = getbackground_inline(File, Background_params)% This function is modified from the function getbackground_Fluor_v02% This function:%   Calculate the background from the median/mean/or percentile pixel levels depending on the user preference.    %   Uses gray scale pictures rather than a single channel.%-----------------------------------------------------------------------DirName     = File.MoviePath;FileNames   = File.MovieFileNames;FrameNum    = File.NumberOfFrames;  % This is the total number of frames in the movie, NOT the number of frames that are analyzed for background calculationMATSIZE     = File.FrameSize;if isfield(Background_params,'method')          % mean or median over the frames?     method = Background_params.method;else    method = 'median';endtry         load(File.BackgroundFile, 'background');    disp(['background file was already calculated for ',File.MovieName,'. Skipping background calculation.', char(10)])    returncatch    disp(['Calculating background for ',File.MovieName,' using ''',method,''' approach', char(10)])    end        if isfield(Background_params,'FrameInterval')   % Usually 50 frames    FrameInterval = Background_params.FrameInterval;else    FrameInterval = 50;endif isfield(Background_params,'StartFrame')      % First frame     StartFrame = Background_params.StartFrame;else    StartFrame = 1;endif isfield(Background_params,'EndFrame')        % Last frame     EndFrame = Background_params.EndFrame;else    EndFrame = FrameNum;endif isfield(Background_params,'plot')            % plot background     plot_background = Background_params.plot;else    plot_background = false;endif isfield(Background_params,'UseGaussianFilter')   % Usually 50 frames    UseGaussianFilter = Background_params.UseGaussianFilter;    GaussianFilter    = fspecial('gaussian', Background_params.GaussianFilter.hsize, Background_params.GaussianFilter.sigma); else    UseGaussianFilter = false;endif UseGaussianFilter    disp('A Gaussian filter is applied to the movie frames and background');end% Assign Movie Format Codeif     strcmpi(File.VideoFormat,'tiff')    VideoFormat   = 1;elseif strcmpi(File.VideoFormat,'multi-tiff')    VideoFormat   = 2;    FileFullName  = [DirName,'\',FileNames{1}]; elseif strcmpi(File.VideoFormat,'avi')    VideoFormat   = 3;    FileFullName  = [DirName,'\',FileNames{1}];     MovieObj      = VideoReader(FileFullName);elseif strcmpi(File.VideoFormat,'multi-avi')    VideoFormat   = 4;    PreviousMovieObjFile = 0; % read new file object if and when it is needed else    disp('unknown format. aborting @ background calculation ...');    returnenddisp(['Background calculating from ',int2str(StartFrame),' to ',int2str(EndFrame),' in increments of ',int2str(FrameInterval)]);NumOfFrames = round((EndFrame-StartFrame+1)/FrameInterval);progbars    = 10;if strcmpi(method,'median') || strcmpi(method,'percentile_10')        MaxAllowedNumOfFrames   = 100;    if NumOfFrames > MaxAllowedNumOfFrames        FrameInterval = round((EndFrame-StartFrame+1) / MaxAllowedNumOfFrames);        NumOfFrames   = round((EndFrame-StartFrame+1)/FrameInterval);        disp(['To avoid large computation time, FrameInterval is enlarged to ',int2str(FrameInterval)]);    end        cdata_mat   = uint16(zeros(MATSIZE(1),MATSIZE(2),NumOfFrames));    ind         = 0;    for Frame = StartFrame:FrameInterval:EndFrame        ind = ind+1;        % Read frame, depending on the video format        if VideoFormat==2                       % A single multiple-tiff file            Mov                = imread(FileFullName, Frame);             elseif VideoFormat==1                   % A sequence of tiff files            FileFullName       = [DirName,'\',FileNames{Frame}];             Mov                = imread(FileFullName);                                  elseif VideoFormat==3                   % A single avi movie file            Mov                = read(MovieObj, Frame);                 Mov                = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!        elseif VideoFormat==4                   % A sequence of avi movie files            CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);                        if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                FileFullName         = [DirName,'\',FileNames{CurrentMovieObjFile}];                 PreviousMovieObjFile = CurrentMovieObjFile;                MovieObj             = VideoReader(FileFullName);            end            CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);            Mov                      = read(MovieObj, CurrentFrameNumberInFile);                 Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                   end                if UseGaussianFilter           Mov = imfilter(Mov,GaussianFilter);         end                % store frame data        cdata_mat(:,:,ind) = Mov;              if mod(Frame * progbars,(EndFrame-StartFrame+1)) < progbars*FrameInterval     % Progress bar- 10x ':'            fprintf(':');         end        end    cdata_mat = single(cdata_mat);        if UseGaussianFilter        cdata_mat = imfilter(cdata_mat,GaussianFilter);    end        fprintf('\nCalculating median\n');    cdatamean       = mean(cdata_mat,3);    background_mean = uint16(round(cdatamean));    cdatamedian       = median(cdata_mat,3);    background_median = uint16(round(cdatamedian));            if strcmpi(method,'median')         background = background_median;    elseif strcmpi(method,'percentile_10')        fprintf('\nCalculating percentile [10%] \n');        % prctile returns percentiles of the values in cdata along the 3rd dimention. p is a scalar or a vector of percent values.        % BEWARE!!! This is a Matlab Function but may be called to Dirk's one on the path !!         p                     = 10;        cdata_percentile      = prctile(double(cdata_mat),p,3);                     background_percentile = uint16(round(cdata_percentile));        background            = background_percentile;    end           if plot_background        figure('name','background');         if strcmpi(method,'percentile_10')            subplot(1,3,1); h(1)=imshow(background_mean,[]);       title('mean');               subplot(1,3,2); h(2)=imshow(background_median,[]);     title('median');             subplot(1,3,3); h(3)=imshow(background_percentile,[]); title([num2str(p),' percent']);         else            subplot(1,2,1); h(1)=imshow(background_mean,[]);       title('mean');               subplot(1,2,2); h(2)=imshow(background_median,[]);     title('median');         end                  % figure; imagesc(background_mean - background_median); colorbar; set(gca,'Clim',[0 10])    end    else   % MEAN    if ~strcmpi(method,'mean')             disp('Background calculation method is not properly defined. Using mean...');    end        MaxAllowedNumOfFrames   = 400;    if NumOfFrames > MaxAllowedNumOfFrames        FrameInterval = round((EndFrame-StartFrame+1) / MaxAllowedNumOfFrames);        NumOfFrames   = round((EndFrame-StartFrame+1)/FrameInterval);        disp(['To avoid large computation time, FrameInterval is enlarged to ',int2str(FrameInterval)]);    end        cdata_mat = single(zeros(MATSIZE));    for Frame = StartFrame:FrameInterval:EndFrame         % Read frame, depending on the video format         if VideoFormat==2                       % A single multiple-tiff file            Mov                = imread(FileFullName, Frame);             elseif VideoFormat==1                   % A sequence of tiff files            FileFullName      = [DirName,'\',FileNames{Frame}];             Mov                = imread(FileFullName);                                  elseif VideoFormat==3                   % A single avi movie file            Mov                = read(MovieObj, Frame);                 Mov                = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!        elseif VideoFormat==4                   % A sequence of avi movie files            CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);            if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                FileFullName        = [DirName,'\',FileNames{CurrentMovieObjFile}];                 PreviousMovieObjFile = CurrentMovieObjFile;                MovieObj             = VideoReader(FileFullName);            end            CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);            Mov                      = read(MovieObj, CurrentFrameNumberInFile);                 Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                   end                if UseGaussianFilter           Mov = imfilter(Mov,GaussianFilter);         end                % Add to previous frames        cdata_mat     = cdata_mat + single(Mov);        if mod(Frame * progbars,(EndFrame-StartFrame+1)) < progbars*FrameInterval     % Progress bar- 10x ':'            fprintf(':');         end        end    if UseGaussianFilter        cdata_mat = imfilter(cdata_mat,GaussianFilter);    end    background = uint16(cdata_mat/NumOfFrames);    fprintf('\n');    if plot_background        figure('name','background (mean)'); %         imagesc(background);  set(gca,'Clim',[0 255]); title('mean');   colorbar        imshow (background,[]);  set(gca,'Clim',[0 255]); title('mean');   colorbar    endend% Transfer background to uint8 if movie was in uint8 formatX=whos('Mov'); CLASS = X.class;if strcmpi(CLASS,'uint8')    background = uint8(background);end% save background mat fileFile.BackgroundFile = [File.TrackFile(1:end-4),'_background.mat'];save(File.BackgroundFile, 'background');% save background image if Background_params.save       [FileName,PathName] = uiputfile('*.bmp', 'Save Background Image');    if FileName ~= 0        imwrite(uint8(background),[PathName, FileName], 'bmp');    endendif isfield(Background_params,'CalcMaskAndVignetting_fromDye')    if Background_params.CalcMaskAndVignetting_fromDye        %%        % Step 1: Define area in the middle of FOV that consist of both a post and non-post areas.            % Step 2: Find frames with maximal dye intensity            % Step 3: Define maximal intensity of dye and maximal intensity of posts. Use them to generate Masks and vignetting reference.           %              Maximal post intensity is used as Mask threhold           %              Maximal dye intensity is used as a reference for vignetting calculation         %   NOTE !!! I assume that minimal dye pattern values (at frame edges) are larger than maximal post levels (in the middle)            %% Step 1: Define area in the middle of FOV that consist of both a post and non-post areas.        Midpoint_Coordinates      = round(MATSIZE/2);         TwiceRadiusOfPostInPixels = File.PixelSize*0.4/2;       % PixelSize == pixel/mm        MidCircle                 = false(MATSIZE);        MidCircle(Midpoint_Coordinates(1),Midpoint_Coordinates(2)) = 1;               SE                        = strel('disk', round(TwiceRadiusOfPostInPixels),0);        MidCircle                 = imdilate(MidCircle,SE);        % figure; imshow(MidCircle,[])        %% Step 2: Find frames with maximal dye intensity        EndFrame        = File.VariablesInformation.FramesOfInterest.DyePatterns(2);        StartFrame      = File.VariablesInformation.FramesOfInterest.DyePatterns(1);            FrameInterval   = File.FrameRate; % 1 second        FramesToAnalyze = StartFrame:FrameInterval:EndFrame;        NumOfFrames     = length(FramesToAnalyze);        DyeIntensity  = zeros(1,NumOfFrames,'single');        ind=0;        for Frame = FramesToAnalyze            ind = ind+1;            % Read frame, depending on the video format            if VideoFormat==2                       % A single multiple-tiff file                Mov                = imread(FileFullName, Frame);                 elseif VideoFormat==1                   % A sequence of tiff files                FileFullName       = [DirName,'\',FileNames{Frame}];                 Mov                = imread(FileFullName);                                      elseif VideoFormat==3                   % A single avi movie file                Mov                = read(MovieObj, Frame);                     Mov                = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!            elseif VideoFormat==4                   % A sequence of avi movie files                CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);                            if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                    FileFullName         = [DirName,'\',FileNames{CurrentMovieObjFile}];                     PreviousMovieObjFile = CurrentMovieObjFile;                    MovieObj             = VideoReader(FileFullName);                end                CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);                Mov                      = read(MovieObj, CurrentFrameNumberInFile);                     Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                       end            Mov              = single(imsubtract(Mov,background));            vec              = Mov(MidCircle(:));            DyeIntensity(ind)= prctile(vec,90);                end        InterpolationFactor = 0.01;        Smoothed_DyeIntensity = csaps(1:length(DyeIntensity),double(DyeIntensity),InterpolationFactor,1:length(DyeIntensity));        [MaxDyeIntensity, MaxInd] = max(Smoothed_DyeIntensity);        LastAllDyeFrame_index  = find(Smoothed_DyeIntensity(MaxInd:end)>0.98*MaxDyeIntensity,1,'last')+MaxInd-1;        FirstAllDyeFrame_index = find(Smoothed_DyeIntensity(1:MaxInd)>0.98*MaxDyeIntensity,1,'first');        LastAllDyeFrame  = FramesToAnalyze(LastAllDyeFrame_index);        FirstAllDyeFrame = FramesToAnalyze(FirstAllDyeFrame_index);    %     figure; plot(DyeIntensity,'b-'); hold on; plot(Smoothed_DyeIntensity,'r-');        File.VariablesInformation.FramesOfInterest.OnlyDye(2) = LastAllDyeFrame;        File.VariablesInformation.FramesOfInterest.OnlyDye(1) = FirstAllDyeFrame;        File.DyePattern_MidPixelValues = Smoothed_DyeIntensity;         File.DyePattern_MidPixelFrames = FramesToAnalyze;         EndFrame      = LastAllDyeFrame;        StartFrame    = FirstAllDyeFrame;        %% Step 3: Define maximal intensity of dye and maximal intensity of posts. Use them to generate Masks and vignetting reference.           %              Maximal post intensity is used as Mask threhold           %              Maximal dye intensity is used as a reference for vignetting calculation         %   NOTE !!! I assume that minimal dye pattern values (at frame edges) are larger than maximal post levels (in the middle)            FrameInterval   = File.FrameRate; % 2 seconds        FramesToAnalyze = StartFrame:FrameInterval:EndFrame;        NumOfFrames     = length(FramesToAnalyze);        cdata_mat   = uint16(zeros(MATSIZE(1),MATSIZE(2),NumOfFrames));        ind         = 0;        for Frame = FramesToAnalyze            ind = ind+1;            % Read frame, depending on the video format            if VideoFormat==2                       % A single multiple-tiff file                Mov                = imread(FileFullName, Frame);                 elseif VideoFormat==1                   % A sequence of tiff files                FileFullName       = [DirName,'\',FileNames{Frame}];                 Mov                = imread(FileFullName);                                      elseif VideoFormat==3                   % A single avi movie file                Mov                = read(MovieObj, Frame);                     Mov                = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!            elseif VideoFormat==4                   % A sequence of avi movie files                CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);                            if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                    FileFullName         = [DirName,'\',FileNames{CurrentMovieObjFile}];                     PreviousMovieObjFile = CurrentMovieObjFile;                    MovieObj             = VideoReader(FileFullName);                end                CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);                Mov                      = read(MovieObj, CurrentFrameNumberInFile);                     Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                       end            % store frame data            cdata_mat(:,:,ind) = Mov;                  if mod(Frame * progbars,(EndFrame-StartFrame+1)) < progbars*FrameInterval     % Progress bar- 10x ':'                fprintf(':');             end            end        cdata_mat          = double(cdata_mat);                  %     cdatamedian        = median(cdata_mat,3);    %     DyeMinusBackground = imsubtract(uint16(round(cdatamedian)),background);          cdata_prctile90    = prctile(cdata_mat,90,3);        DyeMinusBackground = imsubtract(uint16(round(cdata_prctile90)),background);          % Within the MidCircle defined in step 1: there will be a bistable histogram of maximal dye levels and maximal posts level.         MAT            = single(DyeMinusBackground);         MAT(~MidCircle)= NaN;        vec            = MAT(~isnan(MAT(:)));        [N, X] = hist(vec,100); N = N/sum(N); % this gives a two peak histogram: for dye value and post values in the middle of the field of view.          [pks,locs]=findpeaks(N,'MinPeakHeight',0.05);    %     figure; plot(X,N); hold on; plot( X(locs),pks,'r*')        if length(locs)~=2            disp('Problems with Mask generation. need to be debugged...')            Mask = true(MATSIZE);            keyboard;            % figure; plot(X,N); hold on; plot( X(locs),pks,'r*')            % locs = locs(1:2); pks = pks(1:2);        else            MedianPostValue = X(locs(1));            MedianDyeValue  = X(locs(2));    %         MaxDyeValue     = max(vec);            ThresholdForMask = 1.5*MedianPostValue;            % Mask: true within the worms crawling area, false elsewhere             Mask =  true(MATSIZE);            Mask(DyeMinusBackground<ThresholdForMask)=false;            Mask = ~(imclose(~Mask,strel('disk',1,0)));            VignettingPattern        = single(DyeMinusBackground);            VignettingPattern(~Mask) = NaN;            VignettingPattern        = VignettingPattern / prctile(VignettingPattern(:),99);                end        if plot_background            figure; plot(DyeIntensity,'b-'); hold on; plot(Smoothed_DyeIntensity,'r-');            figure; plot(X,N); hold on; plot( X(locs),pks,'r*')            figure; imshow(DyeMinusBackground,[]);            figure; imshow(Mask,[]);            figure; imshow(VignettingPattern,[]);            figure; imagesc(VignettingPattern); set(gca,'clim',[0 1]); axis equal; colorbar                end               % save background mat file        save(File.BackgroundFile, 'DyeMinusBackground','Mask','VignettingPattern','-append');            endend% imshow(background);% pause;returnfunction [Worm_PROPS, AnimalPix, threshold, NumberOfObjects] = AutoThreshold_AndFindWormProps_Imaging_v01(Movdiv, AutoThreshold_params, Pixels_per_mm, LimitCommandWindowFeedback, FLUORESCENCE_STREL1, FLUORESCENCE_STREL2, MaxNumOfWorms, AddProps, MidlineCalculationParams, VignettingPattern )if ~exist('LimitCommandWindowFeedback','var')    LimitCommandWindowFeedback = false;endif isfield(AutoThreshold_params,'MaxWorm_size')               MaxWorm_size        = AutoThreshold_params.MaxWorm_size;          % Defined in mm^2, example value=0.08 (Regular adult is ~0.07)        MaxWorm_NumOfPixels = MaxWorm_size* (Pixels_per_mm^2);            % Pixels_per_mm correponds to the LINEAR dimension of a pixel endif isfield(AutoThreshold_params,'MinWorm_size')        MinWorm_size   = AutoThreshold_params.MinWorm_size;   % Defined in mm^2    else    MinWorm_size   = 0.04;                                % Dirk used  ~0.016endMinWorm_NumOfPixels = MinWorm_size* (Pixels_per_mm^2);     % Pixels_per_mm correponds to the LINEAR dimension of a pixel if isfield(AutoThreshold_params,'use_filter')   % Dirk's filter     use_filter = AutoThreshold_params.use_filter;else    use_filter = 0;endif isfield(AutoThreshold_params,'thrlist')      % Thresholds list with repect to the NORMALIZED MOVIE (values b/w [0 1])    thrlist = AutoThreshold_params.thrlist;else    thrlist = 0.5:-0.01:0.01;end%% Filter or not? Notif exist('use_filter','var') && use_filter       % Use filter    MAT = imfilter(Movdiv,fspecial('average',3));else                                             % No filter, scaled image     MAT = Movdiv;end%% Find Number of object with different thresholds N             = zeros(1,length(thrlist));Real_obj_num  = zeros(1,length(thrlist));Final_BW_MAT = false(size(MAT));for th = 1:length(thrlist)    thr         = thrlist(th);    BW          = im2bw(MAT,thr);    PROPS            = regionprops(BW,'Area','PixelIdxList');       objsize          = [PROPS.Area];    N(th)            = length(objsize);    IndicesOfWorms   = find((objsize>MinWorm_NumOfPixels)&(objsize<MaxWorm_NumOfPixels));    Real_obj_num(th) = length(IndicesOfWorms);      if Real_obj_num(th)>0            % At least one worm object was found                 if nansum(Real_obj_num) > MaxNumOfWorms             % Error: too many worms were found- abort this frame            break        end        WormPixels = vertcat(PROPS(IndicesOfWorms).PixelIdxList);        Final_BW_MAT(WormPixels) = true;               if nansum(Real_obj_num) == MaxNumOfWorms             % All Worms Were Found            break        else           % reset MAT for next loops to avoid counting the same worms twice           MAT(WormPixels)= 0;       end    end    endthreshold = thrlist(th); % last threshold used%%% This addition may be useful for large worms % BWopen      = imopen(Final_BW_MAT, FLUORESCENCE_STREL1);% BWopenclose = imclose(BWopen,      FLUORESCENCE_STREL1);  % BWopen2     = imopen(BWopenclose,  FLUORESCENCE_STREL2);% Final_BW_MAT = BWopen2;   Final_BW_MAT = imclose(Final_BW_MAT,  strel('disk',2));  % The function below is highly time-consuming PROPS       = regionprops(Final_BW_MAT,'area','PixelIdxList','Centroid', 'Eccentricity', 'MajorAxisLength', 'MinorAxisLength', ...                             'Orientation', 'Image', 'BoundingBox');                         objsize     = [PROPS.Area];worm_obj    = setdiff(find(objsize > MinWorm_NumOfPixels), find(objsize > MaxWorm_NumOfPixels));  % Find large enough objects that are not too largeNumberOfObjects = length(worm_obj);                         Worm_PROPS  = ReduceStructure (PROPS , worm_obj);if AddProps    Worm_PROPS  = AddBasicMorphologyPatterns (Worm_PROPS   , size(Final_BW_MAT));endif (AddProps==2)||(AddProps==3)     % Advanced morphology features (midline and head vs. tail), if AddProps==3: add full worm patterns in the worms' coordinate system.      Worm_PROPS  = Add_GrayScale_Midline_and_RelativeCoordinates_Info (Worm_PROPS, MAT, MidlineCalculationParams, AddProps, VignettingPattern);                                                                              endif ~isempty(Worm_PROPS)    AnimalPix = mean([Worm_PROPS.Area]);else    AnimalPix = NaN;end%% Optional Plotstoc% % BW_Matrix = Create_BW_Matrix_from_images(Worm_PROPS, size(BW));% % BW_Matrix = Create_BW_Matrix_from_PixelsList(Worm_PROPS, size(BW),'PixelIdxList');% % BW_Matrix = Create_BW_Matrix_from_PixelsList(Worm_PROPS, size(BW),'Skeleton_PixelIdxList');% % BW_Matrix = Create_BW_Matrix_from_PixelsList(Worm_PROPS, size(BW),'HeadTail_PixelIdxList');% % BW_Matrix = Create_BW_Matrix_from_PixelsList(Worm_PROPS, size(BW),'Perimeter_PixelIdxList');% % % BW_Matrix = Create_BW_Matrix_from_PixelsList(Worm_PROPS, size(BW),'PixelIdxList');% % Plot_PixelList_on_Frame(Worm_PROPS, size(BW), 'Perimeter_PixelIdxList', [], 'g')% % Plot_PixelList_on_Frame(Worm_PROPS, size(BW), 'Skeleton_PixelIdxList', [], 'k')% % Plot_PixelList_on_Frame(Worm_PROPS, size(BW), 'HeadTail_PixelIdxList', [], 'k')% % figure; imshow(MAT,[])% Plot_PixelList_on_Frame(Worm_PROPS.WormPerimeter, size(Final_BW_MAT), 'LinearIndices', [], 'c')% Plot_PixelList_on_Frame(Worm_PROPS.Midline, size(Final_BW_MAT), 'LinearIndices', [], 'm')if ~ LimitCommandWindowFeedback    disp(['NumOfWorms = ',num2str(NumberOfObjects),...          ' (Animal = ',num2str(AnimalPix),' pixels; ', num2str(AnimalPix / Pixels_per_mm^2, 3),' mm^2)',char(10)]);  endreturnfunction ReducedStructure  = ReduceStructure (Structure , RelevantIndices)if isempty(RelevantIndices)    ReducedStructure=[];    returnendReducedStructure.Area            = uint16([Structure(RelevantIndices).Area]);ReducedStructure.Eccentricity    = single([Structure(RelevantIndices).Eccentricity]);ReducedStructure.MajorAxisLength = single([Structure(RelevantIndices).MajorAxisLength]);ReducedStructure.MinorAxisLength = single([Structure(RelevantIndices).MinorAxisLength]);ReducedStructure.Orientation     = single([Structure(RelevantIndices).Orientation]);% Finding [x y] coordinates. These X and Y's correspond to what you see in imagesc BUT NOT TO THE DIMENSIONS OF Matdiv !!  NumWorms                         = single(length(RelevantIndices));WormBox                          = [Structure(RelevantIndices).BoundingBox];ReducedStructure.BoundingBox     = single([WormBox(1:4:4*NumWorms)', WormBox(2:4:4*NumWorms)']);            % Upper-Left corner of the bounding boxWormCentroid                     = [Structure(RelevantIndices).Centroid];ReducedStructure.Centroid        = single(WormCentroid);  ReducedStructure.Coordinates     = single([WormCentroid(1:2:2*NumWorms)', WormCentroid(2:2:2*NumWorms)']) ; % Centroid for wi = 1:length(RelevantIndices)    ReducedStructure.Image{wi}        = Structure(RelevantIndices(wi)).Image;        % BW image. Check syntax !!    ReducedStructure.PixelIdxList{wi} = single(Structure(RelevantIndices(wi)).PixelIdxList); % Centroid endreturnfunction Worm_PROPS  = AddBasicMorphologyPatterns (Worm_PROPS_in, OriginalFrameSize)  % Note that here I also corrected the skeleton representation by eliminating the 'spurs'. The price: a loop... % OriginalFrameSize == Original Image SizeWorm_PROPS = Worm_PROPS_in;if isempty(Worm_PROPS)    returnendNumWorms = length(Worm_PROPS.Area);% LinearIndices are saved: Global= full image,  Local= single worm image.   WormArea.Xcoordinate             = cell(1,NumWorms);WormArea.Ycoordinate             = cell(1,NumWorms);WormArea.LinearIndices           = Worm_PROPS.PixelIdxList;WormLengths                      = uint16(zeros(1,NumWorms));WormPerimeterLengths             = uint16(zeros(1,NumWorms));WormSkeleton.Xcoordinate         = cell(1,NumWorms);WormSkeleton.Ycoordinate         = cell(1,NumWorms);WormSkeleton.LinearIndices       = cell(1,NumWorms);WormPerimeter.Xcoordinate        = cell(1,NumWorms);WormPerimeter.Ycoordinate        = cell(1,NumWorms);WormPerimeter.LinearIndices      = cell(1,NumWorms);for wi = 1:length(Worm_PROPS.Area)    % XY coordinates of the worm area    [AreaPixels.X, AreaPixels.Y] = ind2sub(OriginalFrameSize,Worm_PROPS.PixelIdxList{wi});    WormArea.Xcoordinate{wi}   = uint16(AreaPixels.X);    WormArea.Ycoordinate{wi}   = uint16(AreaPixels.Y);        IM                        = Worm_PROPS.Image{wi};          % BW image    UpperLeft_Coordinate_Dim2 = Worm_PROPS.BoundingBox(wi,1)-0.5;      UpperLeft_Coordinate_Dim1 = Worm_PROPS.BoundingBox(wi,2)-0.5;          %%% Find properties...    BW_thin             = bwmorph(IM,'thin',inf);    BW_endpoints        = bwmorph(BW_thin,'endpoints',inf);               % End points    [I_all ,J_all]      = find(BW_endpoints==1);           NumOfEndPoints      = length(I_all);    if NumOfEndPoints == 0       % e.g. for a circular worm object        continue;    end    % Correct Skeleton if more than 2 endpoints were found:    counter=0;    while NumOfEndPoints>2         counter = counter+1;        % Find spur endpoints (that are 'in the middle' of the skeleton)        Distances = zeros(NumOfEndPoints);        for n=1:NumOfEndPoints            Distances (n,:)= sqrt((I_all-I_all(n)).^2 + (J_all-J_all(n)).^2);        end        [row col]         = find(Distances==max(Distances(:)));        indices           = [row(1) col(1)];  % The real endpoints         Indices_to_reject = setdiff (1:NumOfEndPoints, indices);        I_reject          = I_all(Indices_to_reject);        J_reject          = J_all(Indices_to_reject);                % Correct BW_thin and recalculate the endpoints        for rej_ind = 1:length(I_reject)            BW_thin(I_reject(rej_ind),J_reject(rej_ind)) = false;         end        [I_all ,J_all]      = find(bwmorph(BW_thin,'endpoints',inf)==1);               NumOfEndPoints      = length(I_all);        if counter>100%             disp(['Stopping while loop for skeleton correction', char(10)]);            break        end    end            % Skeleton    [I_thin,J_thin]     = find(BW_thin==1);          WormLengths(wi)     = length(I_thin);        Coordinates         = [J_thin + UpperLeft_Coordinate_Dim2, I_thin + UpperLeft_Coordinate_Dim1];   % Matrix of [x y] locations of the skeleton      WormSkeleton.Xcoordinate{wi}   = uint16(Coordinates(:,2));              WormSkeleton.Ycoordinate{wi}   = uint16(Coordinates(:,1));        WormSkeleton.LinearIndices{wi} = single(sub2ind(OriginalFrameSize, double(WormSkeleton.Xcoordinate{wi}), double(WormSkeleton.Ycoordinate{wi})));          % Perimeter - outer    row     = 1;    col     = find(IM(row,:),1,'first');        CONTOUR = bwtraceboundary(IM, [row, col],'E');    I_perim = CONTOUR(:,1);     J_perim = CONTOUR(:,2);    WormPerimeterLengths(wi)     = length(I_perim);        Coordinates         = [J_perim + UpperLeft_Coordinate_Dim2, I_perim + UpperLeft_Coordinate_Dim1]; % Matrix of [x y] locations of the perimeter           WormPerimeter.Xcoordinate{wi}   = uint16(Coordinates(:,2));              WormPerimeter.Ycoordinate{wi}   = uint16(Coordinates(:,1));        WormPerimeter.LinearIndices{wi} = single(sub2ind(OriginalFrameSize, double(WormPerimeter.Xcoordinate{wi}), double(WormPerimeter.Ycoordinate{wi})));  endWorm_PROPS.WormArea        = WormArea;Worm_PROPS.SkeletonLength  = uint16(WormLengths);Worm_PROPS.PerimeterLength = uint16(WormPerimeterLengths);Worm_PROPS.WormSkeleton    = WormSkeleton;Worm_PROPS.WormPerimeter   = WormPerimeter;returnfunction Worm_PROPS  = Add_GrayScale_Midline_and_RelativeCoordinates_Info (Worm_PROPS, MAT, MidlineCalculationParams, AddProps, VignettingPattern)if isempty(Worm_PROPS)    returnendImageSize = size(MAT);MAT_VignettingCorrected = single(MAT) ./ VignettingPattern; % h         = fspecial('average'); % smear the signal (like out of focus). Since the perimeter is not perfectly aligned, this may give more robust and reliable pattern.% MAT_ave   = imfilter(MAT, h);% h         = fspecial('gauss');% MAT_Gauss = imfilter(MAT, h);%% Store gray scale informationNumWorms                  = length(Worm_PROPS.Area);Worm_PROPS.PatternValues  = cell(1,NumWorms);for wi = 1:NumWorms        Worm_PROPS.PatternValues{wi}                     = MAT(Worm_PROPS.PixelIdxList{wi});  % corresponding to the coordinates given at 'Worm_PROPS.WormArea.Xcoordinate' and 'Worm_PROPS.WormArea.Ycoordinate'     Worm_PROPS.PatternValues_VignettingCorrected{wi} = MAT_VignettingCorrected(Worm_PROPS.PixelIdxList{wi});  % corresponding to the coordinates given at 'Worm_PROPS.WormArea.Xcoordinate' and 'Worm_PROPS.WormArea.Ycoordinate'     end%% Calculate midline coordinates, head vs. tail coordinates and pattern matrix in the worms' coordinate system  Worm_PROPS.Midline.Length               = Worm_PROPS.SkeletonLength;Worm_PROPS.Midline.X_coordinates_short  = cell(1,NumWorms);Worm_PROPS.Midline.Y_coordinates_short  = cell(1,NumWorms);Worm_PROPS.Midline.X_coordinates        = cell(1,NumWorms);Worm_PROPS.Midline.Y_coordinates        = cell(1,NumWorms);Worm_PROPS.Midline.FlagTrueIfReliable   = false(1,NumWorms);Worm_PROPS.HeadTail                     = single(zeros(NumWorms,2,2));if AddProps ==3       Worm_PROPS.Midline.Angle                = cell(1,NumWorms);    Worm_PROPS.WormCoordinates.Length       = cell(1,NumWorms);    Worm_PROPS.WormCoordinates.Width        = cell(1,NumWorms);    Worm_PROPS.PatternMatrix                = cell(1,NumWorms);    Worm_PROPS.PositionMatrixX              = cell(1,NumWorms);    Worm_PROPS.PositionMatrixY              = cell(1,NumWorms);endfor wi = 1:NumWorms    Skeleton_LinearIndices  = double(Worm_PROPS.WormSkeleton.LinearIndices{wi});          if ~isempty(Skeleton_LinearIndices) && (length(Skeleton_LinearIndices)>2)  % Midline of at least 3 pixels!!        if AddProps==2                        [Midline, HeadTail] = ExtractPositionMatrix (Skeleton_LinearIndices, ImageSize, MidlineCalculationParams, AddProps);   % ~22 msec            Midline.Pattern     = MAT(round(Midline.LinearIndices));               %             figure; %             LEN = length(Midline.Pattern);%             subplot(1,2,1);  plot(Midline.Pattern,'b*-'); hold on; hold on; plot([5:10, (LEN-10):(LEN-5)],Midline.Pattern([5:10, (LEN-10):(LEN-5)]),'g*');%             subplot(1,2,2);   %             imshow(MAT,[]); hold on; %             plot(round(Midline.Y_coordinates_short),     round(Midline.X_coordinates_short),     'r.');  hold on; %             plot(round(Midline.Y_coordinates_short(end)),round(Midline.X_coordinates_short(end)),'r*');   hold on;        elseif AddProps==3            [Midline, HeadTail, PositionMatX, PositionMatY] = ExtractPositionMatrix (Skeleton_LinearIndices, ImageSize, MidlineCalculationParams, AddProps);   % ~22 msec            Midline.Pattern                                 = MAT(round(Midline.LinearIndices));                                       %% FOR PATTERN RECOGNITION - this part is time-limiting (interp2~70msec and loop). ~140 msec            AreaIndices.X           = single(Worm_PROPS.WormArea.Xcoordinate{wi});                                                                                        AreaIndices.Y           = single(Worm_PROPS.WormArea.Ycoordinate{wi});                                                          WormCoordinates.Length  = single(zeros(size(AreaIndices.X)));            WormCoordinates.Width   = single(zeros(size(AreaIndices.X)));            Indices                 = single(zeros(1,length(AreaIndices.X)));    % indices in the midline vector where the midline is closest to the pixel.            PatternMatrix                     = interp2(1:ImageSize(2), 1:ImageSize(1), double(MAT), PositionMatY, PositionMatX, 'linear');             PatternMatrix_VignettingCorrected = interp2(1:ImageSize(2), 1:ImageSize(1), double(MAT_VignettingCorrected), PositionMatY, PositionMatX, 'linear');             for pix_ind = 1:length(AreaIndices.X)                   %                 DistanceFromMidline = sqrt((Midline.X_coordinates - AreaIndices.X(pix_ind)).^2 + (Midline.Y_coordinates - AreaIndices.Y(pix_ind)).^2);                [min_val, min_ind]  = min(DistanceFromMidline);                Indices(pix_ind)    = min_ind;                WormCoordinates.Width(pix_ind)  = min_val;                WormCoordinates.Length(pix_ind) = min_ind / MidlineCalculationParams.WormMatrixLength * length(Midline.X_coordinates_short)  ;   % This is the index in the LONG VECTOR THAT WAS OVER SAMPLED!!!!            end            % below the midline switch width coordinates to negative values             ClosestMidlineLocation.X        = Midline.X_coordinates(Indices)';            ClosestMidlineLocation.Y        = Midline.Y_coordinates(Indices)';            Angle_PixRelativeToMidline      = atan2((AreaIndices.Y - ClosestMidlineLocation.Y),(AreaIndices.X - ClosestMidlineLocation.X))/pi*180;            MidlineAngle_at_ClosestLocation = Midline.Angle(Indices)';            AboveMidlineIndices             = Angle_PixRelativeToMidline>MidlineAngle_at_ClosestLocation;            WormCoordinates.Width(~AboveMidlineIndices) = -WormCoordinates.Width(~AboveMidlineIndices);        end                %% assign values to output structure        Worm_PROPS.Midline.X_coordinates_short{wi} = Midline.X_coordinates_short;         Worm_PROPS.Midline.Y_coordinates_short{wi} = Midline.Y_coordinates_short;         Worm_PROPS.Midline.LinearIndices{wi}       = Midline.LinearIndices;         Worm_PROPS.Midline.Pattern{wi}             = Midline.Pattern;         Worm_PROPS.Midline.X_coordinates{wi}       = Midline.X_coordinates;         Worm_PROPS.Midline.Y_coordinates{wi}       = Midline.Y_coordinates;         Worm_PROPS.Midline.FlagTrueIfReliable(wi)  = Midline.Flag;                Worm_PROPS.HeadTail(wi,:,:)                = HeadTail;                if AddProps==3            Worm_PROPS.Midline.Angle{wi}                     = Midline.Angle;             Worm_PROPS.WormCoordinates.Length{wi}            = WormCoordinates.Length;            Worm_PROPS.WormCoordinates.Width{wi}             = WormCoordinates.Width;            Worm_PROPS.PatternMatrix{wi}                     = single(PatternMatrix);            Worm_PROPS.PatternMatrix_VignettingCorrected{wi} = single(PatternMatrix_VignettingCorrected);                        Worm_PROPS.PositionMatrixX{wi}                   = single(PositionMatX);            Worm_PROPS.PositionMatrixY{wi}                   = single(PositionMatY);        end                    else        % If the worm skeleton was not found- assign empty vectors and NaNs.           Worm_PROPS.Midline.X_coordinates_short{wi} = [];         Worm_PROPS.Midline.Y_coordinates_short{wi} = [];         Worm_PROPS.Midline.LinearIndices{wi}       = [];         Worm_PROPS.Midline.Pattern{wi}             = [];         Worm_PROPS.Midline.X_coordinates{wi}       = [];         Worm_PROPS.Midline.Y_coordinates{wi}       = [];         Worm_PROPS.Midline.FlagTrueIfReliable(wi)  = false;                Worm_PROPS.HeadTail(wi,:,:)                = single(zeros(2))*NaN;                if AddProps==3            Worm_PROPS.Midline.Angle{wi}               = [];             Worm_PROPS.WormCoordinates.Length{wi}      = [];            Worm_PROPS.WormCoordinates.Width{wi}       = [];            Worm_PROPS.PatternMatrix{wi}               = [];            Worm_PROPS.PatternMatrix_VignettingCorrected{wi} = [];            Worm_PROPS.PositionMatrixX{wi}             = [];            Worm_PROPS.PositionMatrixY{wi}             = [];        end    end        end% Distinguish the head vs. the tail using the gray scale along the midline axis. Limits are given by the user.  if MidlineCalculationParams.UseMidlineGrayScale_ForHeadvsTail       [Worm_PROPS.Midline, Worm_PROPS.HeadTail] = Find_HeadVsTail_And_MidlineAngleProperties (Worm_PROPS.Midline, Worm_PROPS.HeadTail, MidlineCalculationParams);end% figure; plot(mean(Worm_PROPS.PatternMatrix{1},1)); hold on; plot(mean(Worm_PROPS.PatternMatrix{2}(:,end:-1:1),1));  plot(mean(Worm_PROPS.PatternMatrix{3},1));% LEN = 100;% for wi = 1:NumWorms %     Noise(wi,1) = std(mean(Worm_PROPS.PatternMatrix{wi}(:,1:LEN),1),1)          ./mean(mean(Worm_PROPS.PatternMatrix{wi}(:,1:LEN),1));%     Noise(wi,2) = std(mean(Worm_PROPS.PatternMatrix{wi}(:,(end-LEN+1):end),1),1)./mean(mean(Worm_PROPS.PatternMatrix{wi}(:,(end-LEN+1):end),1));% endreturnfunction [Midline, HeadTail] = Find_HeadVsTail_And_MidlineAngleProperties (Midline, HeadTail, MidlineCalculationParams) %% Input/Output arguments:% 'Midline' is a structure imbedded in the 'Worm_PROPS' structure, where each of each subfields is a cell array of length (NumOfWorms).   % With 'wi' being the worm index, each cell contains a vector as indicated by its name: %         Midline.X_coordinates_short{wi} %         Midline.Y_coordinates_short{wi} %         Midline.LinearIndices{wi}       %         Midline.Pattern{wi}           %         Midline.X_coordinates{wi}      %         Midline.Y_coordinates{wi}       %         Midline.Angle{wi}              %         Midline.FlagTrueIfReliable(wi) %% HeadTail is a 3D matrix of size (NumOfWorms,2,2)% With 'wi' being the worm index %        HeadTail(wi,1,:) contains the [X Y] coordinates of the FIRST  midline edge %        HeadTail(wi,2,:) contains the [X Y] coordinates of the SECOND midline edge %% This function calculates the head and tail coordinates based on the grey scale along the midline near the edges.% The output arguments are the same but now all vectors in all fields of 'Midline' as well as the 'HeadTail' matrix are %     *******   ALIGNED TO START FROM HEAD AND FINISH AT THE TAIL *******%%  Call this function from the function 'Add_GrayScale_Midline_and_RelativeCoordinates_Info'   %      e.g. [Worm_PROPS.Midline, Worm_PROPS.HeadTail] = Find_Head_vs_Tail (Worm_PROPS.Midline, Worm_PROPS.HeadTail, DistancesFromEdges);DistancesFromEdges  = MidlineCalculationParams.DistanceAlongMidline_ForHeadvsTail;HeadTail_in    = HeadTail;NumOfWorms     = length(Midline.Length);MidlineLengths = single(Midline.Length); FirstPixels    = round(MidlineLengths*DistancesFromEdges(1));LastPixels     = round(MidlineLengths*DistancesFromEdges(2));FirstPixels(FirstPixels==0)=1;for wi=1:NumOfWorms    indices = FirstPixels(wi):LastPixels(wi);    if Midline.FlagTrueIfReliable(wi)        % Test if the pattern at the beginning of the midline is Brighter than the pattern at its ending. This is an indication the head and tail are switched.         Beginning_BrighterThan_Ending =   mean(Midline.Pattern{wi}(indices))  >  mean(Midline.Pattern{wi}(end-indices+1))   ;        if Beginning_BrighterThan_Ending            %             % 'Midline.Angle' gives the angle between pixels along the worm midline axis. %             %  Midline.Angle{wi}(n) gives the angle from of the (n) midline pixel relative to the (n-1) midline pixel,  except of Midline.Angle{wi}(1)==  Midline.Angle{wi}(2); %             %           {caluclated from THETA, where THETA = cart2pol(diff(sm_xx),diff(sm_yy)); THETA = [THETA(1) THETA]}    %             % The angles in 'Midline.Angle' are defined as the COUNTERCLOCKWISE DISPLACEMENT FROM THE +X AXIS, i.e. [0 90 180 270] corresponds to [+X +Y -X -Y], respectively.  %             TailToHeadAngles_StartingFromHead =  Midline.Angle{wi}([end end:-1:2]);                 % switch pixels to start from Head rather than the tail%             HeadToTailAngles_StartingFromHead =  mod(TailToHeadAngles_StartingFromHead+180, 360);   % switch angles direction%             %             Midline.Angle{wi}               =  HeadToTailAngles_StartingFromHead;            Midline.X_coordinates{wi}       =  Midline.X_coordinates{wi}(end:-1:1);            Midline.Y_coordinates{wi}       =  Midline.Y_coordinates{wi}(end:-1:1);            Midline.X_coordinates_short{wi} =  Midline.X_coordinates_short{wi}(end:-1:1);            Midline.Y_coordinates_short{wi} =  Midline.Y_coordinates_short{wi}(end:-1:1);            Midline.LinearIndices{wi}       =  Midline.LinearIndices{wi}(end:-1:1);            Midline.Pattern{wi}             =  Midline.Pattern{wi}(end:-1:1);            HeadTail(wi,1,:)                =  HeadTail_in(wi,2,:);            HeadTail(wi,2,:)                =  HeadTail_in(wi,1,:);                               end          end    end% %% Calculated midline angles (including head and tail alignments), and number of bendsMidline = CaluclateMidlineProperties(Midline, MidlineCalculationParams);returnfunction [Tracks, WormCoordinates] = UpdateActiveTracks_Fluor (Tracks_in , STATS, Frame, AddProps, MaxDistance, MaxRelativeSizeChange, MinTrackLength, SingleWormMode, MidlineCalculationParams)% SingleWormMode = optional parameter = If exists and true, it assumes only one worm in the movie.   %                  and therefore FORCES continuation of the active track regardless of distance and size.  Constrain_Linkage = false;if exist('SingleWormMode','var')    if SingleWormMode        Constrain_Linkage = true;    endendTracks           = Tracks_in;ActiveTracks     = find([Tracks.Active]);if ~isempty(STATS)    WormCoordinates  = STATS.Coordinates;else    WormCoordinates = [NaN NaN];end% Update active tracks with new coordinatesfor i = 1:length(ActiveTracks)    track_ind = ActiveTracks(i);        DistanceX = WormCoordinates(:,1) - Tracks(track_ind).LastCoordinates(1);    DistanceY = WormCoordinates(:,2) - Tracks(track_ind).LastCoordinates(2);    Distance  = sqrt(DistanceX.^2 + DistanceY.^2);                                % Distance b/w each worm in this frame to the objects from the previous one    [MinVal, MinIndex] = min(Distance);                                           % Object with the minimal distance        condition = (MinVal <= MaxDistance) && ( abs( STATS.Area(MinIndex) - Tracks(track_ind).LastSize )/Tracks(track_ind).LastSize < (MaxRelativeSizeChange/100) );      if condition || Constrain_Linkage        % very small distance AND similar worm area.  I NEED TO CHECK THE FALSE POSITIVE RATE!        Tracks(track_ind).Path            = [Tracks(track_ind).Path;         WormCoordinates(MinIndex, :)];        Tracks(track_ind).LastCoordinates = WormCoordinates(MinIndex,:);        Tracks(track_ind).Frames          = single([Tracks(track_ind).Frames,       Frame]);        Tracks(track_ind).Size            = [Tracks(track_ind).Size,         STATS.Area(MinIndex)];        Tracks(track_ind).LastSize        = STATS.Area(MinIndex);        Tracks(track_ind).Eccentricity    = [Tracks(track_ind).Eccentricity, STATS.Eccentricity(MinIndex)];        Tracks(track_ind).MajorAxes       = [Tracks(track_ind).MajorAxes   , STATS.MajorAxisLength(MinIndex)];        Tracks(track_ind).MinorAxes       = [Tracks(track_ind).MinorAxes   , STATS.MinorAxisLength(MinIndex)];        Tracks(track_ind).Orientation     = [Tracks(track_ind).Orientation , STATS.Orientation(MinIndex)];        Tracks(track_ind).Box             = [Tracks(track_ind).Box;          STATS.BoundingBox(MinIndex,:)];        TrackFrameNum                     = length(Tracks(track_ind).Size);        Tracks(track_ind).TrackLength     = single(TrackFrameNum);                Tracks(track_ind).Frame(TrackFrameNum).Image = STATS.Image(MinIndex);                if AddProps            Tracks(track_ind).WormArea.Xcoordinate(TrackFrameNum)       = STATS.WormArea.Xcoordinate(MinIndex);                 % vector of coordinates per worm per frame            Tracks(track_ind).WormArea.Ycoordinate(TrackFrameNum)       = STATS.WormArea.Ycoordinate(MinIndex);                 % vector of coordinates per worm per frame                       Tracks(track_ind).WormArea.LinearIndices(TrackFrameNum)     = STATS.WormArea.LinearIndices(MinIndex);               % vector of coordinates per worm per frame                       Tracks(track_ind).SkeletonLength                            = [Tracks(track_ind).SkeletonLength,   STATS.SkeletonLength(MinIndex)] ;            Tracks(track_ind).PerimeterLength                           = [Tracks(track_ind).PerimeterLength,  STATS.PerimeterLength(MinIndex)] ;            Tracks(track_ind).WormPerimeter.Xcoordinate(TrackFrameNum)  = STATS.WormPerimeter.Xcoordinate(MinIndex);            % vector of indices per worm per frame            Tracks(track_ind).WormPerimeter.Ycoordinate(TrackFrameNum)  = STATS.WormPerimeter.Ycoordinate(MinIndex);            % vector of indices per worm per frame                           Tracks(track_ind).WormPerimeter.LinearIndices(TrackFrameNum)= STATS.WormPerimeter.LinearIndices(MinIndex);          % vector of indices per worm per frame                                       if AddProps>=2                Tracks(track_ind).PatternValues(TrackFrameNum)                  = STATS.PatternValues(MinIndex);                % vector per worm per frame                Tracks(track_ind).Midline.X_coordinates_short(TrackFrameNum)    = STATS.Midline.X_coordinates_short(MinIndex);  % vector per worm per frame                Tracks(track_ind).Midline.Y_coordinates_short(TrackFrameNum)    = STATS.Midline.Y_coordinates_short(MinIndex);  % vector per worm per frame                Tracks(track_ind).Midline.LinearIndices(TrackFrameNum)          = STATS.Midline.LinearIndices(MinIndex);        % vector per worm per frame                Tracks(track_ind).Midline.Pattern(TrackFrameNum)                = STATS.Midline.Pattern(MinIndex);              % vector per worm per frame                Tracks(track_ind).Midline.X_coordinates(TrackFrameNum)          = STATS.Midline.X_coordinates(MinIndex);        % vector per worm per frame                Tracks(track_ind).Midline.Y_coordinates(TrackFrameNum)          = STATS.Midline.Y_coordinates(MinIndex);        % vector per worm per frame                Tracks(track_ind).Midline.Angle(TrackFrameNum)                  = STATS.Midline.Angle(MinIndex);                % vector per worm per frame                         Tracks(track_ind).Midline.FlagTrueIfReliable(TrackFrameNum)     = STATS.Midline.FlagTrueIfReliable(MinIndex);   % one logical value per worm per frame                                                if isfield(STATS.Midline,'AngleFirstPoint')                    Tracks(track_ind).Midline.AngleFirstPoint(TrackFrameNum)        = STATS.Midline.AngleFirstPoint(MinIndex);      % vector per worm per frame                                Tracks(track_ind).Midline.AngleLastPoint(TrackFrameNum)         = STATS.Midline.AngleLastPoint(MinIndex);       % vector per worm per frame                                Tracks(track_ind).Midline.NumOfBends_HighRes(TrackFrameNum)     = STATS.Midline.NumOfBends_HighRes(MinIndex);   % vector per worm per frame                                Tracks(track_ind).Midline.NumOfBends_LowRes(TrackFrameNum)      = STATS.Midline.NumOfBends_LowRes(MinIndex);    % vector per worm per frame                                             end                                Tracks(track_ind).HeadTail(TrackFrameNum,:,:)                   = squeeze(STATS.HeadTail(MinIndex,:,:));        % 2x2 matrix per worm per frame: first row=head, second is tail.                                                           if AddProps == 3                    Tracks(track_ind).WormCoordinates.Length(TrackFrameNum) = STATS.WormCoordinates.Length(MinIndex);        % vector per worm per frame                    Tracks(track_ind).WormCoordinates.Width(TrackFrameNum)  = STATS.WormCoordinates.Width(MinIndex);         % vector per worm per frame                    if Tracks(track_ind).Midline.FlagTrueIfReliable(TrackFrameNum)                                                                     Tracks(track_ind).PatternMatrix(TrackFrameNum,:,:)                    = STATS.PatternMatrix{MinIndex};           % Matrix per worm per frame                                                                                             Tracks(track_ind).PatternMatrix_VignettingCorrected(TrackFrameNum,:,:)= STATS.PatternMatrix_VignettingCorrected{MinIndex};           % Matrix per worm per frame                                                                                                                     Tracks(track_ind).PositionMatrixX(TrackFrameNum,:,:)                  = STATS.PositionMatrixX{MinIndex};           % Matrix per worm per frame                                                                                             Tracks(track_ind).PositionMatrixY(TrackFrameNum,:,:)                  = STATS.PositionMatrixY{MinIndex};           % Matrix per worm per frame                                                                                         else  % If no pattern was found due to midline problems                        Tracks(track_ind).PatternMatrix(TrackFrameNum,:,:)                    = zeros(MidlineCalculationParams.WormMatrixWidth, MidlineCalculationParams.WormMatrixLength,'single');  % Matrix per worm per frame                                                                                Tracks(track_ind).PatternMatrix_VignettingCorrected(TrackFrameNum,:,:)= zeros(MidlineCalculationParams.WormMatrixWidth, MidlineCalculationParams.WormMatrixLength,'single');  % Matrix per worm per frame                                                                                Tracks(track_ind).PositionMatrixX(TrackFrameNum,:,:)                  = zeros(MidlineCalculationParams.WormMatrixWidth, MidlineCalculationParams.WormMatrixLength,'single');  % Matrix per worm per frame                                                                                Tracks(track_ind).PositionMatrixY(TrackFrameNum,:,:)                  = zeros(MidlineCalculationParams.WormMatrixWidth, MidlineCalculationParams.WormMatrixLength,'single');  % Matrix per worm per frame                                                                            end                end                            else   % If midline was not calculated, at least store the basic 'skeleton' information.                Tracks(track_ind).WormSkeleton.Xcoordinate(TrackFrameNum)   = STATS.WormSkeleton.Xcoordinate(MinIndex);             % vector of indices per worm per frame                Tracks(track_ind).WormSkeleton.Ycoordinate(TrackFrameNum)   = STATS.WormSkeleton.Ycoordinate(MinIndex);             % vector of indices per worm per frame                Tracks(track_ind).WormSkeleton.LinearIndices(TrackFrameNum) = STATS.WormSkeleton.LinearIndices(MinIndex);           % vector of indices per worm per frame            end        end        WormCoordinates(MinIndex,:) = NaN;            else              % Current Track (track_ind) cannot be connected to any new worm object          Tracks(track_ind).Active = 0;                             % --> End of track                if length(Tracks(track_ind).Frames) < MinTrackLength      % Delete track if too short            Tracks(track_ind) = [];                                           ActiveTracks      = ActiveTracks - 1;     % Reduce indices stored in 'ActiveTracks' since the structure 'Tracks' was shrunk by one         end    endendreturnfunction Tracks = DefineNewTracks_Fluor (Tracks_in , WormCoordinates, STATS, Frame, AddProps, MidlineCalculationParams)Tracks         = Tracks_in;% The original loop... ASSIGNS NEW TRACKS ALSO FOR EXISTING TRACKS ??? (They will have NaNs in their coordinates and therefore will not be used in the next frame)   NumTracks      = length(Tracks);Worm_indices   = find(isfinite(WormCoordinates(:,1)))';   % Find worms which were not previously assigned to an existing track.  Original algorithm: 1:length(WormCoordinates(:,1));NumOfNewTracks = length(Worm_indices);Tracks_Indices = NumTracks + (1:NumOfNewTracks);for i = 1:NumOfNewTracks    worm_ind  = Worm_indices(i);    track_ind = Tracks_Indices(i);    Tracks(track_ind).Active            = 1;    Tracks(track_ind).Path              = single(WormCoordinates(worm_ind,:));    Tracks(track_ind).LastCoordinates   = single(WormCoordinates(worm_ind,:));    Tracks(track_ind).Frames            = single(Frame);    Tracks(track_ind).Size              = uint16(STATS.Area(worm_ind));    Tracks(track_ind).LastSize          = uint16(STATS.Area(worm_ind));    Tracks(track_ind).Eccentricity      = single(STATS.Eccentricity(worm_ind));    Tracks(track_ind).MajorAxes         = single(STATS.MajorAxisLength(worm_ind));    Tracks(track_ind).MinorAxes         = single(STATS.MinorAxisLength(worm_ind));    Tracks(track_ind).Orientation       = single(STATS.Orientation(worm_ind));    Tracks(track_ind).Box               = single(STATS.BoundingBox(worm_ind,:));    Tracks(track_ind).Frame(1).Image    = STATS.Image(worm_ind);    Tracks(track_ind).TrackLength       = single(1);        if AddProps        Tracks(track_ind).WormArea.Xcoordinate(1)        = STATS.WormArea.Xcoordinate(worm_ind);            % vector of coordinates per worm per frame        Tracks(track_ind).WormArea.Ycoordinate(1)        = STATS.WormArea.Ycoordinate(worm_ind);            % vector of coordinates per worm per frame                           Tracks(track_ind).WormArea.LinearIndices(1)      = STATS.WormArea.LinearIndices(worm_ind);          % vector of coordinates per worm per frame                           Tracks(track_ind).SkeletonLength                 = STATS.SkeletonLength(worm_ind);        Tracks(track_ind).PerimeterLength                = STATS.PerimeterLength(worm_ind);        Tracks(track_ind).WormPerimeter.Xcoordinate(1)   = STATS.WormPerimeter.Xcoordinate(worm_ind);       % vector of indices per worm per frame        Tracks(track_ind).WormPerimeter.Ycoordinate(1)   = STATS.WormPerimeter.Ycoordinate(worm_ind);       % vector of indices per worm per frame                       Tracks(track_ind).WormPerimeter.LinearIndices(1) = STATS.WormPerimeter.LinearIndices(worm_ind);     % vector of indices per worm per frame                       if AddProps >= 2                 Tracks(track_ind).PatternValues(1)                  = STATS.PatternValues(worm_ind);                    % vector per worm per frame                        Tracks(track_ind).Midline.X_coordinates_short(1)    = STATS.Midline.X_coordinates_short(worm_ind);      % vector per worm per frame            Tracks(track_ind).Midline.Y_coordinates_short(1)    = STATS.Midline.Y_coordinates_short(worm_ind);      % vector per worm per frame            Tracks(track_ind).Midline.LinearIndices(1)          = STATS.Midline.LinearIndices(worm_ind);            % vector per worm per frame            Tracks(track_ind).Midline.Pattern(1)                = STATS.Midline.Pattern(worm_ind);                  % vector per worm per frame            Tracks(track_ind).Midline.X_coordinates(1)          = STATS.Midline.X_coordinates(worm_ind);            % vector per worm per frame            Tracks(track_ind).Midline.Y_coordinates(1)          = STATS.Midline.Y_coordinates(worm_ind);            % vector per worm per frame            Tracks(track_ind).Midline.Angle(1)                  = STATS.Midline.Angle(worm_ind);                    % vector per worm per frame                        Tracks(track_ind).Midline.FlagTrueIfReliable        = STATS.Midline.FlagTrueIfReliable(worm_ind);       % one logical value per worm per frame                                         if isfield(STATS.Midline,'AngleFirstPoint')                Tracks(track_ind).Midline.AngleFirstPoint(1)        = STATS.Midline.AngleFirstPoint(worm_ind);          % vector per worm per frame                            Tracks(track_ind).Midline.AngleLastPoint(1)         = STATS.Midline.AngleLastPoint(worm_ind);           % vector per worm per frame                            Tracks(track_ind).Midline.NumOfBends_HighRes(1)     = STATS.Midline.NumOfBends_HighRes(worm_ind);       % vector per worm per frame                            Tracks(track_ind).Midline.NumOfBends_LowRes(1)      = STATS.Midline.NumOfBends_LowRes(worm_ind);        % vector per worm per frame                                             end            Tracks(track_ind).HeadTail(1,:,:)                   = squeeze(STATS.HeadTail(worm_ind,:,:));            % 2x2 matrix per worm per frame: first row=head, second is tail.                                    if AddProps == 3                Tracks(track_ind).WormCoordinates.Length(1)         = STATS.WormCoordinates.Length(worm_ind);           % vector per worm per frame                Tracks(track_ind).WormCoordinates.Width(1)          = STATS.WormCoordinates.Width(worm_ind);            % vector per worm per frame                      if Tracks(track_ind).Midline.FlagTrueIfReliable                                        Tracks(track_ind).PatternMatrix(1,:,:)                     = STATS.PatternMatrix{worm_ind};                   % Matrix per worm per frame                      Tracks(track_ind).PatternMatrix_VignettingCorrected(1,:,:) = STATS.PatternMatrix_VignettingCorrected{worm_ind};                   % Matrix per worm per frame                                                             Tracks(track_ind).PositionMatrixX(1,:,:)                   = STATS.PositionMatrixX{worm_ind};                   % Matrix per worm per frame                      Tracks(track_ind).PositionMatrixY(1,:,:)                   = STATS.PositionMatrixY{worm_ind};                   % Matrix per worm per frame                                      else  % If no pattern was found due to midline problems                    Tracks(track_ind).PatternMatrix(1,:,:)                     = zeros(MidlineCalculationParams.WormMatrixWidth, MidlineCalculationParams.WormMatrixLength,'single');  % Matrix per worm per frame                                                                        Tracks(track_ind).PatternMatrix_VignettingCorrected(1,:,:) = zeros(MidlineCalculationParams.WormMatrixWidth, MidlineCalculationParams.WormMatrixLength,'single');  % Matrix per worm per frame                                                                        Tracks(track_ind).PositionMatrixX(1,:,:)                   = zeros(MidlineCalculationParams.WormMatrixWidth, MidlineCalculationParams.WormMatrixLength,'single');  % Matrix per worm per frame                                                                        Tracks(track_ind).PositionMatrixY(1,:,:)                   = zeros(MidlineCalculationParams.WormMatrixWidth, MidlineCalculationParams.WormMatrixLength,'single');  % Matrix per worm per frame                                                                    end            end                                else   % If midline was not calculated, at least store the basic 'skeleton' information.                           Tracks(track_ind).WormSkeleton.Xcoordinate(1)    = STATS.WormSkeleton.Xcoordinate(worm_ind);        % vector of indices per worm per frame            Tracks(track_ind).WormSkeleton.Ycoordinate(1)    = STATS.WormSkeleton.Ycoordinate(worm_ind);        % vector of indices per worm per frame            Tracks(track_ind).WormSkeleton.LinearIndices(1)  = STATS.WormSkeleton.LinearIndices(worm_ind);      % vector of indices per worm per frame        end    endendreturnfunction break_now = ProgressDisplay_and_Memory (Frame, Mov, MovieName, Tracks, CurrentSettings, FragmentFrames, Fragment, ...                         PlotFrameRate, FigHandle, TempFolder, MAX_PerFrame_Calculation_Time, PlotHeadVsTail, MarkerSizeForDisplay, frame_index)  % Inputs in second line are loaded from TrackingVariables_SL.mat  break_now        = false;TotalNumOfFrames = diff(FragmentFrames(Fragment,:));% Allow time window for user to evaluate segmentationForceShowingFigure = false;ForceClosingFigure = false;if (frame_index == 3) && (TotalNumOfFrames< PlotFrameRate)   % Force showing first figure of segmentation if PlotFrameRate is too large    ForceShowingFigure = true;    endif (frame_index == 30) && (TotalNumOfFrames< PlotFrameRate)  % Force closing first after 30 frames if PlotFrameRate is too large    ForceClosingFigure = true;    end             if ForceClosingFigure     close;end% Display every PlotFrameRate'th frameif ForceShowingFigure || (~mod(frame_index, PlotFrameRate))               t1         = toc; tic;    fps        = PlotFrameRate/t1;    [~,NAME,~]    = fileparts(MovieName);    FigureName    = ['Movie name: ',NAME, ' - Frame ', num2str(Frame)];    threshold     = CurrentSettings(2);      AnimalPix     = CurrentSettings(3);      NumOfAnimals  = CurrentSettings(4);          if ForceShowingFigure        fps = 3/t1;        fprintf('\nFrame: %d , Calculation time: %.3g fps (%.2f sec/%d frames), threshold: %.5f, Mean animal size: %d pixels, Number of animals: %d \n',Frame,fps,t1,3, threshold,AnimalPix, NumOfAnimals)    else        fprintf('\nFrame: %d , Calculation time: %.3g fps (%.2f sec/%d frames), threshold: %.5f, Mean animal size: %d pixels, Number of animals: %d \n',Frame,fps,t1,PlotFrameRate, threshold,AnimalPix, NumOfAnimals)        fprintf('\n')    end    EstimateTimeLeft = ((diff(FragmentFrames(Fragment,:)) - frame_index)/fps)/60;  % in minutes    disp([num2str(EstimateTimeLeft),' minutes left'])        % Figure    figure(FigHandle); set(FigHandle, 'name', FigureName)    imshow(uint16(Mov),[]);    hold on;    if ~isempty(Tracks)        ActiveTracks = find([Tracks.Active]);    else        ActiveTracks = [];    end    for i = 1:length(ActiveTracks)        figure(FigHandle)                if Frame == Tracks(ActiveTracks(i)).Frames(end)                        plot(Tracks(ActiveTracks(i)).Path(:,1), Tracks(ActiveTracks(i)).Path(:,2), 'r');            plot(Tracks(ActiveTracks(i)).LastCoordinates(1), Tracks(ActiveTracks(i)).LastCoordinates(2), 'ro','markerfacecolor','r','markersize',MarkerSizeForDisplay);               plot(single(Tracks(ActiveTracks(i)).WormPerimeter.Ycoordinate{end}), single(Tracks(ActiveTracks(i)).WormPerimeter.Xcoordinate{end}), 'g.','markersize',2)            if isfield(Tracks,'Midline')                if Tracks(ActiveTracks(i)).Midline.FlagTrueIfReliable(end);                    PixelIndices.rows = Tracks(ActiveTracks(i)).Midline.X_coordinates{end};                    PixelIndices.cols = Tracks(ActiveTracks(i)).Midline.Y_coordinates{end};                               plot(PixelIndices.cols, PixelIndices.rows, 'b.','markersize',2)                end            end            if isfield(Tracks,'HeadTail')                if Tracks(ActiveTracks(i)).Midline.FlagTrueIfReliable(end);                    HeadCoordinates = squeeze(Tracks(ActiveTracks(i)).HeadTail(end,1,:));                    TailCoordinates = squeeze(Tracks(ActiveTracks(i)).HeadTail(end,2,:));                    plot(HeadCoordinates(2), HeadCoordinates(1), 'm*','markersize',MarkerSizeForDisplay)                    if PlotHeadVsTail                        plot(TailCoordinates(2), TailCoordinates(1), 'yo','markersize',MarkerSizeForDisplay)                    else                        plot(TailCoordinates(2), TailCoordinates(1), 'm*','markersize',MarkerSizeForDisplay)                    end                end            end        else  % Track is 'active' although object was not found in this frame            plot(Tracks(ActiveTracks(i)).Path(:,1), Tracks(ActiveTracks(i)).Path(:,2), 'r');            plot(Tracks(ActiveTracks(i)).LastCoordinates(1), Tracks(ActiveTracks(i)).LastCoordinates(2), 'cx','markersize',MarkerSizeForDisplay);         end                end    drawnow;        hold off;    % So not to see movie replay        % stop if it takes too long to analyze- probably an error    if (t1/PlotFrameRate) > MAX_PerFrame_Calculation_Time             disp(['Stopping script- too long: ', num2str(t1/PlotFrameRate)]);        break_now = true;        return    endend% Command window displayswitch mod(frame_index,5)     case 0, fprintf('-');     case 1, fprintf('\b\\');     case 2, fprintf('\b|');     case 3, fprintf('\b/');     case 4, fprintf('\b='); endif ~mod(frame_index,100)     % new line in workspace    fprintf('\n\n');      % progress file          PercentComplete = round(100*(Frame - FragmentFrames(Fragment,1)) / diff(FragmentFrames(Fragment,:)));        ProgFileName    = fullfile(TempFolder,['_F',int2str(Fragment)]);    delete([ProgFileName,'*']);    save([ProgFileName,'.',int2str(PercentComplete)],'PercentComplete');    endreturnfunction SaveAndUpdateStatus (File, Fragment, Settings, Tracks, background, AddProps, SaveOnlyOneFile_NoArenaSpecificFiles) load (File(1).TrackingVariablesFile);    % All relevant tracking parametersStatusFile       = File(1).StatusFile;FragmentSaveName = File.FragmentSaveNames{Fragment}; ExpData.PixelSize                       = File.PixelSize;ExpData.ArenaSize                       = File.ArenaSize;ExpData.FrameRate                       = FrameRate;ExpData.TrackTime                       = datestr(now);ExpData.TrackedFrames                   = File.FragmentFrames(Fragment,:);if exist('Settings','var')    ExpData.TrackStats.Settings         = Settings;      ExpData.TrackStats.NumWormsPerFrame = Settings(:,4);endExpData.TrackStats.MaxSpeedForTrackLinking_mm_sec = MaxSpeedForTrackLinking_mm_sec;ExpData.TrackStats.MaxRelativeSizeChange  = MaxRelativeSizeChange;ExpData.TrackStats.MinTrackLength         = MinTrackLength;if SaveOnlyOneFile_NoArenaSpecificFiles    % Save Fragment File    savesuccess = 0;    while ~savesuccess        if isfield(Tracks,'PositionMatrixX')            try                NumOfTracks = length(Tracks);                for tr=1:NumOfTracks                    PatternMatrix{tr}                     = Tracks(tr).PatternMatrix;                    PatternMatrix_VignettingCorrected{tr} = Tracks(tr).PatternMatrix_VignettingCorrected;                    PositionMatrixX{tr}                   = Tracks(tr).PositionMatrixX;                    PositionMatrixY{tr}                   = Tracks(tr).PositionMatrixY;                    PatternValues{tr}                     = Tracks(tr).PatternValues;                    WormCoordinates{tr}                   = Tracks(tr).WormCoordinates;                end                Tracks = rmfield(Tracks,{'PatternMatrix','PatternMatrix_VignettingCorrected','PositionMatrixX','PositionMatrixY','PatternValues','WormCoordinates'});                disp([datestr(now),' Saving Data for Movie ''',File.MovieName,''', fragment ',num2str(Fragment)]);                save(FragmentSaveName, 'Tracks', 'background', 'ExpData', 'File', 'Settings',...                        'PatternMatrix','PatternMatrix_VignettingCorrected','PositionMatrixX','PositionMatrixY','PatternValues','WormCoordinates', ...                         '-v7.3');                clear Tracks;                            disp([datestr(now),' *** Save complete *** ']);                savesuccess = 1;                      catch                            disp(' Error while saving... retrying');                lasterr                pause(10);            end        else            try                disp([datestr(now),' Saving Data for Movie ''',File.MovieName,''', fragment ',num2str(Fragment)]);                save(FragmentSaveName, 'Tracks', 'background', 'ExpData', 'File', 'Settings','-v7.3');                clear Tracks;                            disp([datestr(now),' *** Save complete *** ']);                savesuccess = 1;            catch                            disp(' Error while saving... retrying');                lasterr                pause(10);            end        end    end    else        %% Minimized Tracks structure, splitted by Arena ID.     % delete large memory variables and resuce Midline Angle 'sampling' to 50 dots per worm      Tracks_smallstruct =  rmfield(Tracks,'Frame');    MidlineVectorLength = (File.VariablesInformation.MidlineCalculationParams.WormMatrixLength-1);   % 500    Resolution          = 50;                                                                    % How many angle points (along the worm body) to store    MidlineIndices      = round( 1:((MidlineVectorLength-1)/(Resolution-1)) : MidlineVectorLength);     if AddProps >= 2        Tracks_smallstruct           = rmfield(Tracks_smallstruct,  {'PatternValues','WormArea'});           for tr_ind = 1:length(Tracks_smallstruct)            Tracks_smallstruct(tr_ind).Midline       = rmfield(Tracks_smallstruct(tr_ind).Midline,{'X_coordinates','Y_coordinates','LinearIndices','Pattern'} );                     Tracks_smallstruct(tr_ind).WormPerimeter = rmfield(Tracks_smallstruct(tr_ind).WormPerimeter,{'LinearIndices'} );                 end           for tr_ind = 1:length(Tracks_smallstruct)            ReliableMidlineFrames = Tracks_smallstruct(tr_ind).Midline.FlagTrueIfReliable;                    for frame_ind = find(ReliableMidlineFrames)                Tracks_smallstruct(tr_ind).Midline.Angle{frame_ind} = Tracks_smallstruct(tr_ind).Midline.Angle{frame_ind}(MidlineIndices);                        end            for frame_ind = find(~ReliableMidlineFrames)                Tracks_smallstruct(tr_ind).Midline.Angle{frame_ind}               = [];                            Tracks_smallstruct(tr_ind).Midline.X_coordinates_short{frame_ind} = [];                            Tracks_smallstruct(tr_ind).Midline.Y_coordinates_short{frame_ind} = [];                        end        end        end    if AddProps == 3        Tracks_smallstruct           = rmfield(Tracks_smallstruct,   'WormCoordinates');    end    % Save Fragment File    savesuccess = 0;    while ~savesuccess        try            disp([datestr(now),' Saving Data for Movie ''',File.MovieName,''', fragment ',num2str(Fragment)]);            save(FragmentSaveName, 'Tracks', 'background', 'ExpData', 'File', 'Tracks_smallstruct','Settings','-v7.3');            clear Tracks;            for ar = 1:File.NumArenas                Tracks    =  Tracks_smallstruct([Tracks_smallstruct.ArenaID]==ar);                save([FragmentSaveName(1:end-4),'_Arena',num2str(ar),'.mat'], 'Tracks', 'background', 'ExpData', 'File','Settings','-v7.3');             end            disp([datestr(now),' *** Save complete *** ']);            savesuccess = 1;        catch            disp(' Error while saving... retrying');            lasterr            pause(10);        end    endend% Update status fileloadsuccess = 0;while ~loadsuccess     try        load(StatusFile,'File');        loadsuccess = 1;    catch        disp('Error loading status file.  Retrying...');        pause(5);    endend File.CompletedFragments(Fragment) = 1;success = false;while ~success    try        save(StatusFile,'File','-append');        disp('*** Status file updated ***');        success = true;    catch        disp('error saving status file. Retrying in 10 seconds');        pause(10);    endend       return%% midline and pattern definition functionsfunction  [Midline, Head_Tail, PositionMatX, PositionMatY]  = ExtractPositionMatrix (Skeleton_LinearIndices, ImageSize, MidlineCalculationParams, AddProps)  %% Input-Output Examples:% Inputs:% WormMatrixLength    = 2000;     % The skeleton NEW length. For 5X movies the non-refined skeleton is around 210 pixels.% WormMatrixWidth     = 61;       % The NEW worm width. MUST BE AN ODD NUMBER TO INCLUDE ZERO !!!!! % WormRealWidth       = 16;       % Number of PIXELS from midline for definition of the worm profile. Better to over-estimate it. % InterpolationFactor = 0.05;     % for csaps spline function% PlotCalculatinFigures = false; % optional parameter. set 'true' for plotting calculation figures  % Outputs:% PositionMatX = X coordinate matrix of the worm profile. Values are NOT NATURAL numbers  % PositionMatX = Y coordinate matrix of the worm profile. Values are NOT NATURAL numbers  % Flag         = 'true' if the calculation is reliable, 'false' if not% THETA_ang    = midline normal angle. It's the Counterclockwise angular displacement from X coordinate (X coordinate  = Y axis in an ''imshow'' image). values between [0 180]   % Head_Tail    = Head and Tail coordinates. NOTE THAT THE HEAD AND TAIL MAY BE SWITCHED AT THIS POINT !!  This is corrected later using the correlation criteria % [x(start) y(start); x(end) y(end)]%% Initializing parametersFlag = true;InterpolationFactor          = MidlineCalculationParams.InterpolationFactor           ;  % for csaps spline function of midline X-Y coordinateInterpolationFactorBodyAngle = MidlineCalculationParams.InterpolationFactorBodyAngle  ;  % for csaps spline function of midline angles. More smoothed!PlotCalculationFigures       = MidlineCalculationParams.PlotCalculationFigures        ;  % optional parameter. set 'true' for plotting calculation figures  WormMatrixWidth              = MidlineCalculationParams.WormMatrixWidth               ; WormMatrixLength             = MidlineCalculationParams.WormMatrixLength              ;long_vec_Length              = WormMatrixLength;WormRealWidth                = MidlineCalculationParams.WormRealWidthInPixels         ;% Condition for plotting figuresplotfig = false;if exist('PlotCalculationFigures','var')    if PlotCalculationFigures        plotfig = true;    endend% Skeleton [X,Y] Indices% NOTE!!! In the Image: %         Increasing in Y axis is decreasing X coordinate        %         Increasing in X axis is increasing Y coordinate        [xx, yy] = ind2sub(ImageSize, Skeleton_LinearIndices);      % Check monotonicity !!!! Y_is_monotonic = isempty(find(abs(diff(yy))>1,1));X_is_monotonic = isempty(find(abs(diff(xx))>1,1));if ~X_is_monotonic || ~Y_is_monotonic    [xx, yy, Flag] = Resort_into_monotonic_Line_bwtraceboundary_v02 (Skeleton_LinearIndices, ImageSize, xx,yy, plotfig);endif length(xx)<3   % less than 3 pixels --> don't bother calculating midline ...    Midline.Flag                = false;     Midline.X_coordinates_short = [];     Midline.Y_coordinates_short = [];     Midline.LinearIndices       = [];     Midline.Pattern             = [];     Midline.X_coordinates       = [];     Midline.Y_coordinates       = [];     Midline.FlagTrueIfReliable  = false;            Head_Tail                   = single(zeros(2))*NaN;    if AddProps==3        Midline.Angle               = [];     end    returnend% Increasing the sampling rateDelta            = (length(xx)-1)/(long_vec_Length-1); long_vec         = 1 : Delta: length(xx);Width_vec        = (-0.5 : (1/(WormMatrixWidth-1)): 0.5) * WormRealWidth;     % This is the distance in pixels to BOTH DIRECTION, with Zero on the skeleton                                                                              % This paremetr is used to define the normals.  %% Csaps smoothing for each cooredinate individually pp          = csaps(1:length(xx),xx, InterpolationFactor); sm_xx       = fnval(pp,long_vec);sm_xx_short = fnval(pp,1:length(xx));pp          = csaps(1:length(yy),yy, InterpolationFactor); sm_yy       = fnval(pp,long_vec);sm_yy_short = fnval(pp,1:length(yy));if AddProps > 2   % donnot caluclate angles unless necessary for matrix pattern extraction%% Calculating the angle of the normals to the worms skeleton (using increased sampling rate)      THETA       = cart2pol(diff(sm_xx),diff(sm_yy));   % THETA is a counterclockwise angular displacement in radians from the positive x-axis    THETA       = [THETA(1) THETA];       % FIXING SINGULAR POINTS    THETA_PEAKS = find(abs(diff(THETA))> pi); % indices BEFORE the 2pi 'jump'    for p_ind = 1:length(THETA_PEAKS)        StartIndex = THETA_PEAKS(p_ind);            if THETA(StartIndex) < THETA(StartIndex+1) % Expect a sudden increase of 2*pi             THETA((StartIndex+1):end) =  THETA((StartIndex+1):end) - 2*pi;        else                                       % Expect a sudden deccrease of 2*pi             THETA((StartIndex+1):end) =  THETA((StartIndex+1):end) + 2*pi;        end    end    THETA_PEAKS_OK = isempty(find(abs(diff(THETA))> pi , 1, 'first')); % indices BEFORE the 2pi 'jump'    if ~ THETA_PEAKS_OK        disp('WARNING: singularities were found in angles calculation');        Flag = false;    end    THETA_ang_rad = THETA - 0.5*pi;  % Add 90 deg --> Angle is RELATIVE TO THE X AXIS !!!!    % ADDITIONAL SMOOTHING OF THE ANGLE VECTOR               pp       = csaps(long_vec, THETA_ang_rad, InterpolationFactorBodyAngle);     sm_angle = fnval(pp,long_vec);    % figure; plot(long_vec,THETA_ang_rad,'b.'); hold on; plot(long_vec,sm_angle,'r-'); hold on;     THETA_ang_rad = sm_angle;    %% Position matrix    DisplacementMatrices.X = zeros(WormMatrixWidth, WormMatrixLength);    DisplacementMatrices.Y = zeros(WormMatrixWidth, WormMatrixLength);    RHO                    = abs(Width_vec);    AddPiIndices           = sign(Width_vec)<0;       % Add pi to the angle if below midline    for normal_ind = 1: WormMatrixLength        angle_vec               = ones(1,WormMatrixWidth) * THETA_ang_rad(normal_ind);        angle_vec(AddPiIndices) = angle_vec(AddPiIndices) + pi;        [X,Y]                                = pol2cart(angle_vec,RHO);        DisplacementMatrices.X(:,normal_ind) = X;        DisplacementMatrices.Y(:,normal_ind) = Y;        end    % Create Position Matrix: Add midline (skeleton) values and displacements    PositionMatX = repmat(sm_xx,WormMatrixWidth,1) + DisplacementMatrices.X;    PositionMatY = repmat(sm_yy,WormMatrixWidth,1) + DisplacementMatrices.Y;    %% Angle Output    THETA_ang       = single(THETA_ang_rad/pi*180);    Midline.Angle   = single(THETA_ang + 90);   % 'THETA_ang' is the angle of the normal to the midline while 'Midline.Angle' is the body midline angle:                                                             % The angles in 'Midline.Angle' are defined as the COUNTERCLOCKWISE DISPLACEMENT FROM THE +X AXIS.                                                               %       [0 90 180 270] corresponds to [+X +Y -X -Y], respectively.  end%% Asign output variables% Head and tailsm_xx_edge = round(sm_xx([1 end]));sm_xx_edge(sm_xx_edge<1)=1;sm_xx_edge(sm_xx_edge>ImageSize(1))=ImageSize(1);sm_yy_edge = round(sm_yy([1 end]));sm_yy_edge(sm_yy_edge<1)=1;sm_yy_edge(sm_yy_edge>ImageSize(2))=ImageSize(2);Head_Tail = single([sm_xx_edge', sm_yy_edge']);     % [x(start) y(start); x(end) y(end)]% midline coordinates and flagMidline.X_coordinates       = single(sm_xx);Midline.Y_coordinates       = single(sm_yy);Midline.Flag                = Flag;Midline.X_coordinates_short = single(sm_xx_short);Midline.Y_coordinates_short = single(sm_yy_short);% midline linear indicessm_xx_short_for_ind                                     = round(sm_xx_short);sm_yy_short_for_ind                                     = round(sm_yy_short);sm_xx_short_for_ind(sm_xx_short_for_ind == 0)           = 1; sm_yy_short_for_ind(sm_yy_short_for_ind == 0)           = 1; sm_xx_short_for_ind(sm_xx_short_for_ind > ImageSize(1)) = ImageSize(1); sm_yy_short_for_ind(sm_yy_short_for_ind > ImageSize(2)) = ImageSize(2); Midline.LinearIndices                                   = single( sub2ind(ImageSize, sm_xx_short_for_ind, sm_yy_short_for_ind) );  %% PLOTSif plotfig    plot_all = 0;        if plot_all            SKEL_MAT = zeros(ImageSize);        SKEL_MAT(Skeleton_LinearIndices)=1;         figure; imshow(SKEL_MAT); hold on; plot(yy,xx,'b.')            figure; plot(1:length(xx),xx,'b.'); hold on; plot(1:length(xx),yy,'r.'); plot(long_vec,sm_xx,'b-'); plot(long_vec,sm_yy,'r-');                 xlabel('running index'); legend('x','y','sx','sy');        figure; plot(xx,yy,'b.'); hold on; plot(sm_xx,sm_yy,'r-'); xlabel('x'); ylabel('y');          if exist('THETA_ang_rad','var')                        figure; plot(THETA_ang_rad,'r'); title('Angle of skeleton Normals')                    ylabel(['Counterclockwise angular displacement from X coordinate]',char(10),'(X coordinate  = Y axis in an ''imshow'' image)']);                     xlabel('Index in Worm Matrix');        end                if exist('THETA_ang_rad','var')                        % Colormap Display of worm skeleton with normals on BigMatrix            load ('D:\MicroFluidics\Matlab_Temporary_Files\AutoFluorescence\MyColorMap.mat','MyRedGreenMap');            BigMat_X      = (1:Delta:ImageSize(1));            % THETA_MAT     = ones(length(BigMat_X),length(BigMat_X))*90;            THETA_MAT     = zeros(length(BigMat_X),length(BigMat_X));            sm_xx_index   = round(sm_xx*length(BigMat_X)/ImageSize(1));            sm_yy_index   = round(sm_yy*length(BigMat_X)/ImageSize(1));            THETA_MAT(sub2ind(size(THETA_MAT), sm_xx_index, sm_yy_index)) = THETA_ang;            figure; imagesc(THETA_MAT);             % colorbar; set(gca,'CLim',[0 180])            colorbar; set(gca,'CLim',[-90 90])            colormap(MyRedGreenMap); % colormap(redgreencmap)               end    else        figure; plot(xx,yy,'b.'); hold on; plot(sm_xx,sm_yy,'r-'); xlabel('x'); ylabel('y');          if exist('THETA_ang_rad','var')                       figure; plot(THETA_ang_rad,'r');                 if isempty(THETA_PEAKS)                    title('Angle of skeleton Normals');                else                    title('Angle of skeleton Normals - CORRECTED !!');                end                ylabel(['Counterclockwise angular displacement from X coordinate]',char(10),'(X coordinate  = Y axis in an ''imshow'' image)']);                 xlabel('Index in Worm Matrix Index');        end    end        endreturnfunction  Midline = CaluclateMidlineProperties(Midline, MidlineCalculationParams)  plotme = false;InterpolationFactorBodyAngle = MidlineCalculationParams.InterpolationFactorBodyAngle  ;  % for csaps spline function of midline angles. More smoothed!long_vec                     = 1 : (MidlineCalculationParams.WormMatrixLength-1)      ;NumOfWorms                   = length(Midline.Length);Midline.Angle                = cell(1,NumOfWorms);Midline.AngleFirstPoint      = single(zeros(1,NumOfWorms)*NaN);Midline.AngleLastPoint       = single(zeros(1,NumOfWorms)*NaN);Midline.NumOfBends_HighRes   = uint8(zeros(1,NumOfWorms));Midline.NumOfBends_LowRes    = uint8(zeros(1,NumOfWorms));for wi=1:NumOfWorms    if Midline.FlagTrueIfReliable(wi)        X = Midline.X_coordinates{wi};        Y = Midline.Y_coordinates{wi};                %% Calculating the angle of the normals to the worms skeleton (using increased sampling rate)          THETA       = cart2pol(diff(X),diff(Y));   % THETA is a counterclockwise angular displacement in radians from the positive x-axis        % FIXING SINGULAR POINTS        THETA_PEAKS = find(abs(diff(THETA))> pi); % indices BEFORE the 2pi 'jump'        for p_ind = 1:length(THETA_PEAKS)            StartIndex = THETA_PEAKS(p_ind);                if THETA(StartIndex) < THETA(StartIndex+1) % Expect a sudden increase of 2*pi                 THETA((StartIndex+1):end) =  THETA((StartIndex+1):end) - 2*pi;            else                                       % Expect a sudden deccrease of 2*pi                 THETA((StartIndex+1):end) =  THETA((StartIndex+1):end) + 2*pi;            end        end        THETA_PEAKS_OK = isempty(find(abs(diff(THETA))> pi , 1, 'first')); % indices BEFORE the 2pi 'jump'        if ~ THETA_PEAKS_OK            disp('WARNING: singularities were found in angles calculation');            Midline.FlagTrueIfReliable(wi)=false;            Flag=false        end        % ADDITIONAL SMOOTHING OF THE ANGLE VECTOR                pp                          = csaps(long_vec', double(THETA)', InterpolationFactorBodyAngle);         THETA_smoothed              = single(fnval(pp,long_vec));                        pp                          = csaps(long_vec', double(THETA)', InterpolationFactorBodyAngle/100);                                                      THETA_ForBendsCount_HighRes = single(fnval(pp,long_vec));                pp                          = csaps(long_vec', double(THETA)', InterpolationFactorBodyAngle/10000);                                                      THETA_ForBendsCount_LowRes  = single(fnval(pp,long_vec));       %         figure; plot(long_vec,THETA,'b.'); hold on; plot(long_vec,THETA_smoothed,'r:'); plot(long_vec,THETA_ForBendsCount_HighRes,'r-'); plot(long_vec,THETA_ForBendsCount_LowRes,'g-');                        %% Angle Output        % The angles in 'Midline.Angle' are defined as the COUNTERCLOCKWISE DISPLACEMENT FROM THE +X AXIS. i.e. [0 90 180 270] corresponds to [+X +Y -X -Y], respectively.          THETA_ang                     = THETA_smoothed/pi*180;        THETA_ang_ForBendCount_HighRes= THETA_ForBendsCount_HighRes/pi*180;        THETA_ang_ForBendCount_LowRes = THETA_ForBendsCount_LowRes/pi*180;        Midline.Angle{wi}             = single(THETA_ang);           Midline.AngleFirstPoint(wi)   = THETA_ang(1);          % The head direction is: 360- Midline.AngleFirstPoint        Midline.AngleLastPoint(wi)    = THETA_ang(end);        % The tail direction is:      Midline.AngleLastPoint                %% bending output:         %   one bend == the curvature of the body is always to the same direction            %   2 bends  == the curvature of the body swutches direction 1 time           %   3 bends  == the curvature of the body swutches direction 2 times           %   4 or more bends are NOT ALLOWED and considered as errors. Midline.FlagTrueIfReliable will be corrected appropriately.                     % HIGH RESOLUTION        THETA_RelativeToHead                = THETA_ang_ForBendCount_HighRes - THETA_ang_ForBendCount_HighRes(1);       % This is the angle relative to the head orientation;        CurvatureDirection                  = sign(diff(THETA_RelativeToHead));                         % (1) for counterclockwise, (-1) for clockwise.        CurvatureDirectionSwitchingPoints   = find(diff(CurvatureDirection)~=0);        NumOfBends                          = 1+length(CurvatureDirectionSwitchingPoints);              Midline.NumOfBends_HighRes(wi)      = NumOfBends;                    % LOW RESOLUTION        THETA_RelativeToHead                = THETA_ang_ForBendCount_LowRes - THETA_ang_ForBendCount_LowRes(1);       % This is the angle relative to the head orientation;        CurvatureDirection                  = sign(diff(THETA_RelativeToHead));                         % (1) for counterclockwise, (-1) for clockwise.        CurvatureDirectionSwitchingPoints   = find(diff(CurvatureDirection)~=0);        NumOfBends                          = 1+length(CurvatureDirectionSwitchingPoints);              Midline.NumOfBends_LowRes(wi)       = NumOfBends;                            if plotme            figure; plot(long_vec,THETA,'b.'); hold on; plot(long_vec,THETA_smoothed,'r:'); plot(long_vec,THETA_ForBendsCount_HighRes,'r-'); plot(long_vec,THETA_ForBendsCount_LowRes,'g-');             figure;             plot(X,Y,'r'); hold on; plot(X(1),Y(1),'r*')            title(['(',num2str(Midline.NumOfBends_LowRes(wi)),',',num2str(Midline.NumOfBends_HighRes(wi)), ') bends at (low/high) resolution.  First Angle= ',num2str(mod(360+Midline.AngleFirstPoint(wi),360)),'.  Last Angle= ',num2str(mod(360+Midline.AngleLastPoint(wi),360))]);            pause;              close; close;        end                end                                                      endfor wi=find(Midline.FlagTrueIfReliable==0)    Midline.Angle{wi}               = [];   endreturnfunction [xx_sorted, yy_sorted, Flag] = Resort_into_monotonic_Line_bwtraceboundary_v02 (Skeleton_LinearIndices, ImageSize, xx,yy, plotfig_in)InitialPointCorrection = false;Tolerance  = 1;    % Allow changes of up to 1 pixel between raw data midline and monotonic-detected midline  plotfig   = false;StopAtEnd = false;if exist('plotfig_in','var')    if plotfig_in        plotfig = true;    endendSKEL_MAT                        = false(ImageSize);SKEL_MAT(Skeleton_LinearIndices)= true; % FIRST guess: first [xx, yy] point.% Note that the first point that is always taken as the smallest yy point. trial = 1;InitialPoint                       = [xx(1) yy(1)]; [xx_sorted, yy_sorted, SameLength] = ResortMidlineCoordinates (SKEL_MAT, xx, yy, InitialPoint, Tolerance);% If there is an error in calculation (not same length), try to fix it for cases of bad guess of the initial point if ~SameLength     InitialPointCorrection = true;            % SECOND guess: Try the highest xx that is in the range if relatively small yy (Boundary function is going 'WEST')      trial = 2;    PossibleIndicesY = find(yy<=prctile(yy,50));  % == median    [~,I]            = max(xx(PossibleIndicesY));    InitialIndex     = PossibleIndicesY(I);    InitialPoint     = [xx(InitialIndex)  yy(InitialIndex)];     if isempty(InitialPoint)        disp('Script is stopped for debugging using ''keyboard'' at Resort_into_monotonic_Line_bwtraceboundary_v02');        keyboard;    end    [xx_sorted, yy_sorted, SameLength] = ResortMidlineCoordinates (SKEL_MAT, xx, yy, InitialPoint, Tolerance);    if ~SameLength         % THIRD guess: Try the highest xx in all yy range           trial = 3;        [~,InitialIndex] = max(xx);        InitialPoint     = [xx(InitialIndex)  yy(InitialIndex)];         [xx_sorted, yy_sorted, SameLength] = ResortMidlineCoordinates (SKEL_MAT, xx, yy, InitialPoint, Tolerance);                                    if ~SameLength             % FOURTH guess: Try the highest yy in all yy range               trial = 4;            [~,InitialIndex] = max(yy);            InitialPoint     = [xx(InitialIndex)  yy(InitialIndex)];             [xx_sorted, yy_sorted, SameLength] = ResortMidlineCoordinates (SKEL_MAT, xx, yy, InitialPoint, Tolerance);                % It is possible to try call my distance matrix algorithm as a fifth guess, if necessary.               if ~SameLength                 % FIFTH guess: Try the minimal yy in all yy range                   trial = 5;                [~,InitialIndex] = min(yy);                InitialPoint     = [xx(InitialIndex)  yy(InitialIndex)];                 [xx_sorted, yy_sorted, SameLength] = ResortMidlineCoordinates (SKEL_MAT, xx, yy, InitialPoint, Tolerance);                                              if ~SameLength                     % Sixth guess: Try the minimal xx in all yy range                       trial = 5;                    [~,InitialIndex] = min(xx);                    InitialPoint     = [xx(InitialIndex)  yy(InitialIndex)];                     [xx_sorted, yy_sorted, SameLength] = ResortMidlineCoordinates (SKEL_MAT, xx, yy, InitialPoint, Tolerance);                    end            end        end            endend% Flag the result: false= bad; true= good;Y_is_monotonic = isempty(find(abs(diff(yy_sorted))>1,1));X_is_monotonic = isempty(find(abs(diff(xx_sorted))>1,1));Flag           =  X_is_monotonic && Y_is_monotonic && SameLength;% Plotsif plotfig    figure; plot(xx,yy,'b*-'); hold on; plot(xx_sorted,yy_sorted,'r.:');     UniqueLength_sorted   = length(unique(xx_sorted + 1000*yy_sorted));    UniqueLength_unsorted = length(unique(xx        + 1000*yy));    title(['Worm length: new = ',num2str(UniqueLength_sorted),', old = ',num2str(UniqueLength_unsorted),...           ' . Flag = ',num2str(Flag),' . Correction = ',num2str(InitialPointCorrection),' . Trial = ',num2str(trial)]);endif StopAtEnd    pause(1);endreturnfunction [xx_sorted, yy_sorted, SameLength] = ResortMidlineCoordinates (SKEL_MAT, xx, yy, InitialPoint, Tolerance)try    B         = bwtraceboundary(SKEL_MAT, InitialPoint, 'W');  catch%     disp('Boundary direction switched: W to S');    B         = bwtraceboundary(SKEL_MAT, InitialPoint, 'S'); end    xx_sorted = B(1:ceil(end/2),1)';yy_sorted = B(1:ceil(end/2),2)';% Is the new vector the same length, or are we missing some elements?UniqueLength_sorted   = length(unique(xx_sorted + 1000*yy_sorted));UniqueLength_unsorted = length(unique(xx        + 1000*yy));SameLength            =   UniqueLength_sorted >= (UniqueLength_unsorted - Tolerance);     % Tolerance is the number of pixel of difference allowed.returnfunction [Tracks, TrackArena] = AssociateTracksToArenas (Tracks, File, PlotFigure) %% Input argumaents:% Tracks% File% PlotFigure        logical. optional (default = false). If true, figure will be plot showing the mean track position in a per-arena color code  % %% Output argumanets:% Tracks            - now it includes arena ID and vectors indicating for each track and frame whether the centroid is "IN BOUND"  % TrackArena        A vector of length(tracks) that specify the arena in which the track was detected  % NOTE: Here I assume that each track is within a single arena. NO OVERLAPPING ARENAS!   %% For each track, find the arena for which at least point in the track is within its defined borders.%  All tracks will be assigned an arenas ID, except of tracks for which all points are out-of-bound of all arenas.   if ~exist('PlotFigure','var')    PlotFigure = false;endNumArenas             = File.NumArenas;TrackBoxAxis          = File.TrackBoxAxis;        % Arenas are FULLY IMBEDDED within the TrackBoxAxis    InBoundBoxAxis        = File.InBoundBoxAxis;      % In bound areas corresponding to each arena.  InBoundBoxAxis <= TrackBoxAxis.TrackArena            = zeros(1,length(Tracks));  % arena number per track indexfor tr = 1:length(Tracks)           % run over all frames    TrackCoordinates = Tracks(tr).Path;        for ar = 1: NumArenas        InArena = inpolygon(TrackCoordinates(:,1), TrackCoordinates(:,2), TrackBoxAxis(ar,1:2), TrackBoxAxis(ar,3:4));        if find(InArena,1)         % At least one point was found inside the arena boundaries            TrackArena(tr)     = ar;            Tracks(tr).ArenaID = ar;            InBound                = inpolygon(TrackCoordinates(:,1), TrackCoordinates(:,2), InBoundBoxAxis(ar,1:2), InBoundBoxAxis(ar,3:4));   % Frames with the centroid located inside the "IN BOUND" box            Tracks(tr).OutOfBounds = ~InBound';            break        end    end             endTracksToDelete        = find(TrackArena==0);   % These are tracks that were not found within any arena and will therefore be deletedTrackArena            = TrackArena(TrackArena~=0);Tracks(TracksToDelete)=[];%% Optional Tracks position Figureif PlotFigure     XY_Coordinates = cell(1,NumArenas);    Indices       = zeros(1,NumArenas);    for tr = 1:length(Tracks) %   OutOfBoundTracks      % Undefined_Tracks        X       = mean(Tracks(tr).Path(:,1));        Y       = mean(Tracks(tr).Path(:,2));        ArenaID = TrackArena(tr);        Indices(ArenaID) = Indices(ArenaID)+1;        XY_Coordinates{ArenaID}(Indices(ArenaID),1:2) = [X Y];     end    figure;    COLORCODE = {'r','b','g','k'};    for ar = 1:NumArenas               plot(XY_Coordinates{ar}(:,1),XY_Coordinates{ar}(:,2),'*','color',COLORCODE{ar}); hold on;    endendreturn%% Currently unused but important functionsfunction BW_Matrix = Create_BW_Matrix_from_images(Worm_PROPS, OriginalFrameSize)    BW_Matrix = false (OriginalFrameSize);for wi = 1:length(Worm_PROPS.Area)    UpperLeft_Coordinate_Dim2 = Worm_PROPS.BoundingBox(wi,1)-0.5;      UpperLeft_Coordinate_Dim1 = Worm_PROPS.BoundingBox(wi,2)-0.5;      IM = Worm_PROPS.Image{wi};          % Full worm BW image    [I,J]         = find(IM==1);          Coordinates   = [J + UpperLeft_Coordinate_Dim2, I + UpperLeft_Coordinate_Dim1]; % Matrix of [x y] locations of the skeleton ?? CHECK IT     linearInd     = sub2ind(OriginalFrameSize, Coordinates(:,2), Coordinates(:,1));    BW_Matrix (linearInd) = true;endfigure; imagesc(BW_Matrix);returnfunction BW_Matrix = Create_BW_Matrix_from_PixelsList(Worm_PROPS, OriginalFrameSize, PixelsField, ObjectIndices)    BW_Matrix = false (OriginalFrameSize);if ~exist('PixelsField','var')    PixelsField = 'PixelIdxList';   % Worms area. Other options: Skeleton_PixelIdxList , HeadTail_PixelIdxListendPixelsCell = Worm_PROPS.(PixelsField);if ~exist('ObjectIndices','var')    ObjectIndices = 1:length(PixelsCell);   % Worms areaendPixelsCell = PixelsCell(ObjectIndices);if ~ strcmpi(PixelsField,'HeadTail_PixelIdxList')    for wi = 1:length(PixelsCell)        BW_Matrix (PixelsCell{wi}) = true;    endelse    All_indices = Worm_PROPS.HeadTail_PixelIdxList(ObjectIndices,:);    BW_Matrix(All_indices(:)) = true;    endfigure; imagesc(BW_Matrix);returnfunction Plot_PixelList_on_Frame(Worm_PROPS, OriginalFrameSize, PixelsField, ObjectIndices, COLOR)    if ~exist('COLOR','var')    COLOR   = 'r';endLINESTYLE   = 'none'; % for PixelIdxList and HeadTail_PixelIdxListMARKER      = '.';    % for PixelIdxListif ~exist('PixelsField','var')    PixelsField = 'PixelIdxList';          % Worms area elseif strcmpi(PixelsField,'Skeleton_PixelIdxList') || strcmpi(PixelsField,'Perimeter_PixelIdxList')%     LINESTYLE   = '-';    %     MARKER      = 'none';   elseif strcmpi(PixelsField,'HeadTail_PixelIdxList')    MARKER      = '*';  endPixelsCell = Worm_PROPS.(PixelsField);if ~exist('ObjectIndices','var') || isempty(ObjectIndices)    ObjectIndices = 1:length(PixelsCell);   % Worms areaendPixelsCell = PixelsCell(ObjectIndices);if ~ strcmpi(PixelsField,'HeadTail_PixelIdxList')    for wi = 1:length(PixelsCell)        [I,J] = ind2sub(OriginalFrameSize,PixelsCell{wi});        hold on;        plot(J,I,'color',COLOR,'marker',MARKER,'linestyle',LINESTYLE,'markersize',5);     endelse    All_indices = Worm_PROPS.HeadTail_PixelIdxList(ObjectIndices,:);    [I,J] = ind2sub(OriginalFrameSize,All_indices);    hold on;    plot(J,I,'color',COLOR,'marker',MARKER,'linestyle',LINESTYLE,'markersize',10); endreturn
function [File, All_Files] = MultiWormTracker_HighThroughputDevices_SL(AllFiles_ForDyeTracking)%% This function uses the following EXTERNAL FUNCTION: %       (1) SegmentationSettings_HighThroughputDevice_v02  >> Behavior segmentation parameters, matches high-throughput microfluidic device worms' behaviors   %       (2) FragmentTracker_SL_ScreeningSetup_v10          >> Tracks animal objects and extract their properies in one movie fragment %       (3) StitchFiles_MultipleSessions_v02               >> Concatenates all animal Tracks in one arena  %       (4) SegmentBehavior_HighThroughputDevice_02        >> Segments animal behavior on one arena %       (5) FragmentTrackDye_02                            >> track dye pattern in one movie fragment %%   September 2018, Sagi Levy%%%% Initialization:  Define Constants & Initialize variables and Tracker function name. Information saved in TrackingVariables_SL.mat in TempFolder TrackingVariablesFile = Initialize_Tracking_Variables_SB1_6Hz_20170501;  % Timing matches experiment 1        TrackingVariablesFile = Initialize_Tracking_Variables_SB1_6Hz_20170504;  % Timing matches experiment 2   load (TrackingVariablesFile,'TempFolder','check_status_interval','TrackerFunctionName','StatusFile','GenerateSingleWormMovie','Background_params');  warning('off','MATLAB:load:variableNotFound')SortFileNames.Sort  = false;  try load (TrackingVariablesFile,'SortFileNames');  end % If variable exist --> sort the filenames to fit real frame timing using pre-defined identifiersavi_format          = false;  try load (TrackingVariablesFile,'avi_format');     end % If variable exist and true --> The full movie is a set of '.avi' movies.  If false, The full movie is assumed to be a 'tif' or 'multi-tif' format.warning('on','MATLAB:load:variableNotFound')                                                      %%   Check for existing files that are still not analyzed.[FinishPreviousTrackingSession, All_Files] = Check_incomplete_tracking_files (TempFolder);  % 0= new movie, 1= uncompleted fragements analysis, 2= unstitched fragementsif exist('AllFiles_ForDyeTracking','var')    All_Files = AllFiles_ForDyeTracking;    FinishPreviousTrackingSession = 1;end    %% In case of a NEW movie (not yet analyzed)- get movie parameters manuallyif ~FinishPreviousTrackingSession       clear All_Files;    [FileNum, Name] = GetFileNames(SortFileNames, avi_format);    % Get User Input for each movie    for MovieNum = 1:FileNum        CurrentFile         = GetUserInput (Name(MovieNum), TrackingVariablesFile);    % User interface + additional manual variables        All_Files(MovieNum) = CurrentFile;    end    save(StatusFile,'All_Files');end%% Track all movies for which the tracking is not yet finished MoviesCompletionStatus = [All_Files.Stitched];for MovieNum = find(~MoviesCompletionStatus)        File = All_Files(MovieNum);   % The 'File' structure contains data for a single movie    disp([datestr(now), '  Starting movie number ',num2str(MovieNum),' -- ', File.MovieName]);        % Avoid re-analyzing completed fragements. If it's the first uncompleted movie- use the 'File' variable from the StatusFile (inprogress.mat)     if FinishPreviousTrackingSession && (MovieNum==find(~MoviesCompletionStatus,1))         load(StatusFile,'File');        if ~strcmp(File.MoviePath, All_Files(MovieNum).MoviePath)       % If names doesn't match (shouldn't happen...) reanalyze the fragements.            disp('filenames mismatch... ');            File = All_Files(MovieNum);           end    else        save(File.StatusFile,'File','All_Files');        % Calculate background and save variable, if it wasn't previously done            if ~Background_params.UseOnlyFramesInFragement      % Do not calculate background if the user prefers to re-calculated background independently for each movie fragment (useful for fluctuating background)               [~, File] = getbackground_v05(File, Background_params);                    All_Files(MovieNum).BackgroundFile = File.BackgroundFile;        end            end         % Initiate the FragmentTracker function for each fragmented movie file    if ~File.Stitched                % Movie names and make directory for analysis files         [TrackName, FragmentSaveNames, File, All_Files] =  MovieNames_MakeDir (File, All_Files, MovieNum);               % Initiate the FragmentTracker function for each fragmented movie file        load (TrackingVariablesFile,'num_processors','max_processors');        InitiateFragmentTracker (File, All_Files, MovieNum, TrackerFunctionName, num_processors, max_processors)    % 'File' and 'All_Files' are also saved here        % Status Monitoring - Show status window and waits until all fregments analysis is done.           StatusMonitoring (TempFolder, check_status_interval, File, MovieNum, length(MoviesCompletionStatus));              % Stitch animal tracks         File = SafeStitch_BasedOnLocation_MultiSession(File);        % Save status file        disp([datestr(now), '  Finished movie number ',num2str(MovieNum),' -- ', File.MovieName]);        All_Files(MovieNum) = File;        save(File.StatusFile,'File','All_Files');    end        FinishPreviousTrackingSession = false;    % Next movie in the loop is not analyzed yet    end   disp([datestr(now), '  Finished tracking all movies']);%% Segment Behavior for all movies for which the segmentation is not yet finished disp([datestr(now), '  Initiating behavior segmentation']);MoviesCompletionStatus = [All_Files.BehaviorSegmented];for MovieNum = find(~MoviesCompletionStatus)        File                             = All_Files(MovieNum);           BehaviorSegmentationFunctionName = File.VariablesInformation.BehaviorSegmentationFunctionName;        load (TrackingVariablesFile,'num_processors','max_processors');        All_Files = InitiateBehaviorSegmentation (File, All_Files, MovieNum, BehaviorSegmentationFunctionName, num_processors, max_processors);    % 'File' and 'All_Files' are also saved here         end   disp([datestr(now), '  Finished behavior segmentation for all movies']);%% Track dye, if neededif isfield(All_Files(1).VariablesInformation,'TrackDyeFunction')    disp([datestr(now), '  Initiating dye tracker']);    MoviesCompletionStatus = false(1,length(All_Files));        for MovieNum = find(~MoviesCompletionStatus)            File = All_Files(MovieNum);            TrackDyeFunction         = File.VariablesInformation.TrackDyeFunction;        DyePatternsTimeWindow    = File.VariablesInformation.TimeOfInterest.DyePatterns;  % Time window for dye patterns analysis, in MINUTES        load (TrackingVariablesFile,'num_processors','max_processors');            TrackDye = true;        if isfield(File,'DyeCompletedFragments')            if all(File.DyeCompletedFragments)                TrackDye = false;            end        end        if TrackDye                    File = InitiateDyeTracker (File, All_Files, MovieNum, TrackDyeFunction, num_processors, max_processors, DyePatternsTimeWindow);    % 'File' and 'All_Files' are also saved here                 end        StitchDyePatterns_pulses(File);    end                  disp([datestr(now), '  Finished dye analysis for all movies']);else    disp([datestr(now), '  Skipping dye tracking']);endreturn%% Tracking variable files function TrackingVariablesFile = Initialize_Tracking_Variables_SB1_6Hz_20170501 %% This function define Constants & Initialize variables for the tracker%  The following parmeters should be optimized based on computer performance: max_processors, DefaultFragmentLength      %% Which tracker to use, how to define arenas and pixelsize and which worm data neet to be colllectedUserInterfaceMode.UseFirstFrameInsteadOfBackground = true;     % If true --> skip the background calculationn and the user interface is done on the first frame. Much faster for Long/high resolution movies.UserInterfaceMode.AutoDefine_Image_as_OneArena     = false;     % If true --> skip the arenas location definitions. The whole image will be considered as one arena (number 1).UserInterfaceMode.DefineOutOfBoundPolygons         = true;TrackerFunctionName               = ';FragmentTracker_SL_ScreeningSetup_v10(Fragment);';   BehaviorSegmentationFunctionName  = ';SegmentBehavior_HighThroughputDevice_02(File,ArenaID);';   GradientAnalysisFunctionName      = '';   TrackDyeFunction                  = ';FragmentTrackDye_02(Fragment);';   % DetectionMode = 'Minimal';                          % Minimal features are calculated and stored, such as centroid, eccentricity and area of each worm.% DetectionMode = 'AddBasicMorphologyProperties';     % Adding basic morphological features such as skeleton and perimeter. The skeleton is not corrected for possible bugs. DetectionMode = 'AddAdvancedMorphologyProperties';    % Adding also advanced morphological features such as exact midline caluclation, Head and tail, and gray scale pattern in regular coordinates. %                                                       optional: head vs. tail based on gray scale along the midline.% DetectionMode = 'AddAllProperties';                 % Adding also gray scale pattern of the worm in the worms' coordinate system. This can be used for Worm barcoding.  %% Which type of movie files is it? File names definition.%%%%%%%%%%%%%%%%   For the screening setup    %%%%%%%%%%%%%%%    single or multiple 'avi' files are generated. Each avi file contain a subset of the full experiment movie.  avi_format = true;%%%%%%%%%%%%%%%%   For small arenas in the imaging scope    %%%%%%%%%%%%%%% There are two format types: %    (1) Separate tif files for each frame  (e.g. 'Experiment4_t10001.TIF', 'Experiment4_t10002.TIF'...  )%    (2) One multiple-tif file which consists of all frames.% For (1), seperate tif files, make sure that the files are SORTED. Use SortFileNames below. % % Sort file names:  % If variable exist --> sort the filenames to fit real frame timing using pre-defined identifiers% % SortFileNames.Sort    = false;% SortFileNames.Sort      = true;% SortFileNames.BeforeTimeString = '_t';        % example: for file name such as 'Experiment4_t10001.TIF' representing the 10001 frame --> Use '_t'   % SortFileNames.AfterTimeString  = '.TIF';      % example: for file name such as 'Experiment4_t10001.TIF' representing the 10001 frame --> Use '.TIF'   %%%%%%%%%%%%%%%%   Files names definition    %%%%%%%%%%%%%%TempFolder            = 'C:\Matlab_Temporary_Files';     % Another option is to use the Matlabroot work folder:   TempFolder = fullfile(matlabroot,'work');StatusFile            = fullfile(TempFolder,'inprogress.mat');TrackingVariablesFile = fullfile(TempFolder,'TrackingVariables_SL.mat');%% Movie and device information %%%%%%%%%%%%%%%%   Arena size  %%%%%%%%%%%%%%%%arena        = 30.56;   % mm. SB1 pulse device dimensions:ScalingTitle = 'Pick scaling points. (1) end of inlet barriers. (2) start of outlet barriers';   %%%%%%%%%%%%%%%%  Temporal resolution  %%%%%%%%%%%%%%%%FrameRate    = 6;     % Frame rate (Hz)%%%%%%%%%%%%%%%%  Frames of interest for worm tracking, background calculation and for dye patterns calculation  %%%%%%%%%%%%%%%%% Default: all frames of the movie are used for background and for worm tracking, and no dye patterns are calculated. %          If default parameters are needed comment the commands below (until Tracker Behavior section). % For SHORT Memory ExperimentTimeOfInterest.WormTracking             = [0 73];   % minutesTimeOfInterest.BackgroundCalculation    = [0 73];   % minutesTimeOfInterest.DyePatterns              = [73 108]; % minutesTimeOfInterest.OnlyDye                  = [73 80];  % minutesFramesOfInterest.WormTracking           = round(FrameRate*60* TimeOfInterest.WormTracking);FramesOfInterest.BackgroundCalculation  = round(FrameRate*60* TimeOfInterest.BackgroundCalculation);FramesOfInterest.DyePatterns            = round(FrameRate*60* TimeOfInterest.DyePatterns);FramesOfInterest.OnlyDye                = round(FrameRate*60* TimeOfInterest.OnlyDye);if FramesOfInterest.WormTracking(1)==0,           FramesOfInterest.WormTracking(1)=1;           endif FramesOfInterest.BackgroundCalculation(1)==0,  FramesOfInterest.BackgroundCalculation(1)=1;  endif FramesOfInterest.DyePatterns(1)==0,            FramesOfInterest.DyePatterns(1)=1;            endif FramesOfInterest.OnlyDye(1)==0,                FramesOfInterest.OnlyDye(1)=1;            end%% Tracker behavior, display and CPU usage%%%%%%%%%%%%%%%%      For tracker     %%%%%%%%%%%%%%%%QuitMatlabWhenFinished        = true;PlotFrameRate                 = 60;    % Display tracking results every 'PlotFrameRate' framesMAX_PerFrame_Calculation_Time = 100;  % Maximum allowed average calculation time per-frame [sec]. If more than that: script will stop.  %%%%%%%%%%%%%%%%   For 'Spawn' function    %%%%%%%%%%%%%%DefaultFragmentLength   = 4000; % framesmax_processors          = 6;    % For object detection: hard-drive access and memory is limiting. The sctipt slows down if too many processors are used.max_processors_ID       = 5;    % For ID tracker: CPU is time is limiting and not memory or hard-drive access. The sctipt can use more CPU power in parallel.num_processors          = str2num(getenv('NUMBER_OF_PROCESSORS'));comp_name               = getenv('COMPUTERNAME');check_status_interval   = 30; %seconds%%%%%%%%%%%%%%%%   Set screen info  %%%%%%%%%%%%%%%%FigHandle = 1; %% Worms detection parameters: worm size, number, error accepted, background calculation and auto-threshold calculations %%%%%%%%%%%%%%%%     Worm size and number      %%%%%%%%%%%%%%%%MinWorm_size          = 0.04; % Defined in mm^2    MaxWorm_size          = 0.09; % Defined in mm^2    (0.09 is big but works ... )%%%%%%%%%%%%%%%%     Movie Background      %%%%%%%%%%%%%%% Background_params.method        = 'median';Background_params.method        = 'mean';    % mean is good enough for brightfield imagesBackground_params.FrameInterval = 200;Background_params.save          = false;Background_params.plot          = false;Background_params.UseOnlyFramesInFragement = false;  % When false --> All frames in the movie are used for background calculation                                                     % When true  --> Only frames within the current movie fragment are used for background calculation. Corrrected for short last fragements...   if exist('FramesOfInterest','var')                                                         if isfield(FramesOfInterest,'BackgroundCalculation')        Background_params.StartFrame = FramesOfInterest.BackgroundCalculation(1);        Background_params.EndFrame   = FramesOfInterest.BackgroundCalculation(2);            endend        %%%%%%%%%%%%%%%%    Here we use constant-, rather than auto-, threshold algorithm    %%%%%%%%%%%%%%AutoThreshold_params.ForceOneRealObject         = false;          % if true, force Single WormAutoThreshold_params.UseConstantThreshold_value = 0.1;            %  Threshold value when MANUAL mode is ON. FLUORESCENCE_STREL      = strel('disk',1);                    FLUORESCENCE_STREL_OPEN = ones(1);                             %%%%%%%%%%%%%%%%       Midline and worm matrix calculations    %%%%%%%%%%%%%%MidlineCalculationParams.ScalingFactor                  = 10;    % The midline will be oversampled by this factor in order to increase accuracy of transformation to worms coordinates;MidlineCalculationParams.InterpolationFactor            = 5e-2;  % for csaps spline function of midline X-Y coordinateMidlineCalculationParams.InterpolationFactorBodyAngle   = 5e-4;  % for csaps spline function of midline angles. More smoothed!MidlineCalculationParams.PlotCalculationFigures         = false;  % optional parameter. set 'true' for plotting calculation figures  MidlineCalculationParams.WormMatrixWidth                = 35  ; MidlineCalculationParams.WormMatrixLength               = 500 ;MidlineCalculationParams.WormRealWidth                  = 70;    % estimation with overshoot,  micro-meters% This are the relative distances from the midline edges that will be used to quantify midline gray scale and use it for head vs. tail segmentation. %   e.g. [0.055 0.11] --> look at a distance of between 5.5% to 11% of the midline length, from each edge. What are the grey scale values there?   MidlineCalculationParams.DistanceAlongMidline_ForHeadvsTail = [0.055 0.11];    MidlineCalculationParams.MaximumDeviationFromMedianLength   = 20;           % Maximum deviation allowed (in [%]) from the median midline lengths that was found in all worms within the arena.                                                                            % This is used to flag out all Midlines that were 'too short' due to error in morphology calculations.  %% Parameters for tracks linkingMaxSpeedForTrackLinking_mm_sec = 1.5;  % max allowed speed (mm/sec) for connecting a new worm object to an existing track (without IDing).                                        % This is converted to pixels per frame within the function.                                        % NOTE THAT THIS IS A VERY HIGH TOLERANCE SINCE POSSIBLE MULTIPLE POSSIBLE LINKING IS WELL MONITORED!!  MaxRelativeSizeChange = 50;            % [%] Maximal Relative size changed for connecting a new worm object to an existing track (without IDing).                                        %   max change between two consecutive frames: (current_area-previous_area)/previous_area <  (MaxRelativeSizeChange/100)                                       MinTrackLength        = 2;             % Min Length of a valid track (in FRAMES)                               MaxTimeForLinkingBasedOnLocation1   = 0.3;       % seconds. FOR LINKING BASED ON LOCOMOTION. ABOVE THAT ALLOW LINKAGE ONLY BY ID. % first link 'close' tracks (frame-wise) MaxTimeForLinkingBasedOnLocation2   = 1;         % seconds. FOR LINKING BASED ON LOCOMOTION. ABOVE THAT ALLOW LINKAGE ONLY BY ID. % then allow 'far' tracks%% Behavior segmentation settingsSegmentationSettings = SegmentationSettings_HighThroughputDevice_v02;SegmentationSettings.AllowVeryLongTracks = true;%% save (TrackingVariablesFile);pause (6);         % Make sure the mat file is saved before continuing the program. returnfunction TrackingVariablesFile = Initialize_Tracking_Variables_SB1_6Hz_20170504  %% This function define Constants & Initialize variables for the tracker%  The following parmeters should be optimized based on computer performance: max_processors, DefaultFragmentLength      %% Which tracker to use, how to define arenas and pixelsize and which worm data neet to be colllectedUserInterfaceMode.UseFirstFrameInsteadOfBackground = true;     % If true --> skip the background calculationn and the user interface is done on the first frame. Much faster for Long/high resolution movies.UserInterfaceMode.AutoDefine_Image_as_OneArena     = false;     % If true --> skip the arenas location definitions. The whole image will be considered as one arena (number 1).UserInterfaceMode.DefineOutOfBoundPolygons         = true;TrackerFunctionName               = ';FragmentTracker_SL_ScreeningSetup_v10(Fragment);';   BehaviorSegmentationFunctionName  = ';SegmentBehavior_HighThroughputDevice_02(File,ArenaID);';   GradientAnalysisFunctionName      = '';   TrackDyeFunction                  = ';FragmentTrackDye_02(Fragment);';   % DetectionMode = 'Minimal';                          % Minimal features are calculated and stored, such as centroid, eccentricity and area of each worm.% DetectionMode = 'AddBasicMorphologyProperties';     % Adding basic morphological features such as skeleton and perimeter. The skeleton is not corrected for possible bugs. DetectionMode = 'AddAdvancedMorphologyProperties';  % Adding also advanced morphological features such as exact midline caluclation, Head and tail, and gray scale pattern in regular coordinates. %                                                       optional: head vs. tail based on gray scale along the midline.% DetectionMode = 'AddAllProperties';                 % Adding also gray scale pattern of the worm in the worms' coordinate system. This can be used for Worm barcoding.  %% Which type of movie files is it? File names definition.%%%%%%%%%%%%%%%%   For the screening setup    %%%%%%%%%%%%%%%    single or multiple 'avi' files are generated. Each avi file contain a subset of the full experiment movie.  avi_format = true;%%%%%%%%%%%%%%%%   For small arenas in the imaging scope    %%%%%%%%%%%%%%% There are two format types: %    (1) Separate tif files for each frame  (e.g. 'Experiment4_t10001.TIF', 'Experiment4_t10002.TIF'...  )%    (2) One multiple-tif file which consists of all frames.% For (1), seperate tif files, make sure that the files are SORTED. Use SortFileNames below. % % Sort file names:  % If variable exist --> sort the filenames to fit real frame timing using pre-defined identifiers% % SortFileNames.Sort      = false;% SortFileNames.Sort      = true;% SortFileNames.BeforeTimeString = '_t';        % example: for file name such as 'Experiment4_t10001.TIF' representing the 10001 frame --> Use '_t'   % SortFileNames.AfterTimeString  = '.TIF';      % example: for file name such as 'Experiment4_t10001.TIF' representing the 10001 frame --> Use '.TIF'   %%%%%%%%%%%%%%%%   Files names definition    %%%%%%%%%%%%%%TempFolder            = 'C:\Matlab_Temporary_Files';     % Another option is to use the Matlabroot work folder:   TempFolder = fullfile(matlabroot,'work');StatusFile            = fullfile(TempFolder,'inprogress.mat');TrackingVariablesFile = fullfile(TempFolder,'TrackingVariables_SL.mat');%% Movie and device information %%%%%%%%%%%%%%%%   Arena size  %%%%%%%%%%%%%%%%arena         = 30.56;   % mm. SB1 pulse device dimensions:ScalingTitle  = 'Pick scaling points. (1) end of inlet barriers. (2) start of outlet barriers';  %%%%%%%%%%%%%%%%  Temporal resolution  %%%%%%%%%%%%%%%%FrameRate     = 6;     % Frame rate (Hz)%%%%%%%%%%%%%%%%  Frames of interest for worm tracking, background calculation and for dye patterns calculation  %%%%%%%%%%%%%%%%% Default: all frames of the movie are used for background and for worm tracking, and no dye patterns are calculated. %          If default parameters are needed comment the commands below (until Tracker Behavior section). % For SHORT Memory ExperimentTimeOfInterest.WormTracking             = [0 69];   % minutesTimeOfInterest.BackgroundCalculation    = [0 69];   % minutesTimeOfInterest.DyePatterns              = [69 104]; % minutesTimeOfInterest.OnlyDye                  = [69 76];  % minutesFramesOfInterest.WormTracking           = round(FrameRate*60* TimeOfInterest.WormTracking);FramesOfInterest.BackgroundCalculation  = round(FrameRate*60* TimeOfInterest.BackgroundCalculation);FramesOfInterest.DyePatterns            = round(FrameRate*60* TimeOfInterest.DyePatterns);FramesOfInterest.OnlyDye                = round(FrameRate*60* TimeOfInterest.OnlyDye);if FramesOfInterest.WormTracking(1)==0,           FramesOfInterest.WormTracking(1)=1;           endif FramesOfInterest.BackgroundCalculation(1)==0,  FramesOfInterest.BackgroundCalculation(1)=1;  endif FramesOfInterest.DyePatterns(1)==0,            FramesOfInterest.DyePatterns(1)=1;            endif FramesOfInterest.OnlyDye(1)==0,                FramesOfInterest.OnlyDye(1)=1;            end%% Tracker behavior, display and CPU usage%%%%%%%%%%%%%%%%      For tracker     %%%%%%%%%%%%%%%%QuitMatlabWhenFinished  = true;PlotFrameRate         = 60;    % Display tracking results every 'PlotFrameRate' framesMAX_PerFrame_Calculation_Time = 100;  % Maximum allowed average calculation time per-frame [sec]. If more than that: script will stop.  %%%%%%%%%%%%%%%%   For 'Spawn' function    %%%%%%%%%%%%%%DefaultFragmentLength   = 4000; % framesmax_processors          = 6; % For object detection: hard-drive access and memory is limiting. The sctipt slows down if too many processors are used.max_processors_ID       = 5; % For ID tracker: CPU is time is limiting and not memory or hard-drive access. The sctipt can use more CPU power in parallel.num_processors          = str2num(getenv('NUMBER_OF_PROCESSORS'));comp_name               = getenv('COMPUTERNAME');check_status_interval   = 30; %seconds%%%%%%%%%%%%%%%%   Set screen info  %%%%%%%%%%%%%%%%FigHandle = 1; %% Worms detection parameters: worm size, number, error accepted, background calculation and auto-threshold calculations %%%%%%%%%%%%%%%%     Worm size and number      %%%%%%%%%%%%%%%%MinWorm_size          = 0.04; % Defined in mm^2    MaxWorm_size          = 0.09; % Defined in mm^2    (0.09 is big but works ... )%%%%%%%%%%%%%%%%     Movie Background      %%%%%%%%%%%%%%% Background_params.method        = 'median';Background_params.method        = 'mean';    % mean is good enough for brightfield imagesBackground_params.FrameInterval = 200;Background_params.save          = false;Background_params.plot          = false;Background_params.UseOnlyFramesInFragement = false;  % When false --> All frames in the movie are used for background calculation                                                     % When true  --> Only frames within the current movie fragment are used for background calculation. Corrrected for short last fragements...   if exist('FramesOfInterest','var')                                                         if isfield(FramesOfInterest,'BackgroundCalculation')        Background_params.StartFrame = FramesOfInterest.BackgroundCalculation(1);        Background_params.EndFrame   = FramesOfInterest.BackgroundCalculation(2);            endend        %%%%%%%%%%%%%%%%    Here we use constant-, rather than auto-, threshold algorithm    %%%%%%%%%%%%%%AutoThreshold_params.ForceOneRealObject         = false;          % if true, force Single WormAutoThreshold_params.UseConstantThreshold_value = 0.1;            %  Threshold value when MANUAL mode is ON. FLUORESCENCE_STREL      = strel('disk',1);                    FLUORESCENCE_STREL_OPEN = ones(1);                             %%%%%%%%%%%%%%%%       Midline and worm matrix calculations    %%%%%%%%%%%%%%MidlineCalculationParams.ScalingFactor                  = 10;    % The midline will be oversampled by this factor in order to increase accuracy of transformation to worms coordinates;MidlineCalculationParams.InterpolationFactor            = 5e-2;  % for csaps spline function of midline X-Y coordinateMidlineCalculationParams.InterpolationFactorBodyAngle   = 5e-4;  % for csaps spline function of midline angles. More smoothed!MidlineCalculationParams.PlotCalculationFigures         = false;  % optional parameter. set 'true' for plotting calculation figures  MidlineCalculationParams.WormMatrixWidth                = 35  ; MidlineCalculationParams.WormMatrixLength               = 500 ;MidlineCalculationParams.WormRealWidth                  = 70;    % estimation with overshoot,  micro-meters% This are the relative distances from the midline edges that will be used to quantify midline gray scale and use it for head vs. tail segmentation. %   e.g. [0.055 0.11] --> look at a distance of between 5.5% to 11% of the midline length, from each edge. What are the grey scale values there?   MidlineCalculationParams.DistanceAlongMidline_ForHeadvsTail = [0.055 0.11];    MidlineCalculationParams.MaximumDeviationFromMedianLength   = 20;           % Maximum deviation allowed (in [%]) from the median midline lengths that was found in all worms within the arena.                                                                            % This is used to flag out all Midlines that were 'too short' due to error in morphology calculations.  %% Parameters for tracks linkingMaxSpeedForTrackLinking_mm_sec = 1.5;  % max allowed speed (mm/sec) for connecting a new worm object to an existing track (without IDing).                                        % This is converted to pixels per frame within the function.                                        % NOTE THAT THIS IS A VERY HIGH TOLERANCE SINCE POSSIBLE MULTIPLE POSSIBLE LINKING IS WELL MONITORED!!  MaxRelativeSizeChange = 50;            % [%] Maximal Relative size changed for connecting a new worm object to an existing track (without IDing).                                        %   max change between two consecutive frames: (current_area-previous_area)/previous_area <  (MaxRelativeSizeChange/100)                                       MinTrackLength        = 2;             % Min Length of a valid track (in FRAMES)                               MaxTimeForLinkingBasedOnLocation1   = 0.3;       % seconds. FOR LINKING BASED ON LOCOMOTION. ABOVE THAT ALLOW LINKAGE ONLY BY ID. % first link 'close' tracks (frame-wise) MaxTimeForLinkingBasedOnLocation2   = 1;         % seconds. FOR LINKING BASED ON LOCOMOTION. ABOVE THAT ALLOW LINKAGE ONLY BY ID. % then allow 'far' tracks%% Behavior segmentation settingsSegmentationSettings = SegmentationSettings_HighThroughputDevice_v02;SegmentationSettings.AllowVeryLongTracks = true;%% save (TrackingVariablesFile);pause (6);         % Make sure the mat file is saved before continuing the program. return%% User interface files and file/directory generationfunction [FinishPreviousTrackingSession, All_Files] = Check_incomplete_tracking_files (TempFolder)%---------------------------------------%  Check for incomplete tracking files%---------------------------------------FinishPreviousTrackingSession = 0;StatusFile = fullfile(TempFolder,'inprogress.mat');delete(fullfile(TempFolder,'_F*')); % temporary files to monitor progressif exist(StatusFile,'file')==2    load(StatusFile);               if exist('All_Files','var') && ~all([All_Files.BehaviorSegmented])   % Uncompleted fragments        FinishPreviousTrackingSession = 1;        MoviesCompletionStatus = [All_Files.BehaviorSegmented];        Num_UnfinishedMovies   = length(find(~MoviesCompletionStatus));        Num_Movies             = length(MoviesCompletionStatus);         disp(['*** Unfinished jobs found: ,',num2str(Num_UnfinishedMovies),'/',num2str(Num_Movies),' movies']);                    else        All_Files = [];    endelse    All_Files = [];endreturnfunction [FileNum, Name] = GetFileNames (SortFileNames, avi_format)   if SortFileNames.Sort     BeforeTimeString = SortFileNames.BeforeTimeString;   % example: for file name such as 'Experiment4_t10001.TIF' representing the 10001 frame --> Use '_t'       AfterTimeString  = SortFileNames.AfterTimeString;    % example: for file name such as 'Experiment4_t10001.TIF' representing the 10001 frame --> Use '.TIF'   endFileNum = str2num(cell2mat(inputdlg('How many movies do you want to track?')));if FileNum>1    button = questdlg({'Select a parent directory that contains all relevant movies directories?','NOTE: ALL sub-directories will be considered as pathes for movies'},'','Yes','No','No');     if strcmpi(button,'Yes')        UserPrompt     = 'Select a parent directory that contains all relevant movies directories';        ParentPathName = uigetdir('', UserPrompt);        AllMoviesNames = dir(ParentPathName);        AllMoviesNames = {AllMoviesNames(3:end).name};        FileNum        = length(AllMoviesNames);    endendfor MovieNum = 1:FileNum    if ~exist('AllMoviesNames','var')        UserPrompt = ['Select Directory with Files For Analysis of Movie #' num2str(MovieNum)];        PathName   = uigetdir('', UserPrompt);    else        PathName = [ParentPathName,'\',AllMoviesNames{MovieNum}];    end       index = strfind(PathName,'\');     index = index(end)+1;    Name(MovieNum).MoviePath  = PathName;    Name(MovieNum).MovieName  = PathName(index:end);        cd (PathName);      ALLFILES = dir;    ALLFILES = ALLFILES(3:end);  % exclude the '.' and '..'    Name(MovieNum).FileNames  = {ALLFILES.name};        Name(MovieNum).TrackFile  = [Name(MovieNum).MoviePath, '\',  Name(MovieNum).MovieName, '.mat'];            if avi_format           % Keep Only '.avi'        C           = strfind(Name(MovieNum).FileNames,'.avi');                 AviFile_TF  = false(1,length(C));            for file_ind = 1:length(C)            AviFile_TF(file_ind) = ~ isempty(C{file_ind});         end                    TrueFiles = AviFile_TF;            else                            % Keep Only '.tif' or '.TIF' files !!!!!        C           = strfind(Name(MovieNum).FileNames,'.tif');                 TiffFile_TF = false(1,length(C));            for file_ind = 1:length(C)            TiffFile_TF(file_ind) = ~ isempty(C{file_ind});         end            if isempty(find(TiffFile_TF,1))            C       = strfind(Name(MovieNum).FileNames,'.TIF');             for file_ind = 1:length(C)                TiffFile_TF(file_ind) = ~ isempty(C{file_ind});             end        end        TrueFiles = TiffFile_TF;    end        Name(MovieNum).FileNames = Name(MovieNum).FileNames(TrueFiles);        if SortFileNames.Sort                FileNames = Name(MovieNum).FileNames;                C_after   = strfind(Name(MovieNum).FileNames,AfterTimeString);         C_before  = strfind(Name(MovieNum).FileNames,BeforeTimeString);                last_ind  = cell2mat(C_after)-1;        first_ind = cell2mat(C_before)+length(BeforeTimeString);                Time = zeros(1,length(FileNames));        for file_ind = 1:length(FileNames)            Time(file_ind) = str2num(FileNames{file_ind}(first_ind(file_ind):last_ind(file_ind)));        end        [~, Sorted_indices] = sort(Time);        FileNames = FileNames(Sorted_indices);        Name(MovieNum).FileNames =  FileNames;        endendcd ..returnfunction File = GetUserInput (Name, TrackingVariablesFile)load (TrackingVariablesFile);  % All additional manual data -- INCLUDING 'avi_format' !!!!!!!!!AutoDefine_Image_as_OneArena    = false;     % If true --> skip the arenas location definitions. The whole image will be considered as one arena (number 1).AutoDefine_PixelSize            = false;     % If true --> skip the pixel size definition. The pixel size MUST BE PRE-DEFINED in this field: 'PixelSize'. UseFirstFrameInsteadOfBackground = false;    % If true --> skip the background calculationn and the user interface is done on the first frame. Much faster for Long/high resolution movies.DefineOutOfBoundPolygons        = false;     % If true --> define additional locations within the arenas that are considered out-of-bound for behavior segmentation                                             % Necessary of SLG7 gradient devices   if exist('UserInterfaceMode','var')    if isfield(UserInterfaceMode,'UseFirstFrameInsteadOfBackground')                UseFirstFrameInsteadOfBackground = UserInterfaceMode.UseFirstFrameInsteadOfBackground;     end            if isfield(UserInterfaceMode,'AutoDefine_Image_as_OneArena')                AutoDefine_Image_as_OneArena = UserInterfaceMode.AutoDefine_Image_as_OneArena;    end     if isfield(UserInterfaceMode,'DefineOutOfBoundPolygons')                DefineOutOfBoundPolygons = UserInterfaceMode.DefineOutOfBoundPolygons;    end     if isfield(UserInterfaceMode,'AutoDefine_PixelSize')                if UserInterfaceMode.AutoDefine_PixelSize            AutoDefine_PixelSize        = UserInterfaceMode.AutoDefine_PixelSize;  % If true --> skip the pixel size definition. The pixel size MUST BE PRE-DEFINED in this field: 'PixelSize'.             PixelSize_AutoDefinedValue  = UserInterfaceMode.PixelSize ;            % Pixel size. UNITS = pixel per mm        end    endendif ~exist('ScalingTitle','var')    ScalingTitle='';end% Get User Input for a single movie frameif ~ avi_format    if length(Name.FileNames)>1        MovieFirstFrame         = fullfile(Name.MoviePath, Name.FileNames{2});  % use second frame for arena definitions due to camera error in the first frame of some movies (bug in the imaging scope)    else        MovieFirstFrame         = fullfile(Name.MoviePath, Name.FileNames{1});  % First frame = first tiff    endendShortMovieName          = Name.MovieName;TrackSettingsName       = fullfile(Name.MoviePath,[ShortMovieName,'_TrackSettings.mat']);CollectTrackingSettings = true;%% Try to use existing tracking settingsif exist(TrackSettingsName) == 2    ButtonName = questdlg('Use existing tracking settings?','','Yes', 'No', 'Yes');    if strcmp(ButtonName,'Yes')        try            load(TrackSettingsName,'FileSettings');            File = FileSettings;            % check filenames            disp('Filenames are not checked !!!!');            if strcmp (Name.MoviePath, File.MoviePath) % if there is a match between the name of the chosen file and the name in the setting file                                CollectTrackingSettings = false;            else                disp('Filenames don''t match... reselect manually.');            end            if ~isfield(File,'ClaimedFragments') || isempty(File.ClaimedFragments)                File.ClaimedFragments = File.CompletedFragments;  % redo all fragment that were not completed in previous run            end        catch            disp('Error loading settings.  Select manually...');        end    endend%% Manual settings collectionif CollectTrackingSettings    % Assign Movie names to File    File.MoviePath      = Name.MoviePath;    File.MovieFileNames = Name.FileNames;        %% Find whether the file format is a MULTIPLE_TIFF file         if avi_format   %%%%%   avi format    %%%%%                    if length(Name.FileNames)==1    % The full movie is a SINGLE .avi movie            File.VideoFormat  = 'avi';            File.MovieName    = [File.MoviePath,'\',File.MovieFileNames{1}];            MovieObj          = VideoReader(File.MovieName);            FrameNum          = MovieObj.Duration * MovieObj.FrameRate;  % duration of movie display * FrameRate of movie display = number of frames. THIS IS NOT THE REAL TIME AND TEMPORAL RESOLUTION !                               else                            % The full movie is a SEQUENCE of short .avi movies                        File.VideoFormat  = 'multi-avi';                                    File.MovieName    = Name.MovieName;            % Cell array of avi movies            FramesPerAviFile  = zeros(1,length(File.MovieFileNames));                                    disp('Reading files and assigning movie parameters');            NextFirstFrame = 1;            for file_ind = 1:length(File.MovieFileNames)                                MovieObj                   = VideoReader([File.MoviePath,'\',File.MovieFileNames{file_ind}]);                NumOfFrames                = round(MovieObj.Duration * MovieObj.FrameRate);  % duration (of movie display) * FrameRate (of movie display) = number of frames. THIS IS NOT THE REAL TIME AND TEMPORAL RESOLUTION !                                         FramesPerAviFile(file_ind) = NumOfFrames;                NextFirstFrame             = NextFirstFrame + NumOfFrames;            end                                             FrameNum                = sum(FramesPerAviFile);    % This is the TOTAL number of frames in all avi files.                         File.FramesPerAviFile   = FramesPerAviFile;                        MultiAviFrameConversion.MovieFileNumber   = single(zeros(1,FrameNum));            MultiAviFrameConversion.FrameNumberInFile = single(zeros(1,FrameNum));            NextFirstFrame = 1;            CumSumFrames   = cumsum(FramesPerAviFile);            for file_ind = 1:length(File.MovieFileNames)                MultiAviFrameConversion.MovieFileNumber(NextFirstFrame:(CumSumFrames(file_ind)))   = file_ind;                MultiAviFrameConversion.FrameNumberInFile(NextFirstFrame:(CumSumFrames(file_ind))) = 1:FramesPerAviFile(file_ind);                NextFirstFrame = CumSumFrames(file_ind)+1;            end                    end         File.FrameSize               = [MovieObj.Height  MovieObj.Width];        File.MultiAviFrameConversion = MultiAviFrameConversion;    else           %%%%%   tif format    %%%%%                   info = imfinfo(MovieFirstFrame);            File.info_firstframe = info(1);        if length(info) > 1                     % ONE multiple-tiff file            File.VideoFormat        = 'multi-tiff';                        File.MovieName          = [File.MoviePath,'\',File.MovieFileNames{1}];            FrameNum                = length(info);        else                                    % SEQUENCE of tiff files            File.VideoFormat        = 'tiff';                       File.MovieName          = Name.MovieName;            FrameNum                = length(Name.FileNames);        end                 File.FrameSize              = [File.info_firstframe.Height  File.info_firstframe.Width];    end    File.NumberOfFramesInMovie_IncludingDyeAnalysis = FrameNum;   % All frames in the movie    File.NumberOfFrames                             = FrameNum;   % All frames that are going to be worm-tracked         if exist('FramesOfInterest','var')                                                             if isfield(FramesOfInterest,'WormTracking')            if FramesOfInterest.WormTracking(2) <= FrameNum                File.NumberOfFrames = FramesOfInterest.WormTracking(2);                disp(['Only the first ',num2str(File.NumberOfFrames),' frames are analyzed for worm behavior'])            else                disp(['Movie is truncated after ', num2str(File.NumberOfFrames),' frames. CHECK DEFINITIONS FOR FRAMES RELEVANT TO WORM TRACKING !!! '])            end        end        if isfield(FramesOfInterest,'DyePatterns')            File.DyePatternsFrames = FramesOfInterest.DyePatterns;            if File.DyePatternsFrames(2)>FrameNum                File.DyePatternsFrames(2)=FrameNum;            end            disp(['Frames [',num2str(File.DyePatternsFrames),'] are analyzed for dye patterns'])        end            end    FigHandle = figure(FigHandle);    figure(FigHandle);     set(FigHandle,'MenuBar','none','Toolbar','none','Position',[150 100 1020 900],'name',['Movie name: ',ShortMovieName]);    %%    if UseFirstFrameInsteadOfBackground        FileFullName   = [File.MoviePath,'\', File.MovieFileNames{1}];        if     strcmpi(File.VideoFormat,'multi-tiff')         % A single multiple-tiff file            MovFrame       = imread(FileFullName, 2);       % due to bug in imaging scope: read the second frame        elseif strcmpi(File.VideoFormat,'tiff')               % A sequence of tiff files            MovFrame       = imread(FileFullName);                     elseif strcmpi(File.VideoFormat,'avi')||strcmpi(File.VideoFormat,'multi-avi')            % A single avi movie file or A sequence of avi movie files                        MovieObj       = VideoReader(FileFullName);            MovFrame       = read(MovieObj, 1);               end                     else        background = getbackground_v04(File, Background_params);        MovFrame   = background;    end    figure(FigHandle);     imshow(MovFrame,[]);                       %   imshow(background,[400 700]);               %% --------get information----------    buttony = 10;    MovSize = File.FrameSize;    FrameStart = 1;    NumFragments = max(ceil(File.NumberOfFrames/DefaultFragmentLength),1);          uicontrol('Style','text','Position',[110 buttony 170 20],'String','Frames for worm tracking');    h2a = uicontrol('style','edit','Position',[270 buttony 50 20],'String',num2str(FrameStart));    h2  = uicontrol('style','edit','Position',[320 buttony 50 20],'String',num2str(File.NumberOfFrames));    h2b = uicontrol('style','edit','Position',[380 buttony 20 20],'String',num2str(NumFragments));          uicontrol('Style','text','Position',[500 buttony 60 20],'String','Arena(mm)');    h4  = uicontrol('style','edit','Position',[560 buttony 40 20],'String',num2str(arena));          uicontrol('Style','text','Position',[640 buttony 60 20],'String','FrameRate');    h5  = uicontrol('style','edit','Position',[700 buttony 30 20],'String',num2str(FrameRate));        %% Get arena tracking regions    if AutoDefine_Image_as_OneArena        ar = 1;        File.Arena(ar).TrackBox = [1 1 MovSize(2) MovSize(1)];    else        ar = 0;        txt = 'SELECT TRACKING AREAS: click inside to confirm, outside to redo, Enter to end.';        title(txt);         label = text(MovSize(2)/2,MovSize(1)*0.4,txt,'FontSize',18,'HorizontalAlignment','center');        success = 0;         while success == 0            box = getrect(FigHandle); box = box+(box==0); h = rectangle('Position',box); set(h,'EdgeColor',[1,0,0]);            [X,Y,button] = ginput(1);             if isempty(button)                success = true;            elseif button == 1 && (X-box(1) >= 0 && X-box(1) <= box(3) && Y-box(2) >= 0 && Y-box(2) <= box(4))                ar = ar+1; % arena #                File.Arena(ar).TrackBox = box+(box==0);                set(h,'EdgeColor',[0,0,1]);                 ht = text(box(1)+box(3)/2,box(2)+box(4)/2,num2str(ar)); set(ht,'FontSize',36,'Color',[0 0 1]);            end        end    end            %% assign information into 'File'    File.NumArenas            = ar;    File.ArenaSize            = str2num(get(h4,'String'));     File.TrackFile            = Name.TrackFile;    File.TempFolder           = TempFolder;    File.StatusFile           = StatusFile;    File.TrackingVariablesFile= TrackingVariablesFile;    File.TrackFrames          = str2num(get(h2,'String'));    File.StartFrame           = str2num(get(h2a,'String'));    File.ImageSize            = MovSize;    File.FrameRate            = str2num(get(h5,'String'));    File.Fragments            = str2num(get(h2b,'String'));    File.StartFragment        = 1;    File.CompletedFragments   = zeros(1,File.Fragments);    File.ClaimedFragments     = zeros(1,File.Fragments);    File.BehaviorSegmentation.ClaimedArenas   = false(1,ar);    File.BehaviorSegmentation.CompletedArenas = false(1,ar);    File.Stitched             = 0;    File.BehaviorSegmented    = 0;    %% get scale info . Assign into File       if AutoDefine_PixelSize        PixelSize  = PixelSize_AutoDefinedValue;    else               txt = ['GET SCALING: ',ScalingTitle,' = ',get(h4,'String'),'mm'];                imshow(imadjust(MovFrame,stretchlim(MovFrame,[0.01 0.9995])));                title(txt);  label = text(MovSize(2)/2,MovSize(1)*0.4,txt,'FontSize',18,'HorizontalAlignment','center');        [X,Y] = ginput(2);         arenapix  = sqrt((Y(2)-Y(1))^2+(X(2)-X(1))^2);         PixelSize = arenapix / File.ArenaSize;   % UNITS = pixel per mm    end    File.PixelSize            = PixelSize;                      % UNITS = pixel per mm           %% Fragement Frames information         hi              = File.TrackFrames;    lo              = File.StartFrame;    NumFragments    = File.Fragments;    perfrag         = ceil((hi-lo+1)/NumFragments);    frfr            = [lo+(0:(NumFragments-1))*perfrag]';    frfr            = [frfr, [frfr(2:NumFragments)-1; hi]];          File.FragmentFrames = frfr;    disp([datestr(now),' Image Data Collected for Movie: ',ShortMovieName]);    FileSettings = File;    save(TrackSettingsName,'FileSettings');else        % just get the movie frame    if UseFirstFrameInsteadOfBackground        FileFullName   = [File.MoviePath,'\', File.MovieFileNames{1}];        if     strcmpi(File.VideoFormat,'multi-tiff')         % A single multiple-tiff file            MovFrame       = imread(FileFullName, 2);       % due to bug in imaging scope: read the second frame        elseif strcmpi(File.VideoFormat,'tiff')               % A sequence of tiff files            MovFrame       = imread(FileFullName);                     elseif strcmpi(File.VideoFormat,'avi')||strcmpi(File.VideoFormat,'multi-avi')            % A single avi movie file or A sequence of avi movie files                        MovieObj       = VideoReader(FileFullName);            MovFrame       = read(MovieObj, 1);               end                     else        background = getbackground_v04(File, Background_params);        MovFrame   = background;    end    endFile.VariablesInformation = load (File.TrackingVariablesFile);% Define necessray filenames and fields        NumArenas     = File.NumArenas;File.FileNames.ConcatinatedTracks               = cell(1,NumArenas);File.FileNames.SafeStitchedTracks               = cell(1,NumArenas);File.FileNames.SegmentedTracks                  = cell(1,NumArenas);File.FileNames.SegmentedAndForcedStitchedTracks = cell(1,NumArenas);File.FileNames.DataMatrices                     = cell(1,NumArenas);File.FileNames.DataMatrices_ArenaDelayCorrected = cell(1,NumArenas);File.FileNames.DataMatrices_AllDelaysCorrected  = cell(1,NumArenas);File.NumberOfTracks                             = zeros(1,NumArenas);for ar = 1:NumArenas                 File.FileNames.ConcatinatedTracks{ar}               = [File.TrackFile(1:end-4),'_Concatinated_NotStitched_Arena',num2str(ar),'.mat'];    File.FileNames.SafeStitchedTracks{ar}               = [File.TrackFile(1:end-4),'_SafeStitchedTracks_Arena',num2str(ar),'.mat'];        File.FileNames.SegmentedTracks{ar}                  = [File.TrackFile(1:end-4),'_SegmentedTracks_Arena',num2str(ar),'.mat'];        File.FileNames.SegmentedAndForcedStitchedTracks{ar} = [File.TrackFile(1:end-4),'_SegmentedAndForcedStitchedTracks_Arena',num2str(ar),'.mat'];        File.FileNames.DataMatrices{ar}                     = [File.TrackFile(1:end-4),'_DataMatrices_Arena',num2str(ar),'.mat'];    File.FileNames.DataMatrices_ArenaDelayCorrected{ar} = [File.TrackFile(1:end-4),'_DataMatrices_ArenaDelayCorrected',num2str(ar),'.mat'];        File.FileNames.DataMatrices_AllDelaysCorrected{ar}  = [File.TrackFile(1:end-4),'_DataMatrices_AllDelaysCorrected',num2str(ar),'.mat'];    endif DefineOutOfBoundPolygons    File = DefineOutOfBoundsForBehaviorSegmentation(File, MovFrame);endreturn function File = DefineOutOfBoundsForBehaviorSegmentation(File, MovFrame)if isfield(File,'OutOfBoundPolygons')    ButtonName = questdlg('Use existing Out-Of-Bound Polygons settings?','','Yes', 'No', 'Yes');    if strcmp(ButtonName,'Yes')        return    else        disp('redefining polygons');    end    endMovSize = File.FrameSize;figure; imshow(MovFrame,[]);for ar=1:File.NumArenas    h     = rectangle('Position',File.Arena(ar).TrackBox); set(h,'EdgeColor',[1,0,0]);        for polygon_number=1:2        if polygon_number==1            side = 'left';        else            side = 'right';        end        txt = ['Select ' side,' polygon area (arena ',num2str(ar),'). Enter to end.'];        title(txt);         txt = ['Select ' side,' polygon area (arena ',num2str(ar),...               ')',char(10),'This area is out of bound for behaviour segmentation. Enter to end.'];        label = text(MovSize(2)/2,MovSize(1)*0.4,txt,'FontSize',18,'HorizontalAlignment','center');        success = false;         while success == 0                    [X,Y,button] = ginput;             X = [X(1:end); X(1)];            Y = [Y(1:end); Y(1)];            line_handle(ar) = line(X,Y,'color','b');            txt = 'Click inside to confirm first polygon or outside to redefine it';            set(label,'String',txt);            [x,y]=ginput(1);            in = inpolygon(x,y,X,Y);            if in                success = true;                set(line_handle(ar),'color','r');                 File.OutOfBoundPolygons{ar,polygon_number} = [X,Y];                delete(label);            else                delete(line_handle(ar));                txt = ['Select ', side,' polygon area (arena ',num2str(ar),...                       ')',char(10),'This area is out of bound for behaviour segmentation. Enter to end.'];                set(label,'String',txt);            end        end    end    delete(h);       clear h line_handle        endreturnfunction [TrackName, FragmentSaveNames, File, All_Files] =  MovieNames_MakeDir (File_in, All_Files_in, MovieNum)File      = File_in;All_Files = All_Files_in;% Movie file and track namesTrackName               = File.TrackFile;[pathname,filename,ext] = fileparts(TrackName);partsfolder             = '\trackfile parts\';FragmentSaveNames       = cell(File.Fragments,1); for i = 1:File.Fragments;    FragmentSaveNames(i) = {[pathname,partsfolder,filename,'_part',num2str(i),ext]}; endfor a = 1:length(File.Arena)    TrackBox               = File.Arena(a).TrackBox;    File.TrackBox(a,:)     = TrackBox;    File.TrackBoxAxis(a,:) = [TrackBox(1)  TrackBox(1)+TrackBox(3)  TrackBox(2)  TrackBox(2)+TrackBox(4)];  endFile.FragmentSaveNames = FragmentSaveNames;% update All_FilesAll_Files(MovieNum).TrackBox          = File.TrackBox; All_Files(MovieNum).TrackBoxAxis      = File.TrackBoxAxis; All_Files(MovieNum).FragmentSaveNames = File.FragmentSaveNames; % make directory if it doesn't existsif ~exist([pathname,partsfolder],'dir')      mkdir([pathname,partsfolder]); endreturn %% Background calculation function [background, File] = getbackground_v05(File, Background_params)% This function:%   Calculate the background from the median/mean/or percentile pixel levels depending on the user preference.    %   Uses gray scale pictures rather than a single channel.%-----------------------------------------------------------------------DirName     = File.MoviePath;FileNames   = File.MovieFileNames;FrameNum    = File.NumberOfFrames;  % This is the total number of frames in the movie, NOT the number of frames that are analyzed for background calculationMATSIZE     = File.FrameSize;if isfield(Background_params,'method')          % mean or median over the frames?     method = Background_params.method;else    method = 'median';endtry         load(File.BackgroundFile, 'background');    disp(['background file was already calculated for ',File.MovieName,'. Skipping background calculation.', char(10)])    returncatch    disp(['Calculating background for ',File.MovieName,' using ''',method,''' approach', char(10)])    end        if isfield(Background_params,'FrameInterval')   % Usually 50 frames    FrameInterval = Background_params.FrameInterval;else    FrameInterval = 50;endif isfield(Background_params,'StartFrame')      % First frame     StartFrame = Background_params.StartFrame;else    StartFrame = 1;endif isfield(Background_params,'EndFrame')        % Last frame     EndFrame = Background_params.EndFrame;else    EndFrame = FrameNum;endif isfield(Background_params,'plot')            % plot background     plot_background = Background_params.plot;else    plot_background = false;endif isfield(Background_params,'UseGaussianFilter')   % Usually 50 frames    UseGaussianFilter = Background_params.UseGaussianFilter;    GaussianFilter    = fspecial('gaussian', Background_params.GaussianFilter.hsize, Background_params.GaussianFilter.sigma); else    UseGaussianFilter = false;endif UseGaussianFilter    disp('A Gaussian filter is applied to the movie frames and background');end% Assign Movie Format Codeif     strcmpi(File.VideoFormat,'tiff')    VideoFormat   = 1;elseif strcmpi(File.VideoFormat,'multi-tiff')    VideoFormat   = 2;    FileFullName  = [DirName,'\',FileNames{1}]; elseif strcmpi(File.VideoFormat,'avi')    VideoFormat   = 3;    FileFullName  = [DirName,'\',FileNames{1}];     MovieObj      = VideoReader(FileFullName);elseif strcmpi(File.VideoFormat,'multi-avi')    VideoFormat   = 4;    PreviousMovieObjFile = 0; % read new file object if and when it is needed else    disp('unknown format. aborting @ background calculation ...');    returnenddisp(['Background calculating from ',int2str(StartFrame),' to ',int2str(EndFrame),' in increments of ',int2str(FrameInterval)]);NumOfFrames = round((EndFrame-StartFrame+1)/FrameInterval);progbars    = 10;if strcmpi(method,'median') || strcmpi(method,'percentile_10')        MaxAllowedNumOfFrames   = 100;    if NumOfFrames > MaxAllowedNumOfFrames        FrameInterval = round((EndFrame-StartFrame+1) / MaxAllowedNumOfFrames);        NumOfFrames   = round((EndFrame-StartFrame+1)/FrameInterval);        disp(['To avoid large computation time, FrameInterval is enlarged to ',int2str(FrameInterval)]);    end        cdata_mat   = uint16(zeros(MATSIZE(1),MATSIZE(2),NumOfFrames));    ind         = 0;    for Frame = StartFrame:FrameInterval:EndFrame        ind = ind+1;        % Read frame, depending on the video format        if VideoFormat==2                       % A single multiple-tiff file            Mov                = imread(FileFullName, Frame);             elseif VideoFormat==1                   % A sequence of tiff files            FileFullName       = [DirName,'\',FileNames{Frame}];             Mov                = imread(FileFullName);                                  elseif VideoFormat==3                   % A single avi movie file            Mov                = read(MovieObj, Frame);                 Mov                = Mov(:,:,1);                %%%% assuming 3 channel movie !!        elseif VideoFormat==4                   % A sequence of avi movie files            CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);                        if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                FileFullName         = [DirName,'\',FileNames{CurrentMovieObjFile}];                 PreviousMovieObjFile = CurrentMovieObjFile;                MovieObj             = VideoReader(FileFullName);            end            CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);            Mov                      = read(MovieObj, CurrentFrameNumberInFile);                 Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!                        end                if UseGaussianFilter           Mov = imfilter(Mov,GaussianFilter);         end                % store frame data        cdata_mat(:,:,ind) = Mov;              if mod(Frame * progbars,(EndFrame-StartFrame+1)) < progbars*FrameInterval     % Progress bar- 10x ':'            fprintf(':');         end        end    cdata_mat = single(cdata_mat);        if UseGaussianFilter        cdata_mat = imfilter(cdata_mat,GaussianFilter);    end        fprintf('\nCalculating median\n');    cdatamean       = mean(cdata_mat,3);    background_mean = uint16(round(cdatamean));    cdatamedian       = median(cdata_mat,3);    background_median = uint16(round(cdatamedian));            if strcmpi(method,'median')         background = background_median;    elseif strcmpi(method,'percentile_10')        fprintf('\nCalculating percentile [10%] \n');        % prctile returns percentiles of the values in cdata along the 3rd dimention. p is a scalar or a vector of percent values.        p                     = 10;        cdata_percentile      = prctile(double(cdata_mat),p,3);                     background_percentile = uint16(round(cdata_percentile));        background            = background_percentile;    end           if plot_background        figure('name','background');         if strcmpi(method,'percentile_10')            subplot(1,3,1); h(1)=imshow(background_mean,[]);       title('mean');               subplot(1,3,2); h(2)=imshow(background_median,[]);     title('median');             subplot(1,3,3); h(3)=imshow(background_percentile,[]); title([num2str(p),' percent']);         else            subplot(1,2,1); h(1)=imshow(background_mean,[]);       title('mean');               subplot(1,2,2); h(2)=imshow(background_median,[]);     title('median');         end              end    else   % MEAN    if ~strcmpi(method,'mean')             disp('Background calculation method is not properly defined. Using mean...');    end        MaxAllowedNumOfFrames   = 400;    if NumOfFrames > MaxAllowedNumOfFrames        FrameInterval = round((EndFrame-StartFrame+1) / MaxAllowedNumOfFrames);        NumOfFrames   = round((EndFrame-StartFrame+1)/FrameInterval);        disp(['To avoid large computation time, FrameInterval is enlarged to ',int2str(FrameInterval)]);    end        cdata_mat = single(zeros(MATSIZE));    for Frame = StartFrame:FrameInterval:EndFrame         % Read frame, depending on the video format         if VideoFormat==2                       % A single multiple-tiff file            Mov                = imread(FileFullName, Frame);             elseif VideoFormat==1                   % A sequence of tiff files            FileFullName      = [DirName,'\',FileNames{Frame}];             Mov                = imread(FileFullName);                                  elseif VideoFormat==3                   % A single avi movie file            Mov                = read(MovieObj, Frame);                 Mov                = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!        elseif VideoFormat==4                   % A sequence of avi movie files            CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);            if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                FileFullName        = [DirName,'\',FileNames{CurrentMovieObjFile}];                 PreviousMovieObjFile = CurrentMovieObjFile;                MovieObj             = VideoReader(FileFullName);            end            CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);            Mov                      = read(MovieObj, CurrentFrameNumberInFile);                 Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                   end                if UseGaussianFilter           Mov = imfilter(Mov,GaussianFilter);         end                % Add to previous frames        cdata_mat     = cdata_mat + single(Mov);        if mod(Frame * progbars,(EndFrame-StartFrame+1)) < progbars*FrameInterval     % Progress bar- 10x ':'            fprintf(':');         end        end    if UseGaussianFilter        cdata_mat = imfilter(cdata_mat,GaussianFilter);    end    background = uint16(cdata_mat/NumOfFrames);    fprintf('\n');    if plot_background        figure('name','background (mean)');         imshow (background,[]);  set(gca,'Clim',[0 255]); title('mean');   colorbar    endend% Transfer background to uint8 if movie was in uint8 formatX=whos('Mov'); CLASS = X.class;if strcmpi(CLASS,'uint8')    background = uint8(background);end% save background mat fileFile.BackgroundFile = [File.TrackFile(1:end-4),'_background.mat'];save(File.BackgroundFile, 'background');% save background image if Background_params.save       [FileName,PathName] = uiputfile('*.bmp', 'Save Background Image');    if FileName ~= 0        imwrite(uint8(background),[PathName, FileName], 'bmp');    endend% imshow(background);return%% Initiate tracking sessions and status monitoringfunction InitiateFragmentTracker (File, All_Files, MovieNum, TrackerFunctionName, num_processors, max_processors)  disp(['Initiating Trackers in seperate Matlab sessions. Tracker name: ',TrackerFunctionName,char(10)]);StatusFile = File.StatusFile;% Free parameters for Spawning the tracker functionsSpawnSetting.Save           = 1;  % save master workspace; slaves will loadSpawnSetting.Exit           = 0;  % don't exit from master tracker NumFragments  = File.Fragments;    claimed       = (File.ClaimedFragments).*(File.CompletedFragments);   % Fragments that were not completed will not be considered as claimed. This is important if the movie is re-analyzed.disp(['Seeding fragments for Movie: ',File.MovieName,'. Number of fragements = ',num2str(NumFragments)]);while ~all(claimed)  % if any unclaimed fragments left...    completed      = File.CompletedFragments;    fragments_left = find(~claimed);    next_fragment  = min(fragments_left);    processors_used = sum(claimed & ~completed);           if processors_used < min(num_processors, max_processors)        claimed(next_fragment) = 1;        File.ClaimedFragments  = claimed;        if length(All_Files)>1            All_Files(MovieNum)= File;        else            All_Files          = File;        end                    save(StatusFile,'File','All_Files');        % SPAWN new FragmentTracker        Fragment = next_fragment;        disp([datestr(now), '  spawning for fragment ',int2str(Fragment),'/',int2str(NumFragments)]);        disp(['  Fragments completed: ',sprintf('%1d ',completed)]);        disp(['  Fragments analyzing: ',sprintf('%1d ',claimed & ~completed)]);        fprintf('\n\n');        %% This paragraph opens a new Matlab window to track the worms using the function given by: 'TrackerFunctionName'        SpawnSetting.Startup  = ['Fragment=',int2str(Fragment), TrackerFunctionName];                                                       spawn2(SpawnSetting, File.TempFolder)         pause(4);    else        disp(['waiting for processors to finish fragements before seeding fragment number ',num2str(next_fragment)]);        pause(30);    end          load(StatusFile,'File');end   disp('all fragments seeded. waiting for slaves to finish computation...')returnfunction spawn2(SpawnSetting, TempFolder)if ~(exist('SpawnSetting') && isfield(SpawnSetting,'Save') && isfield(SpawnSetting,'Startup'))    SpawnSetting.Save    = 1;    SpawnSetting.Startup = 'load';endif ~isfield(SpawnSetting,'Exit')    SpawnSetting.Exit = 0;endif ~isfield(SpawnSetting,'MatlabFlags')    SpawnSetting.MatlabFlags = [];endif SpawnSetting.Save    cd(TempFolder)    %save;    save('matlab.mat');    if ~any(strfind(SpawnSetting.Startup,'load'))        SpawnSetting.Startup = ['load;',SpawnSetting.Startup];    endendMatlabfile = [fullfile(matlabroot,'bin','win64','MATLAB.exe')];    % Matlab 64 bitif  ~exist(Matlabfile,'file') % The current Matlab version is a 32 bit version    disp('Running Matlab 32 bit');    Matlabfile = [fullfile(matlabroot,'bin','win32','MATLAB.exe')];   end    com = sprintf('!"%s" -nosplash %s -r %s &',Matlabfile,SpawnSetting.MatlabFlags,SpawnSetting.Startup);    eval(com);if SpawnSetting.Exit    exitendreturnfunction StatusMonitoring (TempFolder, check_status_interval, File, MovieNum, TotalMovieNum)load TrackingVariables_SL  FigHandleNumFragments            = File.Fragments;   TrackName               = File.TrackFile;[pathname,filename]     = fileparts(TrackName);partsfolder             = '\trackfile parts\';    % Check that all fragments are completedwhile length(dir([pathname,partsfolder,filename,'*'])) < (NumFragments*(File.NumArenas+1))    pause(check_status_interval)    load (File.StatusFile);    % parse fragment status files    StatusD = dir(fullfile(TempFolder,'_F*')); StatusLine = [StatusD.name];    StatusM = zeros(1,NumFragments);    a = strfind(StatusLine,'.'); b = [strfind(StatusLine,'_'),length(StatusLine)+1]; b = circshift(b,[0 -1]); aF = strfind(StatusLine,'F');    for c = 1:length(a); StatusM(str2num(StatusLine(aF(c)+1:a(c)-1))) = str2num(StatusLine(a(c)+1:b(c)-1)); end % get percent progress from each fragment tracker        StatusM(File.CompletedFragments==1) = 100;        % show status window    figure(FigHandle);    bar(StatusM); set(gca,'YLim',[0 100]);     ylabel('Completed (%)'); xlabel('Fragment Number');     title({datestr(now),['Movie number [',num2str(MovieNum),'/',num2str(TotalMovieNum),'],    ', File.TrackFile]},'Interpreter','none');enddisp([datestr(now), '   found all files. start stitching in 10 seconds.']);pause(10);returnfunction All_Files = InitiateBehaviorSegmentation (File, All_Files, MovieNum, BehaviorSegmentationFunctionName, num_processors, max_processors)  disp(['Initiating behavior segmentation in seperate Matlab sessions. Tracker name: ',BehaviorSegmentationFunctionName,char(10)]);StatusFile = File.StatusFile;% Free parameters for Spawning the tracker functionsSpawnSetting.Save           = 1;  % save master workspace; slaves will loadSpawnSetting.Exit           = 0;  % don't exit from master tracker NumArenas       = File.NumArenas;    ClaimedArenas   = File.BehaviorSegmentation.ClaimedArenas;CompletedArenas = File.BehaviorSegmentation.CompletedArenas;claimed         = (ClaimedArenas).*(CompletedArenas);   % Arenas that were not completed will not be considered as claimed. This is important if the movie is re-analyzed.disp(['Seeding behavior segmentation sessions for Movie: ',File.MovieName,'. Number of arenas = ',num2str(NumArenas)]);while ~all(claimed)  % if any unclaimed fragments left...    completed       = File.BehaviorSegmentation.CompletedArenas;    arenas_left     = find(~claimed,1,'first');    next_arena      = min(arenas_left);    Processors_Used = length(find(claimed));    if (Processors_Used < min(num_processors, max_processors))        claimed(next_arena) = 1;        File.BehaviorSegmentation.ClaimedArenas  = claimed;        if length(All_Files)>1            All_Files(MovieNum)= File;        else            All_Files          = File;        end                    save(StatusFile,'File','All_Files');        % SPAWN new FragmentTracker        ArenaID = next_arena;        disp([datestr(now), '  spawning for arena ',int2str(ArenaID),'/',int2str(NumArenas)]);        disp(['  Arenas completed: ',sprintf('%1d ',completed)]);        disp(['  Arenas analyzing: ',sprintf('%1d ',claimed & ~completed)]);        fprintf('\n\n');        %% This paragraph opens a new Matlab window to track the worms using the function given by: 'TrackerFunctionName'        SpawnSetting.Startup        = ['ArenaID=',int2str(ArenaID),';load(''',StatusFile, ''')', BehaviorSegmentationFunctionName];                                                 spawn2(SpawnSetting,  File.TempFolder)             else        disp(['waiting for processors to finish fragements before seeding arena number ',num2str(next_arena)]);        pause(40);        load(StatusFile,'File')        completed = File.BehaviorSegmentation.CompletedArenas;    endend disp('all arenas seeded. waiting for slaves to finish computation...')% Status monitoring:while ~all(completed)    ArenaCompletionStatus = completed;    pause(30);    load(StatusFile,'File')    completed = File.BehaviorSegmentation.CompletedArenas;enddisp([datestr(now), '  Finished behavior segmentation for Movie number ',num2str(MovieNum),', ',File.MovieName]);% Update status fileload(StatusFile,'File','All_Files');File.BehaviorSegmented = true;if length(All_Files)>1    All_Files(MovieNum)= File;else    All_Files          = File;end save(StatusFile,'File','All_Files');returnfunction File = InitiateDyeTracker (File, All_Files, MovieNum, TrackDyeFunctionName, num_processors, max_processors, DyePatternsTimeWindow)  disp(['Initiating dye tracker in seperate Matlab sessions. Tracker name: ',TrackDyeFunctionName,char(10)]);StatusFile = File.StatusFile;%% Fragment the frames analysis based on number of processorsNumOfFragments          = min(num_processors, max_processors);    DyePatternsFramesWindow = DyePatternsTimeWindow*60*File.FrameRate;TotalNumOfFrames        = (DyePatternsFramesWindow(2)-DyePatternsFramesWindow(1)+1);FramesInterval          = ceil(TotalNumOfFrames/NumOfFragments);FragmentFrames          = zeros(NumOfFragments,2);InitialFrame            = DyePatternsFramesWindow(1);for f_ind = 1:(NumOfFragments-1)    FragmentFrames(f_ind,:)= [InitialFrame InitialFrame+FramesInterval-1];    InitialFrame           = InitialFrame+FramesInterval;endLastFrame                       = min([DyePatternsFramesWindow(2) File.NumberOfFramesInMovie_IncludingDyeAnalysis]);FragmentFrames(NumOfFragments,:)= [InitialFrame LastFrame];  File.DyeAnalysisFragmentFrames  = FragmentFrames;%% Dye tracker filenamesTrackName               = File.TrackFile;[pathname,filename,ext] = fileparts(TrackName);partsfolder             = '\trackfile parts\';DyeAnalysisFragmentSaveNames  = cell(NumOfFragments,1); for i = 1:NumOfFragments    DyeAnalysisFragmentSaveNames(i) = {[pathname,partsfolder,filename,'_DyeAnalysis_part',num2str(i),ext]}; endFile.DyeAnalysisFragmentSaveNames = DyeAnalysisFragmentSaveNames;File.DyeCompletedFragments        = false(1,NumOfFragments);save(File.StatusFile,'File','-append');pause(3);%% Spawn% Free parameters for Spawning the tracker functionsSpawnSetting.Save           = 1;  % save master workspace; slaves will loadSpawnSetting.Exit           = 0;  % don't exit from master tracker disp(['Seeding dye tracker for Movie: ',File.MovieName,'. Number of fragments = ',num2str(NumOfFragments)]);Claimed_Fragments = false(1,NumOfFragments);while ~all(Claimed_Fragments)  % if any unclaimed fragments left...    completed      = File.DyeCompletedFragments;    next_fragment  = find(Claimed_Fragments==0,1,'first');    processors_used = sum(Claimed_Fragments & ~completed);           if processors_used < min(num_processors, max_processors)        Claimed_Fragments(next_fragment) = 1;        save(StatusFile,'File','-append');        % SPAWN new FragmentTracker        disp([datestr(now), '  spawning for fragment ',num2str(next_fragment),'/',int2str(NumOfFragments)]);        fprintf('\n\n');        % This paragraph opens a new Matlab window to track the worms using the function given by: 'TrackerFunctionName'        SpawnSetting.Startup  = ['Fragment=',num2str(next_fragment),TrackDyeFunctionName];                                         spawn2(SpawnSetting,  File.TempFolder)         pause(3);            else        disp(['waiting for processors to finish fragements before seeding fragment number ',num2str(next_fragment)]);        pause(30);        load(StatusFile,'File');   end      end   disp('all fragments seeded. waiting for slaves to finish computation.')%% Status monitoring:DyeCompletedFragments = false(1,NumOfFragments);while ~all(DyeCompletedFragments)    pause(30);    load(StatusFile,'File')       DyeCompletedFragments = File.DyeCompletedFragments;enddisp([datestr(now), '  Finished basic dye tracking for Movie number ',num2str(MovieNum),', ',File.MovieName]);save(StatusFile,'File','-append')   return%% Stitching dye patternsfunction  StitchDyePatterns_pulses(File)   % For pulse device: Compute gradient, compute fast vs. slow transitions%% Function step-by-step calculations% (1) Generate 'AllPatternMatrix'      >> Load and stitch all DyePattern data structures%     Generate 'FilteredPatternMatrix' >> upply a 1 second window averaging filter on 'AllPatternMatrix'   %          NOTE !! Here I am neglecting the time bias due to averaging (on the time scale of <500 miliseconds)    %% (2) Generate 'MaxValue_reference' >> Reference pattern (from FilteredPatternMatrix) when dye is flowing in all inlets (last minute in the session) %     Generate 'NormPatternMatrix'  >> 'FilteredPatternMatrix'/'MaxValue_reference'   %% (3) FOR EACH ARENA use the 'MaxValue_reference' to find exact Yaxis and Xaxis as follows: %   Find edges of the Y axis (Gradient axis):%       averaging the RAW matrix over the X axis%       finding the first and the last peaks during the 'All Dye' time %       These peaks are the Y-Start and Y-End of the arena%   Find edges of the X axis (flow axis):%       find the 10 bins in the middle of each arena relative to the Y-axis (gradient axis)%       average RAW matrix over Y axis%       finding the first and last peaks during the 'All Dye' time %       These peaks are the X-Start and X-End of the arena% (4) FOR EACH ARENA use the RawMatrix ('AllPatternMatrix') and Norm matrix ('NormPatternMatrix') as follows: %  Make ArenaMatrix: %       Take the NormMatrix or RawMatrix within the arena edges %       Reshape the matrix to fit a new binning of [5,100] for [X,Y], respectively.%       Reshaping will introduce spatial linear smoothing of the data, as necessary.   %       ArenaMatrix will have size of (NumOfFrames,5,100);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %% (1) Generate 'AllPatternMatrix'      >> Load and stitch all DyePattern data structures%%     Generate 'FilteredPatternMatrix' >> upply a 1 second window averaging filter on 'AllPatternMatrix'   %%          NOTE !! Here I am neglecting the time bias due to averaging (on the time scale of <500 miliseconds)    if isfield(File.VariablesInformation,'DyeFastSlowTransitionTiming')    DyeFastSlowTransitionTiming = File.VariablesInformation.DyeFastSlowTransitionTiming;    else        disp('WARNING!!  ''DyeFastSlowTransitionTiming'' was not defined - using default values');       DyeFastSlowTransitionTiming.TimeSlowSwitch_ON  = [1 22];         % minutes. Dye ON via 8-valve #1 and then 8-valve #2    DyeFastSlowTransitionTiming.TimeSlowSwitch_OFF = [];             % minutes.     DyeFastSlowTransitionTiming.TimeWindowSlow     = 7;              % minutes.     DyeFastSlowTransitionTiming.TimeFastSwitch_ON  = [10 14 18];     % minutes. Dye ON  via fast-switch    DyeFastSlowTransitionTiming.TimeFastSwitch_OFF = [8  12 16 20];  % minutes. Dye OFF via fast-switch    DyeFastSlowTransitionTiming.TimeWindowFast     = 2;              % minutes.     DyeFastSlowTransitionTiming.SecondsToAverage   = 2;              % 2 seconds before stimulus up to 2 last seconds) endSpecialFrameNumber = (DyeFastSlowTransitionTiming.TimeSlowSwitch_ON(1)+DyeFastSlowTransitionTiming.TimeWindowSlow(1)) * 60 * File.FrameRate;FILEPATH = File.MoviePath;disp([datestr(now), '  Generate ''AllPatternMatrix'' and ''FilteredPatternMatrix''']);FragmentFrames             = File.DyeAnalysisFragmentFrames;  TotalNumberOfFrames        = FragmentFrames(end,end) - FragmentFrames(1,1) +1;DyeFrames                  = FragmentFrames(1,1):FragmentFrames(end,end);NumOfFragments             = size(FragmentFrames,1);load(File.DyeAnalysisFragmentSaveNames{1},'binning');AllPatternMatrix              = zeros(TotalNumberOfFrames,binning.NumOfBins_X, binning.NumOfBins_Y,'single');NumberOfFramesInEachFragement = diff(FragmentFrames,[],2)+1;frame_ind=1;for i = 1:NumOfFragments    % Load and stitch all DyePattern data structures    load(File.DyeAnalysisFragmentSaveNames{i},'PatternMatrix');    AllPatternMatrix(frame_ind:(frame_ind+NumberOfFramesInEachFragement(i)-1),:,:) = PatternMatrix;    frame_ind = frame_ind+NumberOfFramesInEachFragement;endclear PatternMatrixwindowSize        = File.FrameRate-1;  % filter on time scale of 1 second;b                 = (1/windowSize)*ones(1,windowSize);a                 = 1;FilteredPatternMatrix = filter(b,a,AllPatternMatrix);FilterDelay           = floor((windowSize/2));FilteredPatternMatrix(1:end-FilterDelay,:,:) = FilteredPatternMatrix((FilterDelay+1):end,:,:);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %% (2) Generate 'MaxValue_reference' >> Reference pattern when dye is flowing in all inlets (last minute in the session) %%     Generate 'NormPatternMatrix'  >> 'FilteredPatternMatrix'/'MaxValue_reference'  % MaxValue_referencedisp([datestr(now), '  Generate ''MaxValue_reference'' and ''NormPatternMatrix''']);LastAllDyeFrame_IndexInMatrix = File.VariablesInformation.FramesOfInterest.OnlyDye(2) - ...                                File.VariablesInformation.FramesOfInterest.DyePatterns(1);FirstAllDyeFrame_IndexInMatrix_ForReference = LastAllDyeFrame_IndexInMatrix- 120*File.FrameRate;  % LastTwoMinutesMaxValue_reference = squeeze(nanmean(squeeze(FilteredPatternMatrix(FirstAllDyeFrame_IndexInMatrix_ForReference:LastAllDyeFrame_IndexInMatrix,:,:)),1));mean_dye_values           = nansum(nansum(FilteredPatternMatrix,3),2) / (size(FilteredPatternMatrix,3)*size(FilteredPatternMatrix,2));  % mean dye value for each frame[max_mean_val, max_frame_ind] = max(mean_dye_values);if nanmean(MaxValue_reference(:)) < 0.95 * max_mean_val    TimeShiftForAllDyeReference = (max_frame_ind -  LastAllDyeFrame_IndexInMatrix)/File.FrameRate;    disp(['NOTE!!!   Dye did not cover the arena within the ''OnlyDye'' frame window. ' ...         'Reference frame is shifted ', num2str(TimeShiftForAllDyeReference),' seconds after ''OnlyDye'' ends']);    LastAllDyeFrame_IndexInMatrix = max_frame_ind;    FirstAllDyeFrame_IndexInMatrix_ForReference = LastAllDyeFrame_IndexInMatrix- 30*File.FrameRate;  % Last HALF minute    MaxValue_reference = squeeze(nanmean(squeeze(FilteredPatternMatrix(FirstAllDyeFrame_IndexInMatrix_ForReference:LastAllDyeFrame_IndexInMatrix,:,:)),1));end% NormPatternMatrixNormPatternMatrix = FilteredPatternMatrix./shiftdim(repmat(MaxValue_reference,[1 1 TotalNumberOfFrames]),2);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %% (3) FOR EACH ARENA use the 'MaxValue_reference' to find exact Yaxis and Xaxis disp([datestr(now), '  FOR EACH ARENA use the ''MaxValue_reference'' to find exact Yaxis and Xaxis']);YaxisLimits       = zeros(File.NumArenas,2);YaxisLimitsFlag   = true(File.NumArenas,2); % true = good; will be set to false in case of possible errorsXaxisLimits       = zeros(File.NumArenas,2);XaxisLimitsFlag   = true(File.NumArenas,2); % true = good; will be set to false in case of possible errorsDiffThreshold     = 0.3; for ar=1:File.NumArenas        %% Use arena definitions to find "over-estimated" arena location in the binned-matrices (in 'FilteredPatternMatrix')      TrackBoxAxis     = File.TrackBoxAxis(ar,:); % Corresponds to the real axis in imagesc and imshow therefore OPPOSITE of Mov!!        XindicesInFrame  = [TrackBoxAxis(3) TrackBoxAxis(4)];    BinsToCheck.Xmin = max(find(binning.meanXcoordinates>XindicesInFrame(1),1,'first'),1);    BinsToCheck.Xmax = min(find(binning.meanXcoordinates<XindicesInFrame(2),1,'last')+1, binning.NumOfBins_X);    Xindices         = BinsToCheck.Xmin :  BinsToCheck.Xmax;    YindicesInFrame = [TrackBoxAxis(1) TrackBoxAxis(2)];    BinsToCheck.Ymin = max(find(binning.meanYcoordinates>YindicesInFrame(1),1,'first'),1);    BinsToCheck.Ymax = min(find(binning.meanYcoordinates<YindicesInFrame(2),1,'last')+1, binning.NumOfBins_Y);    Yindices         = BinsToCheck.Ymin :  BinsToCheck.Ymax;        %% Calculation of Yaxis start-bin and end-bin    %% Ystart    Yaxis         = nanmean(MaxValue_reference(Xindices,Yindices),1); Yaxis=Yaxis/max(Yaxis);    diffY         = diff(Yaxis);    [pks,locs]    = findpeaks(double(diffY),'MinPeakProminence',DiffThreshold);    if isempty(locs)        % find first small negative diff, if within 5 bins-accept it        Condition =(diffY<0)&(diffY>-0.05);        FirstSmallNegativeDiff = find(Condition,1,'first');        if FirstSmallNegativeDiff<=5            locs = FirstSmallNegativeDiff;        else            YaxisLimitsFlag(ar,1) = false;        end                CurrentThreshold = DiffThreshold/0.8;        while isempty(locs)            CurrentThreshold=CurrentThreshold*0.8;            [pks,locs] = findpeaks(double(diffY),'Threshold',CurrentThreshold);        end    end    FirstDiffPeak = locs(1);    FirstNegativeDiffAfterPeak = FirstDiffPeak + find(diffY((FirstDiffPeak+1):end)<0,1,'first');    Ystart = FirstNegativeDiffAfterPeak;          %% Yend    YaxisSwitched = Yaxis(end:-1:1);    diffYSwitched = diff(YaxisSwitched);    [pks,locs]    = findpeaks(double(diffYSwitched),'MinPeakProminence',DiffThreshold);    if isempty(locs)         % find first small negative diff, if within 5 bins-accept it        Condition =(diffYSwitched<0)&(diffYSwitched>-0.05);        FirstSmallNegativeDiff = find(Condition,1,'first');        if FirstSmallNegativeDiff<=5            locs = FirstSmallNegativeDiff;        else            YaxisLimitsFlag(ar,2) = false;        end           CurrentThreshold = DiffThreshold/0.8;        while isempty(locs)            CurrentThreshold=CurrentThreshold*0.8;            [pks,locs] = findpeaks(double(diffY),'Threshold',CurrentThreshold);        end    end    FirstDiffPeak = locs(1);    FirstNegativeDiffAfterPeak = FirstDiffPeak + find(diffYSwitched((FirstDiffPeak+1):end)<0,1,'first');    Yend  = length(Yaxis)-FirstNegativeDiffAfterPeak+1;           CurrentYlimits    = Yindices([Ystart Yend]);    YaxisLimits(ar,:) = CurrentYlimits;        Yindices = YaxisLimits(ar,1):YaxisLimits(ar,2);  % Correct Yindices before starting Xaxis calculation         %% Calculation of Xaxis start-bin and end-bin        %% Xstart    Xaxis = nanmean(MaxValue_reference(Xindices,Yindices),2); Xaxis=Xaxis/max(Xaxis);    DiffX = diff(Xaxis);     FirstNegativeDiff = find(DiffX<0.01,1,'first');   % <0.01 instead of 0...    if DiffX(FirstNegativeDiff+1)>0.1  % Once in the arena, changes can not be too drastic anymore.         % This condition fix possible errors due to too large definition of the arena          TwoFirstNegativeDiff = find(DiffX<0.01,2,'first');        FirstNegativeDiff = TwoFirstNegativeDiff(2);     end    if FirstNegativeDiff>5        disp(['possible error in X limits calculations, arena: ',num2str(ar),'. Setting Xstart to be the second bin'])        FirstNegativeDiff = 2;        XaxisLimitsFlag(ar,1) = false;    end    Xstart = FirstNegativeDiff;     %% Xend    XaxisSwitched             = Xaxis(end:-1:1);    DiffXSwitched             = diff(XaxisSwitched);    FirstNegativeDiffSwitched = find(DiffXSwitched<0.01,1,'first');  % <0.01 instead of 0...    if DiffXSwitched(FirstNegativeDiffSwitched+1)>0.1  % Once in the arena, changes can not be too drastic anymore.         % This condition fix possible errors due to too large definition of the arena          TwoFirstNegativeDiffSwitch = find(DiffXSwitched<0.01,2,'first');        FirstNegativeDiffSwitched = TwoFirstNegativeDiffSwitch(2);     end    if FirstNegativeDiffSwitched>5        disp(['possible error in X limits calculations, arena: ',num2str(ar),'. Setting Xend to be the second bin'])        FirstNegativeDiffSwitched = 2;        XaxisLimitsFlag(ar,2)     = false;    end    Xend           = length(Xaxis)-FirstNegativeDiffSwitched+1;    CurrentXlimits = Xindices([Xstart Xend]);    XaxisLimits(ar,:) = CurrentXlimits;     end% Correct arenas that were flagged XaxisWidth          = XaxisLimits(:,2)-XaxisLimits(:,1);ReliableXaxis       = XaxisLimitsFlag(:,1) &  XaxisLimitsFlag(:,2);ReliableXaxis       = ReliableXaxis';Expected_XaxisWidth = round(mean(XaxisWidth(ReliableXaxis)));ArenasToCorrect     = find(~ReliableXaxis);if ~isempty(ArenasToCorrect)    for ar = ArenasToCorrect        disp(['Correcting X axis for arena: ',num2str(ar)])        if (XaxisLimitsFlag(ar,1)==false)&& (XaxisLimitsFlag(ar,2)==false)      % if both Xstart and Xend are not reliable            switch ar                case 1                    XaxisLimits(1,:)= XaxisLimits(2,:);                 case 2                    XaxisLimits(2,:)= XaxisLimits(1,:);                 case 3                    XaxisLimits(3,:)= XaxisLimits(4,:);                 case 4                    XaxisLimits(4,:)= XaxisLimits(3,:);             end                elseif XaxisLimitsFlag(ar,1)     % if Xstart is reliable >> correct Xend            XaxisLimits(ar,2)= XaxisLimits(ar,1)+ Expected_XaxisWidth;        elseif XaxisLimitsFlag(ar,2)     % if Xend is reliable >> correct Xstart            XaxisLimits(ar,1)= XaxisLimits(ar,2)- Expected_XaxisWidth;        end    endendYaxisWidth          = YaxisLimits(:,2)-YaxisLimits(:,1);ReliableYaxis       = YaxisLimitsFlag(:,1) &  YaxisLimitsFlag(:,2);ReliableYaxis       = ReliableYaxis';Expected_YaxisWidth = round(mean(YaxisWidth(ReliableYaxis)));ArenasToCorrect     = find(~ReliableYaxis);if ~isempty(ArenasToCorrect)    for ar = ArenasToCorrect        disp(['Correcting Y axis for arena: ',num2str(ar)])        if (YaxisLimitsFlag(ar,1)==false)&& (YaxisLimitsFlag(ar,2)==false)      % if both Ystart and Yend are not reliable            switch ar                case 1                    YaxisLimits(1,:)= YaxisLimits(3,:);                 case 2                    YaxisLimits(2,:)= YaxisLimits(4,:);                 case 3                    YaxisLimits(3,:)= YaxisLimits(1,:);                 case 4                    YaxisLimits(4,:)= YaxisLimits(2,:);             end                elseif YaxisLimitsFlag(ar,1)     % if Ystart is reliable >> correct Yend            YaxisLimits(ar,2)= YaxisLimits(ar,1)+ Expected_YaxisWidth;        elseif YaxisLimitsFlag(ar,2)     % if Yend is reliable >> correct Ystart            YaxisLimits(ar,1)= YaxisLimits(ar,2)- Expected_YaxisWidth;        end    endend%% Constraint arenas to have the same length and width + Plots% BeforeFigureString = 'Reference frame with arena segmentation- BEFORE Forcing arenas similarity';f=figure('name',FigureString);MAT = MaxValue_reference;imagesc(MAT); colormap(gray)  for ar = 1:File.NumArenas       rectangle('position',[YaxisLimits(ar,1),XaxisLimits(ar,1),YaxisLimits(ar,2)-YaxisLimits(ar,1),XaxisLimits(ar,2)-XaxisLimits(ar,1)],...              'edgecolor','r');  endFigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);% CorrectXaxisWidthMinus1  = round(mean((XaxisLimits(:,2)-XaxisLimits(:,1)-1)/2))*2;YaxisWidthMinus1  = round(mean((YaxisLimits(:,2)-YaxisLimits(:,1)-1)/2))*2;XaxisMiddle       = (XaxisLimits(:,2)+XaxisLimits(:,1))/2;YaxisMiddle       = (YaxisLimits(:,2)+YaxisLimits(:,1))/2;XaxisMiddle([1 2]) = round(mean(XaxisMiddle([1 2])));XaxisMiddle([3 4]) = round(mean(XaxisMiddle([3 4])));YaxisMiddle([1 3]) = round(mean(YaxisMiddle([1 3])));YaxisMiddle([2 4]) = round(mean(YaxisMiddle([2 4])));for ar=1:File.NumArenas       XaxisLimits(ar,1)   = XaxisMiddle(ar)-XaxisWidthMinus1/2;    XaxisLimits(ar,2)   = XaxisMiddle(ar)+XaxisWidthMinus1/2;    YaxisLimits(ar,1)   = YaxisMiddle(ar)-YaxisWidthMinus1/2;    YaxisLimits(ar,2)   = YaxisMiddle(ar)+YaxisWidthMinus1/2;end% AfterFigureString = 'Reference frame with arena segmentation';f=figure('name',FigureString);MAT = MaxValue_reference;imagesc(MAT); colormap(gray)  for ar = 1:File.NumArenas       rectangle('position',[YaxisLimits(ar,1),XaxisLimits(ar,1),YaxisLimits(ar,2)-YaxisLimits(ar,1),XaxisLimits(ar,2)-XaxisLimits(ar,1)],...              'edgecolor','r');  endFigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);  %% Figures to manually check the results for Yaxis and Xaxis FigureString = 'Yaxis patterns';f=figure('name',FigureString);for ar = 1:File.NumArenas    subplot(2,2,ar);    Yaxis = nanmean(MaxValue_reference(XaxisLimits(ar,1):XaxisLimits(ar,2),YaxisLimits(ar,1):YaxisLimits(ar,2)),1); Yaxis=Yaxis/max(Yaxis);    plot(Yaxis,'b-'); endFigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);FigureString = 'Xaxis patterns';f=figure('name',FigureString);for ar = 1:File.NumArenas    subplot(2,2,ar);    Xaxis = nanmean(MaxValue_reference(XaxisLimits(ar,1):XaxisLimits(ar,2),YaxisLimits(ar,1):YaxisLimits(ar,2)),2); Xaxis=Xaxis/max(Xaxis);    plot(Xaxis,'b-'); endFigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);%% Figures to see full dye and no-dye frames FigureString = 'Full dye - cropped to arenas.';f=figure('name',FigureString);MAT = squeeze(NormPatternMatrix(SpecialFrameNumber,:,:));  for ar = 1:File.NumArenas    subplot(2,2,ar);    MATcropped = MAT(XaxisLimits(ar,1):XaxisLimits(ar,2),YaxisLimits(ar,1):YaxisLimits(ar,2));      imagesc(MATcropped); colormap(gray); title(ar);     set(gca,'clim',[0 1])endFigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);FigureString = 'Full dye - Full frame with arena segmentation';f=figure('name',FigureString);imagesc(MAT); colormap(gray)  for ar = 1:File.NumArenas       rectangle('position',[YaxisLimits(ar,1),XaxisLimits(ar,1),YaxisLimits(ar,2)-YaxisLimits(ar,1),XaxisLimits(ar,2)-XaxisLimits(ar,1)],...              'edgecolor','r');  endset(gca,'clim',[0 1])FigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);FigureString = 'No dye - cropped to arenas.';f=figure('name',FigureString);MAT = squeeze(NormPatternMatrix(1,:,:));  for ar = 1:File.NumArenas    subplot(2,2,ar);    MATcropped = MAT(XaxisLimits(ar,1):XaxisLimits(ar,2),YaxisLimits(ar,1):YaxisLimits(ar,2));      imagesc(MATcropped); colormap(gray); title(ar);     set(gca,'clim',[0 1])endFigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);FigureString = 'No dye - Full frame with arena segmentation.';f=figure('name',FigureString);MAT = squeeze(NormPatternMatrix(1,:,:));  imagesc(MAT); colormap(gray)  for ar = 1:File.NumArenas       rectangle('position',[YaxisLimits(ar,1),XaxisLimits(ar,1),YaxisLimits(ar,2)-YaxisLimits(ar,1),XaxisLimits(ar,2)-XaxisLimits(ar,1)],...              'edgecolor','r');  endset(gca,'clim',[0 1])FigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %% (4) FOR EACH ARENA use 'NormPatternMatrix' to make ArenasDyePatterns %  ArenasDyePatterns = size(NumOfArnes,TotalNumberOfFrames,5,100), where [5,100] corresponds to [X,Y], respectively. %       Take the NormMatrix or RawMatrix within the arena edges %       Reshape the matrix to fit a new binning of [5,100] for [X,Y], respectively.%       Reshaping will introduce spatial linear smoothing of the data, as necessary.   %       ArenaMatrix will have size of (NumOfFrames,5,100);disp([datestr(now), '  FOR EACH ARENA use ''NormPatternMatrix'' to calculate ''ArenasDyePatterns''. This will take around 2 minutes...']);ArenasDyePatterns = zeros(File.NumArenas, TotalNumberOfFrames, 5, 100, 'single');for frame_ind = 1:TotalNumberOfFrames    for ar = 1:File.NumArenas        CurrentNormPatternMatrix = squeeze(NormPatternMatrix(frame_ind, XaxisLimits(ar,1):XaxisLimits(ar,2), YaxisLimits(ar,1):YaxisLimits(ar,2)));         ArenasDyePatterns(ar,frame_ind,:,:) = imresize(CurrentNormPatternMatrix, [5, 100]);    end    endArenasDyePatterns_Xaverage = squeeze(mean(ArenasDyePatterns,3));%% Find Flow Delays in slow versus fast switches.% Example for input:%     DyeFastSlowTransitionTiming.TimeSlowSwitch_ON  = [1 22];         % minutes. Dye ON via 8-valve #1 and then 8-valve #2%     DyeFastSlowTransitionTiming.TimeSlowSwitch_OFF = [];             % minutes. %     DyeFastSlowTransitionTiming.TimeWindowSlow     = 7;              % minutes. %     DyeFastSlowTransitionTiming.TimeFastSwitch_ON  = [10 14 18];     % minutes. Dye ON  via fast-switch%     DyeFastSlowTransitionTiming.TimeFastSwitch_OFF = [8  12 16 20];  % minutes. Dye OFF via fast-switch%     DyeFastSlowTransitionTiming.TimeWindowFast     = 2;              % minutes. %     DyeFastSlowTransitionTiming.SecondsToAverage   = 2;              % 2 seconds before stimulus up to 2 last seconds) IndicesSlowSwitch_ON  = DyeFastSlowTransitionTiming.TimeSlowSwitch_ON  * 60 * File.FrameRate;  % Dye ON via 8-valve #1 and then 8-valve #2IndicesSlowSwitch_OFF = DyeFastSlowTransitionTiming.TimeSlowSwitch_OFF * 60 * File.FrameRate;  % Dye OFF via 8-valvesFrameWindowSlow       = DyeFastSlowTransitionTiming.TimeWindowSlow     * 60 * File.FrameRate;                IndicesFastSwitch_ON  = DyeFastSlowTransitionTiming.TimeFastSwitch_ON  * 60 * File.FrameRate;  % Dye ON  via fast-switchIndicesFastSwitch_OFF = DyeFastSlowTransitionTiming.TimeFastSwitch_OFF * 60 * File.FrameRate;  % Dye OFF via fast-switchFrameWindowFast       = DyeFastSlowTransitionTiming.TimeWindowFast     * 60 * File.FrameRate;   FramesToAverage       = DyeFastSlowTransitionTiming.SecondsToAverage        * File.FrameRate;  % 2 seconds before stimulus up to 2 last seconds) DyeAverageOverArenaWidth = squeeze(mean(ArenasDyePatterns,4));DyeFlowInDynamics        = squeeze(DyeAverageOverArenaWidth(:,:,1));DyeFlowInDynamics(:,1:windowSize) = repmat(DyeFlowInDynamics(:,windowSize),1,windowSize);     % correct filter delayFigureString = 'Slow and fast dye onset in different arenas';f=figure('name',FigureString);LINESPECS = {'k-','r-','k:','r:'};PatternsOnset_Slow = zeros(File.NumArenas, FrameWindowSlow,'single');PatternsOnset_Fast = zeros(File.NumArenas, FrameWindowFast,'single');for ar= 1:File.NumArenas   subplot(2,2,1);         CurrentMAT = ones(length(IndicesSlowSwitch_ON),FrameWindowSlow)*NaN;       for ind = 1:length(IndicesSlowSwitch_ON)           Baseline   = mean(DyeFlowInDynamics(ar,IndicesSlowSwitch_ON(ind)-1+(1:FramesToAverage)));           MaxVal     = mean(DyeFlowInDynamics(ar,IndicesSlowSwitch_ON(ind)+FrameWindowSlow -(1:FramesToAverage)));           CurrentVec = (DyeFlowInDynamics(ar,IndicesSlowSwitch_ON(ind)-1+(1:FrameWindowSlow))-Baseline)/(MaxVal-Baseline);           CurrentMAT(ind,:) = CurrentVec;       end       Vec = nanmean(CurrentMAT,1);       Vec_ON = Vec;       plot((1:length(Vec))/File.FrameRate,Vec,LINESPECS{ar}); hold on; title('Slow ON'); ylim([-0.05 1.05])          subplot(2,2,2);         CurrentMAT = ones(length(IndicesSlowSwitch_OFF),FrameWindowSlow)*NaN;       for ind = 1:length(IndicesSlowSwitch_OFF)           Baseline   = mean(DyeFlowInDynamics(ar,IndicesSlowSwitch_OFF(ind)-1+(1:FramesToAverage)));           MaxVal     = mean(DyeFlowInDynamics(ar,IndicesSlowSwitch_OFF(ind)+FrameWindowSlow -(1:FramesToAverage)));           CurrentVec = (DyeFlowInDynamics(ar,IndicesSlowSwitch_OFF(ind)-1+(1:FrameWindowSlow))-Baseline)/(MaxVal-Baseline);           CurrentMAT(ind,:) = CurrentVec;       end       Vec = nanmean(CurrentMAT,1);       Vec_OFF = Vec;       plot((1:length(Vec))/File.FrameRate,Vec,LINESPECS{ar}); hold on; title('Slow OFF'); ylim([-0.05 1.05])       PatternsOnset_Slow(ar,:) = Vec_ON;      subplot(2,2,3);         CurrentMAT = ones(length(IndicesFastSwitch_ON),FrameWindowFast)*NaN;       for ind = 1:length(IndicesFastSwitch_ON)           Baseline   = mean(DyeFlowInDynamics(ar,IndicesFastSwitch_ON(ind)-1+(1:FramesToAverage)));           MaxVal     = mean(DyeFlowInDynamics(ar,IndicesFastSwitch_ON(ind)+FrameWindowFast -(1:FramesToAverage)));           CurrentVec = (DyeFlowInDynamics(ar,IndicesFastSwitch_ON(ind)-1+(1:FrameWindowFast))-Baseline)/(MaxVal-Baseline);           CurrentMAT(ind,:) = CurrentVec;       end       Vec = nanmean(CurrentMAT,1);       Vec_ON = Vec;       plot((1:length(Vec))/File.FrameRate,Vec,LINESPECS{ar}); hold on; title('Fast ON'); ylim([-0.05 1.05])             subplot(2,2,4);         CurrentMAT = ones(length(IndicesFastSwitch_OFF),FrameWindowFast)*NaN;       for ind = 1:length(IndicesFastSwitch_OFF)           Baseline   = mean(DyeFlowInDynamics(ar,IndicesFastSwitch_OFF(ind)-1+(1:FramesToAverage)));           MaxVal     = mean(DyeFlowInDynamics(ar,IndicesFastSwitch_OFF(ind)+FrameWindowFast -(1:FramesToAverage)));           CurrentVec = (DyeFlowInDynamics(ar,IndicesFastSwitch_OFF(ind)-1+(1:FrameWindowFast))-Baseline)/(MaxVal-Baseline);           CurrentMAT(ind,:) = CurrentVec;       end       Vec = nanmean(CurrentMAT,1);       Vec_OFF = Vec;       plot((1:length(Vec))/File.FrameRate,Vec,LINESPECS{ar}); hold on; title('Fast OFF'); ylim([-0.05 1.05]);   PatternsOnset_Fast(ar,:) = Vec_ON;   endFigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);%%%%%%% Slow Switch %%%%%%%PatternsOnset = PatternsOnset_Slow;FramesUntil_90_percent          = zeros(1,4);FramesUntilHalfDyePattern       = zeros(1,4);FramesUntilDyePatternInitiation = zeros(1,4);OnsetFrameEstimation            = zeros(1,4);ThresholdForDyeChange           = 5e-4;for ar = 1:4    FramesUntil_90_percent(ar)          = find(PatternsOnset(ar,:)>0.9,1,'first');    FramesUntilHalfDyePattern(ar)       = find(PatternsOnset(ar,:)>0.5,1,'first');    FramesUntilDyePatternInitiation(ar) = find(PatternsOnset(ar,:)>0.05,1,'first');    OnsetFrameEstimation(ar)            = find( diff(PatternsOnset(ar,1:FramesUntilHalfDyePattern(ar))) < ThresholdForDyeChange , 1 , 'last' );endSecondsUntil_90_percent                     = FramesUntil_90_percent/File.FrameRate;SecondsUntilHalfDyePattern                  = FramesUntilHalfDyePattern/File.FrameRate;SecondsUntilDyePatternInitiation_UpperLimit = FramesUntilDyePatternInitiation/File.FrameRate;   % Only upper limit... Use smoothed patterns for more exact timingSecondsUntilDyePatternInitiation = OnsetFrameEstimation/File.FrameRate;  % More exact estimationRiseTime_InitiationTo90Percent   = SecondsUntil_90_percent- SecondsUntilDyePatternInitiation;% calculate relevant flow rates and assign to structuresInterArenasDelay                 = mean(SecondsUntilHalfDyePattern(3:4))-mean(SecondsUntilHalfDyePattern(1:2)); % assuming similar flow in right and InterArenasDelay_Arenas_1and3    = SecondsUntilHalfDyePattern(3)-SecondsUntilHalfDyePattern(1); InterArenasDelay_Arenas_2and4    = SecondsUntilHalfDyePattern(4)-SecondsUntilHalfDyePattern(2); DyeInititationTime               = mean(SecondsUntilDyePatternInitiation(1:2));DyeInititationTime_Arenas_1and3  = SecondsUntilDyePatternInitiation(1);DyeInititationTime_Arenas_2and4  = SecondsUntilDyePatternInitiation(2);DyeStatsSlow.SecondsUntilHalfDyePattern                  = SecondsUntilHalfDyePattern;DyeStatsSlow.SecondsUntilDyePatternInitiation_UpperLimit = SecondsUntilDyePatternInitiation_UpperLimit;DyeStatsSlow.SecondsUntilDyePatternInitiation            = SecondsUntilDyePatternInitiation;DyeStatsSlow.InterArenasDelay                            = InterArenasDelay;DyeStatsSlow.InterArenasDelay_Arenas_1and3               = InterArenasDelay_Arenas_1and3;DyeStatsSlow.InterArenasDelay_Arenas_2and4               = InterArenasDelay_Arenas_2and4;DyeStatsSlow.DyeInititationTime                          = DyeInititationTime;DyeStatsSlow.DyeInititationTime_Arenas_1and3             = DyeInititationTime_Arenas_1and3;DyeStatsSlow.DyeInititationTime_Arenas_2and4             = DyeInititationTime_Arenas_2and4;DyeStatsSlow.RiseTime_InitiationTo90Percent              = RiseTime_InitiationTo90Percent;% plot: Dye onset dynamicsFigureString = 'Dye onset dynamics for SLOW switches raw';f=figure('name',FigureString);colors = {'b','r',[0.4 0.4 0.8],[0.8 0.4 0.4]};FramesToPlot = 1:FrameWindowSlow;for ar=1:4    plot(FramesToPlot/File.FrameRate, PatternsOnset(ar,FramesToPlot),'color',colors{ar}); hold on;endlegend('Arena 1 (UL)','Arena 2 (UR)','Arena 3 (LL)','Arena r (LR)');ylimits = get(gca,'ylim');for ar=1:4    line([SecondsUntilHalfDyePattern(ar)       SecondsUntilHalfDyePattern(ar)],       ylimits,'color',colors{ar},'linestyle',':');    line([SecondsUntilDyePatternInitiation(ar) SecondsUntilDyePatternInitiation(ar)], ylimits,'color',colors{ar},'linestyle','--');endxlabel('seconds'); ylabel('dye level');title(['Dye Inititation Time = ',num2str(min(SecondsUntilDyePatternInitiation)),' , Inter Arenas Delay= ',num2str(InterArenasDelay)]);FigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);%%%%%%%   Fast Switch   %%%%%%%PatternsOnset = PatternsOnset_Fast;FramesUntil_90_percent          = zeros(1,4);FramesUntilHalfDyePattern       = zeros(1,4);FramesUntilDyePatternInitiation = zeros(1,4);OnsetFrameEstimation            = zeros(1,4);ThresholdForDyeChange           = 5e-4;for ar = 1:4    FramesUntil_90_percent(ar)          = find(PatternsOnset(ar,:)>0.9,1,'first');    FramesUntilHalfDyePattern(ar)       = find(PatternsOnset(ar,:)>0.5,1,'first');    FramesUntilDyePatternInitiation(ar) = find(PatternsOnset(ar,:)>0.05,1,'first');    OnsetFrameEstimation(ar)            = find( diff(PatternsOnset(ar,1:FramesUntilHalfDyePattern(ar))) < ThresholdForDyeChange , 1 , 'last' );endSecondsUntil_90_percent                     = FramesUntil_90_percent/File.FrameRate;SecondsUntilHalfDyePattern                  = FramesUntilHalfDyePattern/File.FrameRate;SecondsUntilDyePatternInitiation_UpperLimit = FramesUntilDyePatternInitiation/File.FrameRate;   % Only upper limit... Use smoothed patterns for more exact timingSecondsUntilDyePatternInitiation = OnsetFrameEstimation/File.FrameRate;  % More exact estimationRiseTime_InitiationTo90Percent   = SecondsUntil_90_percent- SecondsUntilDyePatternInitiation;% calculate relevant flow rates and assign to structuresInterArenasDelay                 = mean(SecondsUntilHalfDyePattern(3:4))-mean(SecondsUntilHalfDyePattern(1:2)); % assuming similar flow in right and InterArenasDelay_Arenas_1and3    = SecondsUntilHalfDyePattern(3)-SecondsUntilHalfDyePattern(1); InterArenasDelay_Arenas_2and4    = SecondsUntilHalfDyePattern(4)-SecondsUntilHalfDyePattern(2); DyeInititationTime               = mean(SecondsUntilDyePatternInitiation(1:2));DyeInititationTime_Arenas_1and3  = SecondsUntilDyePatternInitiation(1);DyeInititationTime_Arenas_2and4  = SecondsUntilDyePatternInitiation(2);DyeStats.SecondsUntilHalfDyePattern                  = SecondsUntilHalfDyePattern;DyeStats.SecondsUntilDyePatternInitiation_UpperLimit = SecondsUntilDyePatternInitiation_UpperLimit;DyeStats.SecondsUntilDyePatternInitiation            = SecondsUntilDyePatternInitiation;DyeStats.InterArenasDelay                            = InterArenasDelay;DyeStats.InterArenasDelay_Arenas_1and3               = InterArenasDelay_Arenas_1and3;DyeStats.InterArenasDelay_Arenas_2and4               = InterArenasDelay_Arenas_2and4;DyeStats.DyeInititationTime                          = DyeInititationTime;DyeStats.DyeInititationTime_Arenas_1and3             = DyeInititationTime_Arenas_1and3;DyeStats.DyeInititationTime_Arenas_2and4             = DyeInititationTime_Arenas_2and4;DyeStats.RiseTime_InitiationTo90Percent              = RiseTime_InitiationTo90Percent;% plot: Dye onset dynamicsFigureString = 'Dye onset dynamics- raw';f=figure('name',FigureString);colors = {'b','r',[0.4 0.4 0.8],[0.8 0.4 0.4]};FramesToPlot = 1:FrameWindowFast;for ar=1:4    plot(FramesToPlot/File.FrameRate, PatternsOnset(ar,FramesToPlot),'color',colors{ar}); hold on;endlegend('Arena 1 (UL)','Arena 2 (UR)','Arena 3 (LL)','Arena r (LR)');ylimits = get(gca,'ylim');for ar=1:4    line([SecondsUntilHalfDyePattern(ar)       SecondsUntilHalfDyePattern(ar)],       ylimits,'color',colors{ar},'linestyle',':');    line([SecondsUntilDyePatternInitiation(ar) SecondsUntilDyePatternInitiation(ar)], ylimits,'color',colors{ar},'linestyle','--');endxlabel('seconds'); ylabel('dye level');title(['Dye Inititation Time = ',num2str(min(SecondsUntilDyePatternInitiation)),' , Inter Arenas Delay= ',num2str(InterArenasDelay)]);FigureFileName = [FILEPATH,'\',FigureString,'.fig'];    savefig(f,FigureFileName);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %% Assign to structures and save%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     %  assign to structuresFlowDelay.DeviceType                                = 'SB1';FlowDelay.ArenasID                                  = {'Upper left', 'Upper right', 'Lower left', 'Lower right'};FlowDelay.DelayBetweenValveAndArenas                = SecondsUntilDyePatternInitiation;                        % seconds  FlowDelay.InterArenasDelay                          = InterArenasDelay ;                                       % secondsFlowDelay.InterArenasDelay_Arenas_1and3             = InterArenasDelay_Arenas_1and3 ;                          % secondsFlowDelay.InterArenasDelay_Arenas_2and4             = InterArenasDelay_Arenas_2and4 ;                          % secondsFlowDelay.ArenaSize                                 = 15030;                % For SB1 micrometers. Distance on the X axis of a single arena: from barriers (in) to barriers (out)FlowDelay.DistanceBetweenArenas                     = 15030 + 500;          % For SB1. add length of one barrier columnFlowDelay.FlowRate_micrometerPERsec                 = FlowDelay.DistanceBetweenArenas /  FlowDelay.InterArenasDelay;  FlowDelay.FlowRate_micrometerPERsec_Arenas_1and3    = FlowDelay.DistanceBetweenArenas /  FlowDelay.InterArenasDelay_Arenas_1and3;  FlowDelay.FlowRate_micrometerPERsec_Arenas_2and4    = FlowDelay.DistanceBetweenArenas /  FlowDelay.InterArenasDelay_Arenas_2and4;  FlowDelay.DeviceDelay_Arenas_1and3                  = DyeInititationTime_Arenas_1and3;  FlowDelay.DeviceDelay_Arenas_2and4                  = DyeInititationTime_Arenas_2and4;  FlowDelay.RiseTime_InitiationTo90Percent            = RiseTime_InitiationTo90Percent;  FlowDelay.DyeStats     = DyeStats;FlowDelay.DyeStatsSlow = DyeStatsSlow;File.FlowDelay         = FlowDelay;%  SAVE and exitdisp([datestr(now), '  Saving ''ArenasDyePatterns''']);DyeFileName = [File.TrackFile(1:end-4),'_DyePatterns.mat'];File.DyeFileName = DyeFileName;save(DyeFileName, 'File','ArenasDyePatterns','ArenasDyePatterns_Xaverage','DyeFrames', ...                  'DyeStats','DyeStatsSlow','FlowDelay','PatternsOnset','PatternsOnset_Fast','PatternsOnset_Slow');     if exist('TimeShiftForAllDyeReference','var')                             disp(['NOTE!!!   Dye did not cover the arena within the ''OnlyDye'' frame window. ' ...         'Reference frame is shifted ', num2str(TimeShiftForAllDyeReference),' seconds after ''OnlyDye'' ends']);    disp(['The calculated expected delay from the flow analysis is around ',num2str( min([FlowDelay.DeviceDelay_Arenas_1and3, FlowDelay.DeviceDelay_Arenas_2and4]) ),' seconds']);    save(DyeFileName, 'LastAllDyeFrame_IndexInMatrix','TimeShiftForAllDyeReference','-append');   enddisp([datestr(now), '  Dye file saved']);returnfunction [File, Tracks] = SafeStitch_BasedOnLocation_MultiSession(File)% Concatinates all animal Tracks for each arenaFunctionName = ';StitchFiles_MultipleSessions_v01(File,arena);';   NumArenas     = File.NumArenas;File.FileNames.ConcatinatedTracks               = cell(1,NumArenas);File.FileNames.SafeStitchedTracks               = cell(1,NumArenas);File.FileNames.SegmentedTracks                  = cell(1,NumArenas);File.FileNames.SegmentedAndForcedStitchedTracks = cell(1,NumArenas);File.NumberOfTracks                             = zeros(1,NumArenas);for ar = 1:NumArenas        File.FileNames.ConcatinatedTracks{ar}               = [File.TrackFile(1:end-4),'_Concatinated_NotStitched_Arena',num2str(ar),'.mat'];    File.FileNames.SafeStitchedTracks{ar}               = [File.TrackFile(1:end-4),'_SafeStitchedTracks_Arena',num2str(ar),'.mat'];        File.FileNames.SegmentedTracks{ar}                  = [File.TrackFile(1:end-4),'_SegmentedTracks_Arena',num2str(ar),'.mat'];        File.FileNames.SegmentedAndForcedStitchedTracks{ar} = [File.TrackFile(1:end-4),'_SegmentedAndForcedStitchedTracks_Arena',num2str(ar),'.mat'];        endsave(File.StatusFile,'File','-append');  disp(['Initiating Stitching in seperate Matlab sessions. function name: ',FunctionName,char(10)]);StatusFile = File.StatusFile;load(StatusFile,'Stitched_arenas')if ~exist('Stitched_arenas','var')    Stitched_arenas = zeros(1,File.NumArenas);    save(StatusFile,'Stitched_arenas','-append');endpause(3);% Free parameters for Spawning the tracker functionsSpawnSetting.Save           = 1;  % save master workspace; slaves will loadSpawnSetting.Exit           = 0;  % don't exit from master trackerfor arena = 1:File.NumArenas    disp([datestr(now), '  spawning for arena ',int2str(arena),'/',int2str(File.NumArenas)]);    SpawnSetting.Startup = ['arena=',int2str(arena),';load(''',StatusFile, ''')', FunctionName];                                    spawn2(SpawnSetting, File.TempFolder)     pause(3);      endwhile ~all(Stitched_arenas)      disp('waiting for processors to finish stitching ');    pause(30);              load(StatusFile,'Stitched_arenas');end   disp('all arenas were stitched')disp([datestr(now),' -- Updating status file']);File.Stitched = true;save(File.StatusFile,'File','-append');        return     
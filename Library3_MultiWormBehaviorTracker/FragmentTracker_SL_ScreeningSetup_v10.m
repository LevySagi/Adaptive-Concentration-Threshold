function FragmentTracker_SL_ScreeningSetup_v10(Fragment,File)%% load 'File' if it's not provided as an input variablewhile ~exist('File','var')    try        load('inprogress.mat','File');            catch        disp('error loading ''File'', retrying in 2 seconds')        pause(2);    end           enddisp([datestr(now),'   Analyzing fragment number ',num2str(Fragment),' of the movie: ''',File.MovieName,'''']);%% InitializationSingleWormMode       = false; subplot_mode         = true;MarkerSizeForDisplay = 3;     % This is a good value when you want to look at a large field of view with all worms     MoviePath      = File.MoviePath;MovieFileNames = File.MovieFileNames;PixelSize      = File.PixelSize;              % PixelSize == # pixels per mm (1D length) FragmentFrames = File.FragmentFrames;RelevantFrames = FragmentFrames(Fragment,1):FragmentFrames(Fragment,2);t0 = clock;load (File.TrackingVariablesFile,   'Background_params','DetectionMode','AutoThreshold_params','FLUORESCENCE_STREL','FLUORESCENCE_STREL_OPEN',...                                    'MinWorm_size','MaxWorm_size','PlotFrameRate','FigHandle','TempFolder',...                                    'MAX_PerFrame_Calculation_Time','MinTrackLength','MaxSpeedForTrackLinking_mm_sec', 'MaxRelativeSizeChange', 'QuitMatlabWhenFinished', 'MidlineCalculationParams','SegmentationSettings');   % For head vs. tail detection. This will be calculated ONLY in advanced 'DetectionMode' (AddProps>=2)   PlotHeadVsTail = false;if exist('MidlineCalculationParams','var')    if isfield(MidlineCalculationParams,'DistanceAlongMidline_ForHeadvsTail')        MidlineCalculationParams.UseMidlineGrayScale_ForHeadvsTail = true;        PlotHeadVsTail = true;    else        MidlineCalculationParams.UseMidlineGrayScale_ForHeadvsTail = false;            endendfigure (FigHandle);MaxDistance = MaxSpeedForTrackLinking_mm_sec * File.PixelSize / File.FrameRate;  % File.PixelSize is actually How many pixels per mm. MaxDistance has units of pixels/frame MidlineCalculationParams.WormRealWidthInPixels = MidlineCalculationParams.WormRealWidth /1000* File.PixelSize;disp(['Detection mode: ',DetectionMode, char(10)]);if strcmpi(DetectionMode, 'AddAllProperties')    AddProps = 3;elseif strcmpi(DetectionMode, 'AddAdvancedMorphologyProperties')    AddProps = 2;elseif strcmpi(DetectionMode, 'AddBasicMorphologyProperties')    AddProps = true; else    AddProps = false;endForceOneWorm = false;if isfield(AutoThreshold_params,'ForceOneRealObject')    if AutoThreshold_params.ForceOneRealObject        ForceOneWorm   = true;        SingleWormMode = true;    endendManual_Threshold = AutoThreshold_params.UseConstantThreshold_value;   %  Threshold value when MANUAL mode is ON. Settings = single([RelevantFrames', NaN*ones(length(RelevantFrames),1), NaN*ones(length(RelevantFrames),1), NaN*ones(length(RelevantFrames),1) ]);                  if ~exist('FLUORESCENCE_STREL_OPEN','var')    % When using Mask for detecting the object: Use 'open' to get rid of noise before doing the 'close'. For RIM use ones(1);    FLUORESCENCE_STREL_OPEN  = ones(3);endthreshold_figure_handle=[];if subplot_mode    SCSZ      = get(0,'screensize');       Height    = (SCSZ(4)-50) / 4 * 0.9;    LL_Height = 50 + (SCSZ(4)-50) / size(FragmentFrames,1) * (Fragment-1);     Width     = (SCSZ(3)-20) / 4;        PositionMovieFigure         = round([20            LL_Height  Width   Height]);      PositionAutoThresholdFigure = round([30+SCSZ(3)/4  LL_Height  Width   Height]);          set(FigHandle,'position',PositionMovieFigure);    if ~isempty(threshold_figure_handle)        set(threshold_figure_handle,'position',PositionAutoThresholdFigure);    endend        if     strcmpi(File.VideoFormat,'tiff')    VideoFormat   = 1;                                  % read new file every loop iteration elseif strcmpi(File.VideoFormat,'multi-tiff')    VideoFormat   = 2;    FileFullName  = [MoviePath,'\',MovieFileNames{1}];  % one fileelseif strcmpi(File.VideoFormat,'avi')    VideoFormat   = 3;    FileFullName  = [MoviePath,'\',MovieFileNames{1}];  % one file    MovieObj      = VideoReader(FileFullName);          % one objectelseif strcmpi(File.VideoFormat,'multi-avi')    VideoFormat   = 4;    PreviousMovieObjFile = 0;                           % read new file object if and when it is needed end           %% Calculating video Background and Maskif isfield(Background_params,'UseOnlyFramesInFragement')    UseOnlyFramesInFragement = Background_params.UseOnlyFramesInFragement;else    UseOnlyFramesInFragement = false;  end if UseOnlyFramesInFragement      %%%%  background is calculated independently for each movie fragment (fluctuating background)       Background_params.StartFrame =  FragmentFrames(Fragment,1);    Background_params.EndFrame   =  FragmentFrames(Fragment,2);    if Fragment == File.Fragments     % Correct first frame for last fragement. Make sure that the background is calculated using the same number of frames...           Background_params.StartFrame = Background_params.EndFrame - FragmentFrames(1,2);    end    background = getbackground_v04(File, Background_params);        disp([datestr(now),' Background Processed for fragment ',num2str(Fragment),char(10)]);     else                             %%%%  background was already calculated based on all movie frames        try        load(File.BackgroundFile, 'background');    catch        disp('background file was not found. Re-calculating the background using all movie frames.')        background = getbackground_v04(File, Background_params);            disp([datestr(now),' Background Processed']);     end       end% Use background matrix to decide whether the data is uint8 or uint16. DEFAULT IS uint16 !!!X = whos('background'); if strcmpi(X.class,'uint8')    Use_uint8_for_patterns = true;else    Use_uint8_for_patterns = false;end%% Find worm objects in each frameTracks          = [];frame_index     = 0;Run_Regionprops_to_Filter_Noise = true;  % this will be tested and changed if needed in the FIRST loopTotalNumOfWorms = single(zeros(1,length(RelevantFrames)))*NaN;tic; c1=clock;for Frame = RelevantFrames         frame_index = frame_index+ 1;    %% Current frame analysis    % Get Frame and normalize it          switch VideoFormat        case 2                             % A single multiple-tiff file            Mov           = imread(FileFullName, Frame);             case 1                             % A sequence of tiff files            FileFullName  = [MoviePath,'\',MovieFileNames{Frame}];             Mov           = imread(FileFullName);                                  case 3                             % A single avi movie file            Mov           = read(MovieObj, Frame);                 Mov           = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!        case 4                             % A sequence of avi movie files            CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);            if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                FileFullName        = [MoviePath,'\',MovieFileNames{CurrentMovieObjFile}];                 PreviousMovieObjFile = CurrentMovieObjFile;                MovieObj             = VideoReader(FileFullName);            end            CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);            Mov                      = read(MovieObj, CurrentFrameNumberInFile);                 Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                    end               Mov = imsubtract(background,Mov);                       %% CONSTANT THRESHOLD - DEFINED MANUALLY BY USER IN THE MAIN FUNCTION    threshold = Manual_Threshold;    Mask      = [];    if frame_index==1        [STATS, AnimalPix, Run_Regionprops_to_Filter_Noise] = Detect_Worm_properties_SL_Fluor_v04 (Mov, threshold, MinWorm_size, MaxWorm_size, PixelSize, AddProps, FLUORESCENCE_STREL, Mask, FLUORESCENCE_STREL_OPEN, MidlineCalculationParams, Run_Regionprops_to_Filter_Noise);        else        [STATS, AnimalPix]                                  = Detect_Worm_properties_SL_Fluor_v04 (Mov, threshold, MinWorm_size, MaxWorm_size, PixelSize, AddProps, FLUORESCENCE_STREL, Mask, FLUORESCENCE_STREL_OPEN, MidlineCalculationParams, Run_Regionprops_to_Filter_Noise);                    end    if isempty(STATS); NUM = 0;       else               NUM = length(STATS.Area);   % Number of worm objects detected    end    if ForceOneWorm   % Single worm movie         if NUM>1      % If more then one worm was detected --> consider it as error in object detection            NUM=0;        end    end                     TotalNumOfWorms(frame_index) = single(NUM);        Settings(frame_index,:)      = single([Frame, threshold, AnimalPix, NUM]);                   %% Basic worms tracking        if NUM         % At least one worm object was found                               % Update active tracks with new coordinates        if ~isempty(Tracks)            [Tracks, WormCoordinates] = UpdateActiveTracks_Fluor (Tracks , STATS, Frame, AddProps, MaxDistance, MaxRelativeSizeChange, MinTrackLength, SingleWormMode, MidlineCalculationParams, Use_uint8_for_patterns);               % WormCoordinates will have NaNs for worms assigned to existing Tracks.         else            WormCoordinates           = STATS.Coordinates;        end        % Start new tracks for worm objects that are not assigned to existing tracks           Tracks = DefineNewTracks_Fluor (Tracks , WormCoordinates, STATS, Frame, AddProps, MidlineCalculationParams, Use_uint8_for_patterns);                end                  %% Display and memory    break_now = ProgressDisplay_and_Memory (Frame, Mov, FileFullName, Tracks, Settings(frame_index,:), FragmentFrames, Fragment, PlotFrameRate, FigHandle, TempFolder, MAX_PerFrame_Calculation_Time, PlotHeadVsTail, MarkerSizeForDisplay, frame_index) ;     if break_now  % Script is too slow        break    end        endetime(clock,c1)/60%%% Get rid of too short tracks (can only exist from the last tracks)DeleteTracks = [];for i = 1:length(Tracks)    if length(Tracks(i).Frames) < MinTrackLength        DeleteTracks = [DeleteTracks, i];    endendTracks(DeleteTracks) = [];SegmentationSettings    = File.VariablesInformation.SegmentationSettings;PlotArenasCalculation   = SegmentationSettings.PlotInfo.TracksAssociationToArenas;[Tracks, TrackArena]    = AssociateTracksToArenas_inline (Tracks, File, PlotArenasCalculation);%% SAVESaveAndUpdateStatus (File, Fragment, Settings , Tracks, background,  AddProps)  % settings contain the thresholds values that were usedt1=clock; disp(['Total cpu time for this fragment = ',num2str(etime(t1,t0)/60),char(10)])if QuitMatlabWhenFinished    quitendreturn%% inline functionsfunction background = getbackground_v04(File, Background_params)% % This function:%   Calculate the background from the median pixel levels rather than their means.    %   Uses gray scale pictures rather than a single channel.%-----------------------------------------------------------------------DirName     = File.MoviePath;FileNames   = File.MovieFileNames;FrameNum    = File.NumberOfFrames;  % This is the total number of frames in the movie, NOT the number of frames that are analyzed for background calculationMATSIZE     = File.FrameSize;if isfield(Background_params,'FrameInterval')   % Usually 50 frames    FrameInterval = Background_params.FrameInterval;else    FrameInterval = 50;endif isfield(Background_params,'method')          % mean or median over the frames?     method = Background_params.method;else    method = 'median';endif isfield(Background_params,'StartFrame')      % First frame     StartFrame = Background_params.StartFrame;else    StartFrame = 1;endif isfield(Background_params,'EndFrame')        % Last frame     EndFrame = Background_params.EndFrame;else    EndFrame = FrameNum;endif isfield(Background_params,'plot')            % plot background     plot_background = Background_params.plot;else    plot_background = false;end% Assign Movie Format Codeif     strcmpi(File.VideoFormat,'tiff')    VideoFormat   = 1;elseif strcmpi(File.VideoFormat,'multi-tiff')    VideoFormat   = 2;    FileFullName  = [DirName,'\',FileNames{1}]; elseif strcmpi(File.VideoFormat,'avi')    VideoFormat   = 3;    FileFullName  = [DirName,'\',FileNames{1}];     MovieObj      = VideoReader(FileFullName);elseif strcmpi(File.VideoFormat,'multi-avi')    VideoFormat   = 4;    PreviousMovieObjFile = 0; % read new file object if and when it is needed else    disp('unknown format. aborting @ background calculation ...');    returnenddisp(['Background calculating from ',int2str(StartFrame),' to ',int2str(EndFrame),' in increments of ',int2str(FrameInterval)]);NumOfFrames = round((EndFrame-StartFrame+1)/FrameInterval);progbars    = 10;if strcmpi(method,'median') || strcmpi(method,'percentile_10')        MaxAllowedNumOfFrames   = 100;    if NumOfFrames > MaxAllowedNumOfFrames        FrameInterval = round((EndFrame-StartFrame+1) / MaxAllowedNumOfFrames);        NumOfFrames   = round((EndFrame-StartFrame+1)/FrameInterval);        disp(['To avoid large computation time, FrameInterval is enlarged to ',int2str(FrameInterval)]);    end        cdata_mat   = uint16(zeros(MATSIZE(1),MATSIZE(2),NumOfFrames));    ind         = 0;    for Frame = StartFrame:FrameInterval:EndFrame        ind = ind+1;        % Read frame, depending on the video format        if VideoFormat==2                       % A single multiple-tiff file            Mov                = imread(FileFullName, Frame);             elseif VideoFormat==1                   % A sequence of tiff files            FileFullName       = [DirName,'\',FileNames{Frame}];             Mov                = imread(FileFullName);                                  elseif VideoFormat==3                   % A single avi movie file            Mov                = read(MovieObj, Frame);                 Mov                = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!        elseif VideoFormat==4                   % A sequence of avi movie files            CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);                        if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                FileFullName         = [DirName,'\',FileNames{CurrentMovieObjFile}];                 PreviousMovieObjFile = CurrentMovieObjFile;                MovieObj             = VideoReader(FileFullName);            end            CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);            Mov                      = read(MovieObj, CurrentFrameNumberInFile);                 Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                   end                % store frame data        cdata_mat(:,:,ind) = Mov;              if mod(Frame * progbars,(EndFrame-StartFrame+1)) < progbars*FrameInterval     % Progress bar- 10x ':'            fprintf(':');         end        end    cdata_mat = single(cdata_mat);        fprintf('\nCalculating median\n');    cdatamean       = mean(cdata_mat,3);    background_mean = uint16(round(cdatamean));    cdatamedian       = median(cdata_mat,3);    background_median = uint16(round(cdatamedian));            if strcmpi(method,'median')         background = background_median;    elseif strcmpi(method,'percentile_10')        fprintf('\nCalculating percentile [10%] \n');        % prctile returns percentiles of the values in cdata along the 3rd dimention. p is a scalar or a vector of percent values.        p                     = 10;        cdata_percentile      = prctile(double(cdata_mat),p,3);                     background_percentile = uint16(round(cdata_percentile));        background            = background_percentile;    end           if plot_background        figure('name','background');         if strcmpi(method,'percentile_10')            subplot(1,3,1); h(1)=imshow(background_mean,[]);       title('mean');               subplot(1,3,2); h(2)=imshow(background_median,[]);     title('median');             subplot(1,3,3); h(3)=imshow(background_percentile,[]); title([num2str(p),' percent']);         else            subplot(1,2,1); h(1)=imshow(background_mean,[]);       title('mean');               subplot(1,2,2); h(2)=imshow(background_median,[]);     title('median');         end                  % figure; imagesc(background_mean - background_median); colorbar; set(gca,'Clim',[0 10])    end    else   % MEAN    if ~strcmpi(method,'mean')             disp('Background calculation method is not properly defined. Using mean...');    end        MaxAllowedNumOfFrames   = 300;    if NumOfFrames > MaxAllowedNumOfFrames        FrameInterval = round((EndFrame-StartFrame+1) / MaxAllowedNumOfFrames);        NumOfFrames   = round((EndFrame-StartFrame+1)/FrameInterval);        disp(['To avoid large computation time, FrameInterval is enlarged to ',int2str(FrameInterval)]);    end        cdata_mat = single(zeros(MATSIZE));       for Frame = StartFrame:FrameInterval:EndFrame         % Read frame, depending on the video format         if VideoFormat==2                       % A single multiple-tiff file            Mov                = imread(FileFullName, Frame);             elseif VideoFormat==1                   % A sequence of tiff files            FileFullName      = [DirName,'\',FileNames{Frame}];             Mov                = imread(FileFullName);                                  elseif VideoFormat==3                   % A single avi movie file            Mov                = read(MovieObj, Frame);                 Mov                = Mov(:,:,1);                %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!        elseif VideoFormat==4                   % A sequence of avi movie files            CurrentMovieObjFile = File.MultiAviFrameConversion.MovieFileNumber(Frame);            if (PreviousMovieObjFile ~= CurrentMovieObjFile)        % create a new file object if necessary                FileFullName        = [DirName,'\',FileNames{CurrentMovieObjFile}];                 PreviousMovieObjFile = CurrentMovieObjFile;                MovieObj             = VideoReader(FileFullName);            end            CurrentFrameNumberInFile = File.MultiAviFrameConversion.FrameNumberInFile(Frame);            Mov                      = read(MovieObj, CurrentFrameNumberInFile);                 Mov                      = Mov(:,:,1);          %%%% assuming 3 channel movie !!!!!!!!!!!!!!!!!!                                   end                % Add to previous frames        cdata_mat     = cdata_mat + single(Mov);        if mod(Frame * progbars,(EndFrame-StartFrame+1)) < progbars*FrameInterval     % Progress bar- 10x ':'            fprintf(':');         end        end    background = uint16(cdata_mat/NumOfFrames);    fprintf('\n');    if plot_background        figure('name','background (mean)');         imshow (background,[]);  set(gca,'Clim',[0 255]); title('mean');   colorbar    endend% Transfer background to uint8 if movie was in uint8 formatX=whos('Mov'); CLASS = X.class;if strcmpi(CLASS,'uint8')    background = uint8(background);end%the following is necessary only if you want to save background image for later re-analysisif Background_params.save       [FileName,PathName] = uiputfile('*.bmp', 'Save Background Image');    if FileName ~= 0        imwrite(uint8(background),[PathName, FileName], 'bmp');    endend% imshow(background);returnfunction [Worm_PROPS, AnimalPix, Run_Regionprops_to_Filter_Noise]  = Detect_Worm_properties_SL_Fluor_v04 (MAT, threshold, MinWorm_size, MaxWorm_size, Pixels_per_mm, AddProps, FLUORESCENCE_STREL, Mask, FLUORESCENCE_STREL_OPEN, MidlineCalculationParams, Run_Regionprops_to_Filter_Noise)% The image in MAT is used to find worms with:%   signals > threshold %   area    > MinWorm_size %   area    < MaxWorm_size % Properties of worms are returned in 'Worm_PROPS'  % Properties of objects that may be colliding worms (area > MaxWorm_size) are returned in 'LargeObjects'     % AddProps: false=basic worm parameters, true= additional morphology parameters (slower), 2= add also midline and possibly head vs. tail. 3= add full gray scale pattern matrices in the worm's coordinate system.   BW = im2bw(MAT,threshold);if exist('Mask','var') % generate a BW only with the worm object and reduce noise by imopen with a small strel.    if ~isempty(Mask)        MAT(~Mask)=0;        BW = im2bw(MAT,threshold);        PROPS                  = regionprops(BW,'Area','PixelIdxList');        [~,MaxSizeObjectIndex] = max([PROPS.Area]);        PixelIdx_of_MaxSizeObject =  PROPS(MaxSizeObjectIndex).PixelIdxList;        BW_old = BW;         BW     = false(size(BW));        BW(PixelIdx_of_MaxSizeObject) = BW_old(PixelIdx_of_MaxSizeObject);         BW     = imopen(BW, FLUORESCENCE_STREL_OPEN);               endendBW = imclose(BW,FLUORESCENCE_STREL);if isempty(MinWorm_size)        MinWorm_size   = 0.04;       % Defined in mm^2    endif isempty(MaxWorm_size)        MaxWorm_size   = 0.1;        % Defined in mm^2    endMinWorm_NumOfPixels = MinWorm_size* (Pixels_per_mm^2);     % Pixels_per_mm correponds to the LINEAR dimension of a pixel MaxWorm_NumOfPixels = MaxWorm_size* (Pixels_per_mm^2);     % Pixels_per_mm correponds to the LINEAR dimension of a pixel if Run_Regionprops_to_Filter_Noise    % this check is done ONCE only at the first frame    PROPS        = regionprops(BW,'Area','PixelIdxList');    objsize      = [PROPS.Area];    not_worm_obj = union(find(objsize < MinWorm_NumOfPixels), find(objsize > MaxWorm_NumOfPixels));  % Find large enough objects that are not too large        if length(not_worm_obj) > 1e3   % if there are too many non worms objects, it is better to eliminate them before calculating object proprties         not_worm_pixels = vertcat(PROPS(not_worm_obj).PixelIdxList);          BW(not_worm_pixels)=false;      else        Run_Regionprops_to_Filter_Noise = false    end        end% The function below is highly time-consuming PROPS       = regionprops(BW,'area','PixelIdxList','Centroid', 'Eccentricity', 'MajorAxisLength', 'MinorAxisLength', ...                             'Orientation', 'Image', 'BoundingBox');objsize     = [PROPS.Area];worm_obj    = setdiff(find(objsize > MinWorm_NumOfPixels), find(objsize > MaxWorm_NumOfPixels));  % Find large enough objects that are not too largeWorm_PROPS  = ReduceStructure (PROPS , worm_obj);if AddProps    Worm_PROPS  = AddBasicMorphologyPatterns (Worm_PROPS   , size(BW));endif (AddProps==2)||(AddProps==3)     % Advanced morphology features (midline and head vs. tail), if AddProps==3: add full worm patterns in the worms' coordinate system.      Worm_PROPS  = Add_GrayScale_Midline_and_RelativeCoordinates_Info (Worm_PROPS, MAT, MidlineCalculationParams, AddProps);                                                                              endAnimalPix = mean([Worm_PROPS.Area]);%% Optional Plots% toc% BW_Matrix = Create_BW_Matrix_from_images(Worm_PROPS, size(BW));% BW_Matrix = Create_BW_Matrix_from_PixelsList(Worm_PROPS, size(BW),'PixelIdxList');% BW_Matrix = Create_BW_Matrix_from_PixelsList(Worm_PROPS, size(BW),'Skeleton_PixelIdxList');% BW_Matrix = Create_BW_Matrix_from_PixelsList(Worm_PROPS, size(BW),'HeadTail_PixelIdxList');% BW_Matrix = Create_BW_Matrix_from_PixelsList(Worm_PROPS, size(BW),'Perimeter_PixelIdxList');% BW_Matrix = Create_BW_Matrix_from_PixelsList(Worm_PROPS, size(BW),'PixelIdxList');% Plot_PixelList_on_Frame(Worm_PROPS, size(BW), 'Perimeter_PixelIdxList', [], 'g')% Plot_PixelList_on_Frame(Worm_PROPS, size(BW), 'Skeleton_PixelIdxList', [], 'k')% Plot_PixelList_on_Frame(Worm_PROPS, size(BW), 'HeadTail_PixelIdxList', [], 'k')% figure; imshow(MAT,[])% Plot_PixelList_on_Frame(Worm_PROPS, size(BW), 'PixelIdxList', [], 'g')% Plot_PixelList_on_Frame(Worm_PROPS, size(BW), 'Perimeter_PixelIdxList', [], 'c')% Plot_PixelList_on_Frame(Worm_PROPS, size(BW), 'InnerPerimeter_PixelIdxList', [], 'r')% Plot_PixelList_on_Frame(Worm_PROPS, size(BW), 'Skeleton_PixelIdxList', [], 'm')% Plot_PixelList_on_Frame(Worm_PROPS, size(BW), 'HeadTail_PixelIdxList', [], 'm')returnfunction ReducedStructure  = ReduceStructure (Structure , RelevantIndices)if isempty(RelevantIndices)    ReducedStructure=[];    returnendReducedStructure.Area            = uint16([Structure(RelevantIndices).Area]);ReducedStructure.Eccentricity    = single([Structure(RelevantIndices).Eccentricity]);ReducedStructure.MajorAxisLength = single([Structure(RelevantIndices).MajorAxisLength]);ReducedStructure.MinorAxisLength = single([Structure(RelevantIndices).MinorAxisLength]);ReducedStructure.Orientation     = single([Structure(RelevantIndices).Orientation]);% Finding [x y] coordinates. These X and Y's correspond to what you see in imagesc BUT NOT TO THE DIMENSIONS OF Matdiv !!  NumWorms                         = single(length(RelevantIndices));WormBox                          = [Structure(RelevantIndices).BoundingBox];ReducedStructure.BoundingBox     = single([WormBox(1:4:4*NumWorms)', WormBox(2:4:4*NumWorms)']);            % Upper-Left corner of the bounding boxWormCentroid                     = [Structure(RelevantIndices).Centroid];ReducedStructure.Centroid        = single(WormCentroid);  ReducedStructure.Coordinates     = single([WormCentroid(1:2:2*NumWorms)', WormCentroid(2:2:2*NumWorms)']) ; % Centroid for wi = 1:length(RelevantIndices)    ReducedStructure.Image{wi}        = Structure(RelevantIndices(wi)).Image;        % BW image. Check syntax !!    ReducedStructure.PixelIdxList{wi} = single(Structure(RelevantIndices(wi)).PixelIdxList); % Centroid endreturnfunction Worm_PROPS  = AddBasicMorphologyPatterns (Worm_PROPS_in, OriginalFrameSize)  % Here I corrected the skeleton representation by eliminating the 'spurs'.% The price: a loop...% OriginalFrameSize == Original Image SizeWorm_PROPS = Worm_PROPS_in;if isempty(Worm_PROPS)    returnendNumWorms = length(Worm_PROPS.Area);% LinearIndices are saved: Global= full image,  Local= single worm image.   WormArea.Xcoordinate             = cell(1,NumWorms);WormArea.Ycoordinate             = cell(1,NumWorms);WormArea.LinearIndices           = Worm_PROPS.PixelIdxList;WormLengths                      = uint16(zeros(1,NumWorms));WormPerimeterLengths             = uint16(zeros(1,NumWorms));WormSkeleton.Xcoordinate         = cell(1,NumWorms);WormSkeleton.Ycoordinate         = cell(1,NumWorms);WormSkeleton.LinearIndices       = cell(1,NumWorms);WormPerimeter.Xcoordinate        = cell(1,NumWorms);WormPerimeter.Ycoordinate        = cell(1,NumWorms);WormPerimeter.LinearIndices      = cell(1,NumWorms);for wi = 1:length(Worm_PROPS.Area)    % XY coordinates of the worm area    [AreaPixels.X, AreaPixels.Y] = ind2sub(OriginalFrameSize,Worm_PROPS.PixelIdxList{wi});    WormArea.Xcoordinate{wi}   = uint16(AreaPixels.X);    WormArea.Ycoordinate{wi}   = uint16(AreaPixels.Y);        IM                        = Worm_PROPS.Image{wi};          % BW image    UpperLeft_Coordinate_Dim2 = Worm_PROPS.BoundingBox(wi,1)-0.5;      UpperLeft_Coordinate_Dim1 = Worm_PROPS.BoundingBox(wi,2)-0.5;          %%% Find properties...    BW_thin             = bwmorph(IM,'thin',inf);    BW_endpoints        = bwmorph(BW_thin,'endpoints',inf);               % End points    [I_all ,J_all]      = find(BW_endpoints==1);           NumOfEndPoints      = length(I_all);    if NumOfEndPoints == 0       % e.g. for a circular worm object        continue;    end    % Correct Skeleton if more than 2 endpoints were found:    counter=0;    while NumOfEndPoints>2         counter = counter+1;        % Find spur endpoints (that are 'in the middle' of the skeleton)        Distances = zeros(NumOfEndPoints);        for n=1:NumOfEndPoints            Distances (n,:)= sqrt((I_all-I_all(n)).^2 + (J_all-J_all(n)).^2);        end        [row col]         = find(Distances==max(Distances(:)));        indices           = [row(1) col(1)];  % The real endpoints         Indices_to_reject = setdiff (1:NumOfEndPoints, indices);        I_reject          = I_all(Indices_to_reject);        J_reject          = J_all(Indices_to_reject);                % Correct BW_thin and recalculate the endpoints        for rej_ind = 1:length(I_reject)            BW_thin(I_reject(rej_ind),J_reject(rej_ind)) = false;         end        [I_all ,J_all]      = find(bwmorph(BW_thin,'endpoints',inf)==1);               NumOfEndPoints      = length(I_all);        if counter>100%             disp(['Stopping while loop for skeleton correction', char(10)]);            break        end    end            % Skeleton    [I_thin,J_thin]     = find(BW_thin==1);          WormLengths(wi)     = length(I_thin);        Coordinates         = [J_thin + UpperLeft_Coordinate_Dim2, I_thin + UpperLeft_Coordinate_Dim1];   % Matrix of [x y] locations of the skeleton      WormSkeleton.Xcoordinate{wi}   = uint16(Coordinates(:,2));              WormSkeleton.Ycoordinate{wi}   = uint16(Coordinates(:,1));        WormSkeleton.LinearIndices{wi} = single(sub2ind(OriginalFrameSize, double(WormSkeleton.Xcoordinate{wi}), double(WormSkeleton.Ycoordinate{wi})));          % Perimeter - outer    row     = 1;    col     = find(IM(row,:),1,'first');        CONTOUR = bwtraceboundary(IM, [row, col],'E');    I_perim = CONTOUR(:,1);     J_perim = CONTOUR(:,2);    WormPerimeterLengths(wi)     = length(I_perim);        Coordinates         = [J_perim + UpperLeft_Coordinate_Dim2, I_perim + UpperLeft_Coordinate_Dim1]; % Matrix of [x y] locations of the perimeter           WormPerimeter.Xcoordinate{wi}   = uint16(Coordinates(:,2));              WormPerimeter.Ycoordinate{wi}   = uint16(Coordinates(:,1));        WormPerimeter.LinearIndices{wi} = single(sub2ind(OriginalFrameSize, double(WormPerimeter.Xcoordinate{wi}), double(WormPerimeter.Ycoordinate{wi})));  endWorm_PROPS.WormArea        = WormArea;Worm_PROPS.SkeletonLength  = uint16(WormLengths);Worm_PROPS.PerimeterLength = uint16(WormPerimeterLengths);Worm_PROPS.WormSkeleton    = WormSkeleton;Worm_PROPS.WormPerimeter   = WormPerimeter;returnfunction Worm_PROPS  = Add_GrayScale_Midline_and_RelativeCoordinates_Info (Worm_PROPS, MAT, MidlineCalculationParams, AddProps)if isempty(Worm_PROPS)    returnendImageSize = size(MAT);%% Store gray scale informationNumWorms                  = length(Worm_PROPS.Area);Worm_PROPS.PatternValues  = cell(1,NumWorms);for wi = 1:NumWorms        Worm_PROPS.PatternValues{wi} = MAT(Worm_PROPS.PixelIdxList{wi});  % corresponding to the coordinates given at 'Worm_PROPS.WormArea.Xcoordinate' and 'Worm_PROPS.WormArea.Ycoordinate' end%% Calculate midline coordinates, head vs. tail coordinates and pattern matrix in the worms' coordinate system  Worm_PROPS.Midline.Length               = Worm_PROPS.SkeletonLength;Worm_PROPS.Midline.X_coordinates_short  = cell(1,NumWorms);Worm_PROPS.Midline.Y_coordinates_short  = cell(1,NumWorms);Worm_PROPS.Midline.X_coordinates        = cell(1,NumWorms);Worm_PROPS.Midline.Y_coordinates        = cell(1,NumWorms);Worm_PROPS.Midline.FlagTrueIfReliable   = false(1,NumWorms);Worm_PROPS.HeadTail                     = single(zeros(NumWorms,2,2));if AddProps ==3       Worm_PROPS.Midline.Angle                = cell(1,NumWorms);    Worm_PROPS.WormCoordinates.Length       = cell(1,NumWorms);    Worm_PROPS.WormCoordinates.Width        = cell(1,NumWorms);    Worm_PROPS.PatternMatrix                = cell(1,NumWorms);endfor wi = 1:NumWorms    Skeleton_LinearIndices  = double(Worm_PROPS.WormSkeleton.LinearIndices{wi});          if ~isempty(Skeleton_LinearIndices) && (length(Skeleton_LinearIndices)>2)  % Midline of at least 3 pixels!!        if AddProps==2                        [Midline, HeadTail] = ExtractPositionMatrix (Skeleton_LinearIndices, ImageSize, MidlineCalculationParams, AddProps);   % ~22 msec            Midline.Pattern     = MAT(round(Midline.LinearIndices));                       elseif AddProps==3            [Midline, HeadTail, PositionMatX, PositionMatY] = ExtractPositionMatrix (Skeleton_LinearIndices, ImageSize, MidlineCalculationParams, AddProps);   % ~22 msec            Midline.Pattern                                 = MAT(round(Midline.LinearIndices));                                       %% FOR PATTERN RECOGNITION - this part is time-limiting (interp2~70msec and loop). ~140 msec            AreaIndices.X           = single(Worm_PROPS.WormArea.Xcoordinate{wi});                                                                                        AreaIndices.Y           = single(Worm_PROPS.WormArea.Ycoordinate{wi});                                                          WormCoordinates.Length  = single(zeros(size(AreaIndices.X)));            WormCoordinates.Width   = single(zeros(size(AreaIndices.X)));            Indices                 = single(zeros(1,length(AreaIndices.X)));    % indices in the midline vector where the midline is closest to the pixel.            PatternMatrix           = interp2(1:ImageSize(2), 1:ImageSize(1), double(MAT), PositionMatY, PositionMatX, 'linear');             for pix_ind = 1:length(AreaIndices.X)                   %                 DistanceFromMidline = sqrt((Midline.X_coordinates - AreaIndices.X(pix_ind)).^2 + (Midline.Y_coordinates - AreaIndices.Y(pix_ind)).^2);                [min_val, min_ind]  = min(DistanceFromMidline);                Indices(pix_ind)    = min_ind;                WormCoordinates.Width(pix_ind)  = min_val;                WormCoordinates.Length(pix_ind) = min_ind / MidlineCalculationParams.WormMatrixLength * length(Midline.X_coordinates_short)  ;   % This is the index in the LONG VECTOR THAT WAS OVER SAMPLED!!!!            end            % below the midline switch width coordinates to negative values             ClosestMidlineLocation.X        = Midline.X_coordinates(Indices)';            ClosestMidlineLocation.Y        = Midline.Y_coordinates(Indices)';            Angle_PixRelativeToMidline      = atan2((AreaIndices.Y - ClosestMidlineLocation.Y),(AreaIndices.X - ClosestMidlineLocation.X))/pi*180;            MidlineAngle_at_ClosestLocation = Midline.Angle(Indices)';            AboveMidlineIndices             = Angle_PixRelativeToMidline>MidlineAngle_at_ClosestLocation;            WormCoordinates.Width(~AboveMidlineIndices) = -WormCoordinates.Width(~AboveMidlineIndices);        end                %% assign values to output structure        Worm_PROPS.Midline.X_coordinates_short{wi} = Midline.X_coordinates_short;         Worm_PROPS.Midline.Y_coordinates_short{wi} = Midline.Y_coordinates_short;         Worm_PROPS.Midline.LinearIndices{wi}       = Midline.LinearIndices;         Worm_PROPS.Midline.Pattern{wi}             = Midline.Pattern;         Worm_PROPS.Midline.X_coordinates{wi}       = Midline.X_coordinates;         Worm_PROPS.Midline.Y_coordinates{wi}       = Midline.Y_coordinates;         Worm_PROPS.Midline.FlagTrueIfReliable(wi)  = Midline.Flag;                Worm_PROPS.HeadTail(wi,:,:)                = HeadTail;                if AddProps==3            Worm_PROPS.Midline.Angle{wi}               = Midline.Angle;             Worm_PROPS.WormCoordinates.Length{wi}      = WormCoordinates.Length;            Worm_PROPS.WormCoordinates.Width{wi}       = WormCoordinates.Width;            Worm_PROPS.PatternMatrix{wi}               = uint16(PatternMatrix);        end                    else        % If the worm skeleton was not found- assign empty vectors and NaNs.           Worm_PROPS.Midline.X_coordinates_short{wi} = [];         Worm_PROPS.Midline.Y_coordinates_short{wi} = [];         Worm_PROPS.Midline.LinearIndices{wi}       = [];         Worm_PROPS.Midline.Pattern{wi}             = [];         Worm_PROPS.Midline.X_coordinates{wi}       = [];         Worm_PROPS.Midline.Y_coordinates{wi}       = [];         Worm_PROPS.Midline.FlagTrueIfReliable(wi)  = false;                Worm_PROPS.HeadTail(wi,:,:)                = single(zeros(2))*NaN;                if AddProps==3            Worm_PROPS.Midline.Angle{wi}               = [];             Worm_PROPS.WormCoordinates.Length{wi}      = [];            Worm_PROPS.WormCoordinates.Width{wi}       = [];            Worm_PROPS.PatternMatrix{wi}               = [];        end    end        end% Distinguish the head vs. the tail using the gray scale along the midline axis. Limits are given by the user.  if MidlineCalculationParams.UseMidlineGrayScale_ForHeadvsTail       [Worm_PROPS.Midline, Worm_PROPS.HeadTail] = Find_HeadVsTail_And_MidlineAngleProperties (Worm_PROPS.Midline, Worm_PROPS.HeadTail, MidlineCalculationParams);endreturnfunction [Midline, HeadTail] = Find_HeadVsTail_And_MidlineAngleProperties (Midline, HeadTail, MidlineCalculationParams) %% Input/Output arguments:% 'Midline' is a structure imbedded in the 'Worm_PROPS' structure, where each of each subfields is a cell array of length (NumOfWorms).   % With 'wi' being the worm index, each cell contains a vector as indicated by its name: %         Midline.X_coordinates_short{wi} %         Midline.Y_coordinates_short{wi} %         Midline.LinearIndices{wi}       %         Midline.Pattern{wi}           %         Midline.X_coordinates{wi}      %         Midline.Y_coordinates{wi}       %         Midline.Angle{wi}              %         Midline.FlagTrueIfReliable(wi) %% HeadTail is a 3D matrix of size (NumOfWorms,2,2)% With 'wi' being the worm index %        HeadTail(wi,1,:) contains the [X Y] coordinates of the FIRST  midline edge %        HeadTail(wi,2,:) contains the [X Y] coordinates of the SECOND midline edge %% This function calculates the head and tail coordinates based on the grey scale along the midline near the edges.% The output arguments are the same but now all vectors in all fields of 'Midline' as well as the 'HeadTail' matrix are %     *******   ALIGNED TO START FROM HEAD AND FINISH AT THE TAIL *******%%  Call this function from the function 'Add_GrayScale_Midline_and_RelativeCoordinates_Info'   %      e.g. [Worm_PROPS.Midline, Worm_PROPS.HeadTail] = Find_Head_vs_Tail (Worm_PROPS.Midline, Worm_PROPS.HeadTail, DistancesFromEdges);DistancesFromEdges  = MidlineCalculationParams.DistanceAlongMidline_ForHeadvsTail;HeadTail_in    = HeadTail;NumOfWorms     = length(Midline.Length);MidlineLengths = single(Midline.Length); FirstPixels    = round(MidlineLengths*DistancesFromEdges(1));LastPixels     = round(MidlineLengths*DistancesFromEdges(2));FirstPixels(FirstPixels==0)=1;for wi=1:NumOfWorms    indices = FirstPixels(wi):LastPixels(wi);    if Midline.FlagTrueIfReliable(wi)        % Test if the pattern at the beginning of the midline is Brighter than the pattern at its ending. This is an indication the head and tail are switched.         Beginning_BrighterThan_Ending =   mean(Midline.Pattern{wi}(indices))  >  mean(Midline.Pattern{wi}(end-indices+1))   ;        if Beginning_BrighterThan_Ending                      Midline.X_coordinates{wi}       =  Midline.X_coordinates{wi}(end:-1:1);            Midline.Y_coordinates{wi}       =  Midline.Y_coordinates{wi}(end:-1:1);            Midline.X_coordinates_short{wi} =  Midline.X_coordinates_short{wi}(end:-1:1);            Midline.Y_coordinates_short{wi} =  Midline.Y_coordinates_short{wi}(end:-1:1);            Midline.LinearIndices{wi}       =  Midline.LinearIndices{wi}(end:-1:1);            Midline.Pattern{wi}             =  Midline.Pattern{wi}(end:-1:1);            HeadTail(wi,1,:)                =  HeadTail_in(wi,2,:);            HeadTail(wi,2,:)                =  HeadTail_in(wi,1,:);                               end          end    end% %% Calculated midline angles (including head and tail alignments), and number of bendsMidline = CaluclateMidlineProperties(Midline, MidlineCalculationParams);returnfunction [Tracks, WormCoordinates] = UpdateActiveTracks_Fluor (Tracks_in , STATS, Frame, AddProps, MaxDistance, MaxRelativeSizeChange, MinTrackLength, SingleWormMode, MidlineCalculationParams, Use_uint8_for_patterns)% SingleWormMode = optional parameter = If exists and true, it assumes only one worm in the movie.   %                  and therefore FORCES continuation of the active track regardless of distance and size.  Constrain_Linkage = false;if exist('SingleWormMode','var')    if SingleWormMode        Constrain_Linkage = true;    endendTracks           = Tracks_in;ActiveTracks     = find([Tracks.Active]);if ~isempty(STATS)    WormCoordinates  = STATS.Coordinates;else    WormCoordinates = [NaN NaN];end% Update active tracks with new coordinatesfor i = 1:length(ActiveTracks)    track_ind = ActiveTracks(i);        DistanceX = WormCoordinates(:,1) - Tracks(track_ind).LastCoordinates(1);    DistanceY = WormCoordinates(:,2) - Tracks(track_ind).LastCoordinates(2);    Distance  = sqrt(DistanceX.^2 + DistanceY.^2);                                % Distance b/w each worm in this frame to the objects from the previous one    [MinVal, MinIndex] = min(Distance);                                           % Object with the minimal distance        condition = (MinVal <= MaxDistance) && ( abs( STATS.Area(MinIndex) - Tracks(track_ind).LastSize )/Tracks(track_ind).LastSize < (MaxRelativeSizeChange/100) );      if condition || Constrain_Linkage        % very small distance AND similar worm area.  I NEED TO CHECK THE FALSE POSITIVE RATE!        Tracks(track_ind).Path            = [Tracks(track_ind).Path;         WormCoordinates(MinIndex, :)];        Tracks(track_ind).LastCoordinates = WormCoordinates(MinIndex,:);        Tracks(track_ind).Frames          = single([Tracks(track_ind).Frames,       Frame]);        Tracks(track_ind).Size            = [Tracks(track_ind).Size,         STATS.Area(MinIndex)];        Tracks(track_ind).LastSize        = STATS.Area(MinIndex);        Tracks(track_ind).Eccentricity    = [Tracks(track_ind).Eccentricity, STATS.Eccentricity(MinIndex)];        Tracks(track_ind).MajorAxes       = [Tracks(track_ind).MajorAxes   , STATS.MajorAxisLength(MinIndex)];        Tracks(track_ind).MinorAxes       = [Tracks(track_ind).MinorAxes   , STATS.MinorAxisLength(MinIndex)];        Tracks(track_ind).Orientation     = [Tracks(track_ind).Orientation , STATS.Orientation(MinIndex)];        Tracks(track_ind).Box             = [Tracks(track_ind).Box;          STATS.BoundingBox(MinIndex,:)];        TrackFrameNum                     = length(Tracks(track_ind).Size);        Tracks(track_ind).TrackLength     = single(TrackFrameNum);                Tracks(track_ind).Frame(TrackFrameNum).Image = STATS.Image(MinIndex);                if AddProps            Tracks(track_ind).WormArea.Xcoordinate(TrackFrameNum)       = STATS.WormArea.Xcoordinate(MinIndex);                 % vector of coordinates per worm per frame            Tracks(track_ind).WormArea.Ycoordinate(TrackFrameNum)       = STATS.WormArea.Ycoordinate(MinIndex);                 % vector of coordinates per worm per frame                       Tracks(track_ind).WormArea.LinearIndices(TrackFrameNum)     = STATS.WormArea.LinearIndices(MinIndex);               % vector of coordinates per worm per frame                       Tracks(track_ind).SkeletonLength                            = [Tracks(track_ind).SkeletonLength,   STATS.SkeletonLength(MinIndex)] ;            Tracks(track_ind).PerimeterLength                           = [Tracks(track_ind).PerimeterLength,  STATS.PerimeterLength(MinIndex)] ;            Tracks(track_ind).WormPerimeter.Xcoordinate(TrackFrameNum)  = STATS.WormPerimeter.Xcoordinate(MinIndex);            % vector of indices per worm per frame            Tracks(track_ind).WormPerimeter.Ycoordinate(TrackFrameNum)  = STATS.WormPerimeter.Ycoordinate(MinIndex);            % vector of indices per worm per frame                           Tracks(track_ind).WormPerimeter.LinearIndices(TrackFrameNum)= STATS.WormPerimeter.LinearIndices(MinIndex);          % vector of indices per worm per frame                                       if AddProps>=2                Tracks(track_ind).PatternValues(TrackFrameNum)                  = STATS.PatternValues(MinIndex);                % vector per worm per frame                Tracks(track_ind).Midline.X_coordinates_short(TrackFrameNum)    = STATS.Midline.X_coordinates_short(MinIndex);  % vector per worm per frame                Tracks(track_ind).Midline.Y_coordinates_short(TrackFrameNum)    = STATS.Midline.Y_coordinates_short(MinIndex);  % vector per worm per frame                Tracks(track_ind).Midline.LinearIndices(TrackFrameNum)          = STATS.Midline.LinearIndices(MinIndex);        % vector per worm per frame                Tracks(track_ind).Midline.Pattern(TrackFrameNum)                = STATS.Midline.Pattern(MinIndex);              % vector per worm per frame                Tracks(track_ind).Midline.X_coordinates(TrackFrameNum)          = STATS.Midline.X_coordinates(MinIndex);        % vector per worm per frame                Tracks(track_ind).Midline.Y_coordinates(TrackFrameNum)          = STATS.Midline.Y_coordinates(MinIndex);        % vector per worm per frame                Tracks(track_ind).Midline.Angle(TrackFrameNum)                  = STATS.Midline.Angle(MinIndex);                % vector per worm per frame                         Tracks(track_ind).Midline.AngleFirstPoint(TrackFrameNum)        = STATS.Midline.AngleFirstPoint(MinIndex);      % vector per worm per frame                            Tracks(track_ind).Midline.AngleLastPoint(TrackFrameNum)         = STATS.Midline.AngleLastPoint(MinIndex);       % vector per worm per frame                            Tracks(track_ind).Midline.NumOfBends_HighRes(TrackFrameNum)     = STATS.Midline.NumOfBends_HighRes(MinIndex);   % vector per worm per frame                            Tracks(track_ind).Midline.NumOfBends_LowRes(TrackFrameNum)      = STATS.Midline.NumOfBends_LowRes(MinIndex);    % vector per worm per frame                                             Tracks(track_ind).Midline.FlagTrueIfReliable(TrackFrameNum)     = STATS.Midline.FlagTrueIfReliable(MinIndex);   % one logical value per worm per frame                                Tracks(track_ind).HeadTail(TrackFrameNum,:,:)                   = squeeze(STATS.HeadTail(MinIndex,:,:));        % 2x2 matrix per worm per frame: first row=head, second is tail.                                                           if AddProps == 3                    Tracks(track_ind).WormCoordinates.Length(TrackFrameNum) = STATS.WormCoordinates.Length(MinIndex);        % vector per worm per frame                    Tracks(track_ind).WormCoordinates.Width(TrackFrameNum)  = STATS.WormCoordinates.Width(MinIndex);         % vector per worm per frame                    if Tracks(track_ind).Midline.FlagTrueIfReliable(TrackFrameNum)                        if Use_uint8_for_patterns                            Tracks(track_ind).PatternMatrix(TrackFrameNum,:,:)  = uint8(STATS.PatternMatrix{MinIndex});      % Matrix per worm per frame                                                                     else                                                    Tracks(track_ind).PatternMatrix(TrackFrameNum,:,:)  = STATS.PatternMatrix{MinIndex};             % Matrix per worm per frame                                                                     end                    else  % If no pattern was found due to midline problems                        if Use_uint8_for_patterns                            Tracks(track_ind).PatternMatrix(TrackFrameNum,:,:)  = uint8(zeros(MidlineCalculationParams.WormMatrixWidth, MidlineCalculationParams.WormMatrixLength));  %  Matrix per worm per frame                                                        else                                Tracks(track_ind).PatternMatrix(TrackFrameNum,:,:)  = uint16(zeros(MidlineCalculationParams.WormMatrixWidth, MidlineCalculationParams.WormMatrixLength));  % Matrix per worm per frame                                                        end                    end                end                            else   % If midline was not calculated, at least store the basic 'skeleton' information.                Tracks(track_ind).WormSkeleton.Xcoordinate(TrackFrameNum)   = STATS.WormSkeleton.Xcoordinate(MinIndex);             % vector of indices per worm per frame                Tracks(track_ind).WormSkeleton.Ycoordinate(TrackFrameNum)   = STATS.WormSkeleton.Ycoordinate(MinIndex);             % vector of indices per worm per frame                Tracks(track_ind).WormSkeleton.LinearIndices(TrackFrameNum) = STATS.WormSkeleton.LinearIndices(MinIndex);           % vector of indices per worm per frame            end        end        WormCoordinates(MinIndex,:) = NaN;            else              % Current Track (track_ind) cannot be connected to any new worm object          Tracks(track_ind).Active = 0;                             % --> End of track                if length(Tracks(track_ind).Frames) < MinTrackLength      % Delete track if too short            Tracks(track_ind) = [];                                           ActiveTracks      = ActiveTracks - 1;     % Reduce indices stored in 'ActiveTracks' since the structure 'Tracks' was shrunk by one         end    endendreturnfunction Tracks = DefineNewTracks_Fluor (Tracks_in , WormCoordinates, STATS, Frame, AddProps, MidlineCalculationParams, Use_uint8_for_patterns)Tracks         = Tracks_in;NumTracks      = length(Tracks);Worm_indices   = find(isfinite(WormCoordinates(:,1)))';   % Find worms which were not previously assigned to an existing track.  NumOfNewTracks = length(Worm_indices);Tracks_Indices = NumTracks + (1:NumOfNewTracks);for i = 1:NumOfNewTracks    worm_ind  = Worm_indices(i);    track_ind = Tracks_Indices(i);    Tracks(track_ind).Active            = 1;    Tracks(track_ind).Path              = single(WormCoordinates(worm_ind,:));    Tracks(track_ind).LastCoordinates   = single(WormCoordinates(worm_ind,:));    Tracks(track_ind).Frames            = single(Frame);    Tracks(track_ind).Size              = uint16(STATS.Area(worm_ind));    Tracks(track_ind).LastSize          = uint16(STATS.Area(worm_ind));    Tracks(track_ind).Eccentricity      = single(STATS.Eccentricity(worm_ind));    Tracks(track_ind).MajorAxes         = single(STATS.MajorAxisLength(worm_ind));    Tracks(track_ind).MinorAxes         = single(STATS.MinorAxisLength(worm_ind));    Tracks(track_ind).Orientation       = single(STATS.Orientation(worm_ind));    Tracks(track_ind).Box               = single(STATS.BoundingBox(worm_ind,:));    Tracks(track_ind).Frame(1).Image    = STATS.Image(worm_ind);    Tracks(track_ind).TrackLength       = single(1);        if AddProps        Tracks(track_ind).WormArea.Xcoordinate(1)        = STATS.WormArea.Xcoordinate(worm_ind);            % vector of coordinates per worm per frame        Tracks(track_ind).WormArea.Ycoordinate(1)        = STATS.WormArea.Ycoordinate(worm_ind);            % vector of coordinates per worm per frame                           Tracks(track_ind).WormArea.LinearIndices(1)      = STATS.WormArea.LinearIndices(worm_ind);          % vector of coordinates per worm per frame                           Tracks(track_ind).SkeletonLength                 = STATS.SkeletonLength(worm_ind);        Tracks(track_ind).PerimeterLength                = STATS.PerimeterLength(worm_ind);        Tracks(track_ind).WormPerimeter.Xcoordinate(1)   = STATS.WormPerimeter.Xcoordinate(worm_ind);       % vector of indices per worm per frame        Tracks(track_ind).WormPerimeter.Ycoordinate(1)   = STATS.WormPerimeter.Ycoordinate(worm_ind);       % vector of indices per worm per frame                       Tracks(track_ind).WormPerimeter.LinearIndices(1) = STATS.WormPerimeter.LinearIndices(worm_ind);     % vector of indices per worm per frame                       if AddProps >= 2                 Tracks(track_ind).PatternValues(1)                  = STATS.PatternValues(worm_ind);                    % vector per worm per frame                        Tracks(track_ind).Midline.X_coordinates_short(1)    = STATS.Midline.X_coordinates_short(worm_ind);      % vector per worm per frame            Tracks(track_ind).Midline.Y_coordinates_short(1)    = STATS.Midline.Y_coordinates_short(worm_ind);      % vector per worm per frame            Tracks(track_ind).Midline.LinearIndices(1)          = STATS.Midline.LinearIndices(worm_ind);            % vector per worm per frame            Tracks(track_ind).Midline.Pattern(1)                = STATS.Midline.Pattern(worm_ind);                  % vector per worm per frame            Tracks(track_ind).Midline.X_coordinates(1)          = STATS.Midline.X_coordinates(worm_ind);            % vector per worm per frame            Tracks(track_ind).Midline.Y_coordinates(1)          = STATS.Midline.Y_coordinates(worm_ind);            % vector per worm per frame            Tracks(track_ind).Midline.Angle(1)                  = STATS.Midline.Angle(worm_ind);                    % vector per worm per frame                        Tracks(track_ind).Midline.AngleFirstPoint(1)        = STATS.Midline.AngleFirstPoint(worm_ind);          % vector per worm per frame                        Tracks(track_ind).Midline.AngleLastPoint(1)         = STATS.Midline.AngleLastPoint(worm_ind);           % vector per worm per frame                        Tracks(track_ind).Midline.NumOfBends_HighRes(1)     = STATS.Midline.NumOfBends_HighRes(worm_ind);       % vector per worm per frame                        Tracks(track_ind).Midline.NumOfBends_LowRes(1)      = STATS.Midline.NumOfBends_LowRes(worm_ind);        % vector per worm per frame                                             Tracks(track_ind).Midline.FlagTrueIfReliable        = STATS.Midline.FlagTrueIfReliable(worm_ind);       % one logical value per worm per frame                            Tracks(track_ind).HeadTail(1,:,:)                   = squeeze(STATS.HeadTail(worm_ind,:,:));            % 2x2 matrix per worm per frame: first row=head, second is tail.                                    if AddProps == 3                Tracks(track_ind).WormCoordinates.Length(1)         = STATS.WormCoordinates.Length(worm_ind);           % vector per worm per frame                Tracks(track_ind).WormCoordinates.Width(1)          = STATS.WormCoordinates.Width(worm_ind);            % vector per worm per frame                      if Tracks(track_ind).Midline.FlagTrueIfReliable                    if Use_uint8_for_patterns                        Tracks(track_ind).PatternMatrix(1,:,:) = uint8(STATS.PatternMatrix{worm_ind});                  % Matrix per worm per frame                      else                                                            Tracks(track_ind).PatternMatrix(1,:,:) =       STATS.PatternMatrix{worm_ind};                   % Matrix per worm per frame                      end                else  % If no pattern was found due to midline problems                    if Use_uint8_for_patterns                        Tracks(track_ind).PatternMatrix(1,:,:)  = uint8(zeros(MidlineCalculationParams.WormMatrixWidth, MidlineCalculationParams.WormMatrixLength));   % Matrix per worm per frame                           else                        Tracks(track_ind).PatternMatrix(1,:,:)  = uint16(zeros(MidlineCalculationParams.WormMatrixWidth, MidlineCalculationParams.WormMatrixLength));  % Matrix per worm per frame                                                    end                end            end                                else   % If midline was not calculated, at least store the basic 'skeleton' information.                          Tracks(track_ind).WormSkeleton.Xcoordinate(1)    = STATS.WormSkeleton.Xcoordinate(worm_ind);        % vector of indices per worm per frame            Tracks(track_ind).WormSkeleton.Ycoordinate(1)    = STATS.WormSkeleton.Ycoordinate(worm_ind);        % vector of indices per worm per frame            Tracks(track_ind).WormSkeleton.LinearIndices(1)  = STATS.WormSkeleton.LinearIndices(worm_ind);      % vector of indices per worm per frame        end    endendreturnfunction break_now = ProgressDisplay_and_Memory (Frame, Mov, MovieName, Tracks, CurrentSettings, FragmentFrames, Fragment, ...                         PlotFrameRate, FigHandle, TempFolder, MAX_PerFrame_Calculation_Time, PlotHeadVsTail, MarkerSizeForDisplay, frame_index)  % Inputs in second line are loaded from TrackingVariables_SL.mat  break_now        = false;TotalNumOfFrames = diff(FragmentFrames(Fragment,:));% Allow time window for user to evaluate segmentationForceShowingFigure = false;ForceClosingFigure = false;if (frame_index == 3) && (TotalNumOfFrames< PlotFrameRate)   % Force showing first figure of segmentation if PlotFrameRate is too large    ForceShowingFigure = true;    endif (frame_index == 30) && (TotalNumOfFrames< PlotFrameRate)  % Force closing first after 30 frames if PlotFrameRate is too large    ForceClosingFigure = true;    end             if ForceClosingFigure     close;end% Display every PlotFrameRate'th frameif ForceShowingFigure || (~mod(frame_index, PlotFrameRate))               t1         = toc; tic;    fps        = PlotFrameRate/t1;    [~,NAME,~]    = fileparts(MovieName);    FigureName    = ['Movie name: ',NAME, ' - Frame ', num2str(Frame)];    threshold     = CurrentSettings(2);      AnimalPix     = CurrentSettings(3);      NumOfAnimals  = CurrentSettings(4);          if ForceShowingFigure        fps = 3/t1;        fprintf('\nFrame: %d , Calculation time: %.3g fps (%.2f sec/%d frames), threshold: %.3f, Mean animal size: %d pixels, Number of animals: %d \n',Frame,fps,t1,3, threshold,AnimalPix, NumOfAnimals)    else        fprintf('\nFrame: %d , Calculation time: %.3g fps (%.2f sec/%d frames), threshold: %.3f, Mean animal size: %d pixels, Number of animals: %d \n',Frame,fps,t1,PlotFrameRate, threshold,AnimalPix, NumOfAnimals)        fprintf('\n')    end        % Figure    figure(FigHandle); set(FigHandle, 'name', FigureName)    imshow(uint16(Mov),[]);    hold on;    if ~isempty(Tracks)        ActiveTracks = find([Tracks.Active]);    else        ActiveTracks = [];    end    for i = 1:length(ActiveTracks)        figure(FigHandle)                if Frame == Tracks(ActiveTracks(i)).Frames(end)                        plot(Tracks(ActiveTracks(i)).Path(:,1), Tracks(ActiveTracks(i)).Path(:,2), 'r');            plot(Tracks(ActiveTracks(i)).LastCoordinates(1), Tracks(ActiveTracks(i)).LastCoordinates(2), 'ro','markerfacecolor','r','markersize',MarkerSizeForDisplay);               plot(single(Tracks(ActiveTracks(i)).WormPerimeter.Ycoordinate{end}), single(Tracks(ActiveTracks(i)).WormPerimeter.Xcoordinate{end}), 'g.','markersize',1)            if isfield(Tracks,'Midline')                if Tracks(ActiveTracks(i)).Midline.FlagTrueIfReliable(end);                    PixelIndices.rows = Tracks(ActiveTracks(i)).Midline.X_coordinates{end};                    PixelIndices.cols = Tracks(ActiveTracks(i)).Midline.Y_coordinates{end};                               plot(PixelIndices.cols, PixelIndices.rows, 'b.','markersize',1)                end            end            if isfield(Tracks,'HeadTail')                if Tracks(ActiveTracks(i)).Midline.FlagTrueIfReliable(end);                    HeadCoordinates = squeeze(Tracks(ActiveTracks(i)).HeadTail(end,1,:));                    TailCoordinates = squeeze(Tracks(ActiveTracks(i)).HeadTail(end,2,:));                    plot(HeadCoordinates(2), HeadCoordinates(1), 'm*','markersize',MarkerSizeForDisplay)                    if PlotHeadVsTail                        plot(TailCoordinates(2), TailCoordinates(1), 'yo','markersize',MarkerSizeForDisplay)                    else                        plot(TailCoordinates(2), TailCoordinates(1), 'm*','markersize',MarkerSizeForDisplay)                    end                end            end        else  % Track is 'active' although object was not found in this frame            plot(Tracks(ActiveTracks(i)).Path(:,1), Tracks(ActiveTracks(i)).Path(:,2), 'r');            plot(Tracks(ActiveTracks(i)).LastCoordinates(1), Tracks(ActiveTracks(i)).LastCoordinates(2), 'cx','markersize',MarkerSizeForDisplay);         end                end    drawnow;        hold off;    % So not to see movie replay        % stop if it takes too long to analyze- probably an error    if (t1/PlotFrameRate) > MAX_PerFrame_Calculation_Time             disp(['Stopping script- too long: ', num2str(t1/PlotFrameRate)]);        break_now = true;        return    endendif ~mod(frame_index, 10)           % units [1/frame]    t1         = toc; tic;    fps        = 10/t1;    EstimateTimeLeft = ((diff(FragmentFrames(Fragment,:)) - frame_index)/fps)/60;  % in minutes    disp(['  fps=',num2str(fps),',  ',num2str(EstimateTimeLeft),' minutes left'])end% Command window displayswitch mod(frame_index,5)     case 0, fprintf('-');     case 1, fprintf('\b\\');     case 2, fprintf('\b|');     case 3, fprintf('\b/');     case 4, fprintf('\b='); %     case 5, fprintf('\b+'); endif ~mod(frame_index,100)     % new line in workspace    fprintf('\n\n');      % progress file          PercentComplete = round(100*(Frame - FragmentFrames(Fragment,1)) / diff(FragmentFrames(Fragment,:)));        ProgFileName    = fullfile(TempFolder,['_F',int2str(Fragment)]);    delete([ProgFileName,'*']);    save([ProgFileName,'.',int2str(PercentComplete)],'PercentComplete');    endreturnfunction SaveAndUpdateStatus (File, Fragment, Settings, Tracks, background, AddProps) load (File(1).TrackingVariablesFile);    % All relevant tracking parametersStatusFile       = File(1).StatusFile;FragmentSaveName = File.FragmentSaveNames{Fragment}; ExpData.PixelSize                       = File.PixelSize;ExpData.ArenaSize                       = File.ArenaSize;ExpData.FrameRate                       = FrameRate;ExpData.TrackTime                       = datestr(now);ExpData.TrackedFrames                   = File.FragmentFrames(Fragment,:);if exist('Settings','var')    ExpData.TrackStats.Settings         = Settings;      ExpData.TrackStats.NumWormsPerFrame = Settings(:,4);endExpData.TrackStats.MaxSpeedForTrackLinking_mm_sec = MaxSpeedForTrackLinking_mm_sec;ExpData.TrackStats.MaxRelativeSizeChange  = MaxRelativeSizeChange;ExpData.TrackStats.MinTrackLength         = MinTrackLength;%% Minimized Tracks structure, splitted by Arena ID. % delete large memory variables and resuce Midline Angle 'sampling' to 50 dots per worm  Tracks_smallstruct =  rmfield(Tracks,'Frame');MidlineVectorLength = (File.VariablesInformation.MidlineCalculationParams.WormMatrixLength-1);   % 500Resolution          = 50;                                                                    % How many angle points (along the worm body) to storeMidlineIndices      = round( 1:((MidlineVectorLength-1)/(Resolution-1)) : MidlineVectorLength); if AddProps >= 2    Tracks_smallstruct           = rmfield(Tracks_smallstruct,  {'PatternValues','WormArea'});       for tr_ind = 1:length(Tracks_smallstruct)        Tracks_smallstruct(tr_ind).Midline       = rmfield(Tracks_smallstruct(tr_ind).Midline,{'X_coordinates','Y_coordinates','LinearIndices','Pattern'} );                 Tracks_smallstruct(tr_ind).WormPerimeter = rmfield(Tracks_smallstruct(tr_ind).WormPerimeter,{'LinearIndices'} );             end       for tr_ind = 1:length(Tracks_smallstruct)        ReliableMidlineFrames = Tracks_smallstruct(tr_ind).Midline.FlagTrueIfReliable;                for frame_ind = find(ReliableMidlineFrames)            Tracks_smallstruct(tr_ind).Midline.Angle{frame_ind} = Tracks_smallstruct(tr_ind).Midline.Angle{frame_ind}(MidlineIndices);                    end        for frame_ind = find(~ReliableMidlineFrames)            Tracks_smallstruct(tr_ind).Midline.Angle{frame_ind}               = [];                        Tracks_smallstruct(tr_ind).Midline.X_coordinates_short{frame_ind} = [];                        Tracks_smallstruct(tr_ind).Midline.Y_coordinates_short{frame_ind} = [];                    end    end    endif AddProps == 3    Tracks_smallstruct           = rmfield(Tracks_smallstruct,   'WormCoordinates');end% Save Fragment Filesavesuccess = 0;while ~savesuccess    try        disp([datestr(now),' Saving Data for Movie ''',File.MovieName,''', fragment ',num2str(Fragment)]);        save(FragmentSaveName, 'Tracks', 'background', 'ExpData', 'File', 'Tracks_smallstruct','Settings','-v7.3');        clear Tracks;        for ar = 1:File.NumArenas            Tracks    =  Tracks_smallstruct([Tracks_smallstruct.ArenaID]==ar);            save([FragmentSaveName(1:end-4),'_Arena',num2str(ar),'.mat'], 'Tracks', 'background', 'ExpData', 'File','Settings','-v7.3');         end                    disp([datestr(now),' *** Save complete *** ']);        savesuccess = 1;    catch        disp(' Error while saving... retrying');        lasterr        pause(10);    endend% Update status fileloadsuccess = 0;while ~loadsuccess     try        load(StatusFile,'File');        loadsuccess = 1;    catch        disp('Error loading status file.  Retrying...');        pause(5);    endend File.CompletedFragments(Fragment) = 1;success = false;while ~success    try        save(StatusFile,'File','-append');        disp('*** Status file updated ***');        success = true;    catch        disp('error saving status file. Retrying in 10 seconds');        pause(10);    endend        return%% midline and pattern definition functionsfunction  [Midline, Head_Tail, PositionMatX, PositionMatY]  = ExtractPositionMatrix (Skeleton_LinearIndices, ImageSize, MidlineCalculationParams, AddProps)  %% Input-Output Examples:% Inputs:% WormMatrixLength    = 2000;     % The skeleton NEW length. For 5X movies the non-refined skeleton is around 210 pixels.% WormMatrixWidth     = 61;       % The NEW worm width. MUST BE AN ODD NUMBER TO INCLUDE ZERO !!!!! % WormRealWidth       = 16;       % Number of PIXELS from midline for definition of the worm profile. Better to over-estimate it. % InterpolationFactor = 0.05;     % for csaps spline function% PlotCalculatinFigures = false; % optional parameter. set 'true' for plotting calculation figures  % Outputs:% PositionMatX = X coordinate matrix of the worm profile. Values are NOT NATURAL numbers  % PositionMatX = Y coordinate matrix of the worm profile. Values are NOT NATURAL numbers  % Flag         = 'true' if the calculation is reliable, 'false' if not% THETA_ang    = midline normal angle. It's the Counterclockwise angular displacement from X coordinate (X coordinate  = Y axis in an ''imshow'' image). values between [0 180]   % Head_Tail    = Head and Tail coordinates. NOTE THAT THE HEAD AND TAIL MAY BE SWITCHED AT THIS POINT !!  This is corrected later using the correlation criteria % [x(start) y(start); x(end) y(end)]%% Initializing parametersFlag = true;InterpolationFactor          = MidlineCalculationParams.InterpolationFactor           ;  % for csaps spline function of midline X-Y coordinateInterpolationFactorBodyAngle = MidlineCalculationParams.InterpolationFactorBodyAngle  ;  % for csaps spline function of midline angles. More smoothed!PlotCalculationFigures       = MidlineCalculationParams.PlotCalculationFigures        ;  % optional parameter. set 'true' for plotting calculation figures  WormMatrixWidth              = MidlineCalculationParams.WormMatrixWidth               ; WormMatrixLength             = MidlineCalculationParams.WormMatrixLength              ;long_vec_Length              = WormMatrixLength;WormRealWidth                = MidlineCalculationParams.WormRealWidthInPixels         ;% Condition for plotting figuresplotfig = false;if exist('PlotCalculationFigures','var')    if PlotCalculationFigures        plotfig = true;    endend% Skeleton [X,Y] Indices% NOTE!!! In the Image: %         Increasing in Y axis is decreasing X coordinate        %         Increasing in X axis is increasing Y coordinate        [xx, yy] = ind2sub(ImageSize, Skeleton_LinearIndices);      % Check monotonicity !!!! Y_is_monotonic = isempty(find(abs(diff(yy))>1,1));X_is_monotonic = isempty(find(abs(diff(xx))>1,1));if ~X_is_monotonic || ~Y_is_monotonic    [xx, yy, Flag] = Resort_into_monotonic_Line_bwtraceboundary_v02 (Skeleton_LinearIndices, ImageSize, xx,yy, plotfig);endif length(xx)<3   % less than 3 pixels --> don't bother calculating midline ...    Midline.Flag                = false;     Midline.X_coordinates_short = [];     Midline.Y_coordinates_short = [];     Midline.LinearIndices       = [];     Midline.Pattern             = [];     Midline.X_coordinates       = [];     Midline.Y_coordinates       = [];     Midline.FlagTrueIfReliable  = false;            Head_Tail                   = single(zeros(2))*NaN;    if AddProps==3        Midline.Angle               = [];     end    returnend% Increasing the sampling rateDelta            = (length(xx)-1)/(long_vec_Length-1); long_vec         = 1 : Delta: length(xx);Width_vec        = (-0.5 : (1/(WormMatrixWidth-1)): 0.5) * WormRealWidth;     % This is the distance in pixels to BOTH DIRECTION, with Zero on the skeleton                                                                              % This paremetr is used to define the normals.  %% Csaps smoothing for each cooredinate individually pp          = csaps(1:length(xx),xx, InterpolationFactor); sm_xx       = fnval(pp,long_vec);sm_xx_short = fnval(pp,1:length(xx));pp          = csaps(1:length(yy),yy, InterpolationFactor); sm_yy       = fnval(pp,long_vec);sm_yy_short = fnval(pp,1:length(yy));if AddProps > 2   % donnot caluclate angles unless necessary for matrix pattern extraction%% Calculating the angle of the normals to the worms skeleton (using increased sampling rate)      THETA       = cart2pol(diff(sm_xx),diff(sm_yy));   % THETA is a counterclockwise angular displacement in radians from the positive x-axis    THETA       = [THETA(1) THETA];       % FIXING SINGULAR POINTS    THETA_PEAKS = find(abs(diff(THETA))> pi); % indices BEFORE the 2pi 'jump'    for p_ind = 1:length(THETA_PEAKS)        StartIndex = THETA_PEAKS(p_ind);            if THETA(StartIndex) < THETA(StartIndex+1) % Expect a sudden increase of 2*pi             THETA((StartIndex+1):end) =  THETA((StartIndex+1):end) - 2*pi;        else                                       % Expect a sudden deccrease of 2*pi             THETA((StartIndex+1):end) =  THETA((StartIndex+1):end) + 2*pi;        end    end    THETA_PEAKS_OK = isempty(find(abs(diff(THETA))> pi , 1, 'first')); % indices BEFORE the 2pi 'jump'    if ~ THETA_PEAKS_OK        disp('WARNING: singularities were found in angles calculation');        Flag = false;    end    THETA_ang_rad = THETA - 0.5*pi;  % Add 90 deg --> Angle is RELATIVE TO THE X AXIS !    % ADDITIONAL SMOOTHING OF THE ANGLE VECTOR               pp       = csaps(long_vec, THETA_ang_rad, InterpolationFactorBodyAngle);     sm_angle = fnval(pp,long_vec);    % figure; plot(long_vec,THETA_ang_rad,'b.'); hold on; plot(long_vec,sm_angle,'r-'); hold on;     THETA_ang_rad = sm_angle;    %% Position matrix    DisplacementMatrices.X = zeros(WormMatrixWidth, WormMatrixLength);    DisplacementMatrices.Y = zeros(WormMatrixWidth, WormMatrixLength);    RHO                    = abs(Width_vec);    AddPiIndices           = sign(Width_vec)<0;       % Add pi to the angle if below midline    for normal_ind = 1: WormMatrixLength        angle_vec               = ones(1,WormMatrixWidth) * THETA_ang_rad(normal_ind);        angle_vec(AddPiIndices) = angle_vec(AddPiIndices) + pi;        [X,Y]                                = pol2cart(angle_vec,RHO);        DisplacementMatrices.X(:,normal_ind) = X;        DisplacementMatrices.Y(:,normal_ind) = Y;        end    % Create Position Matrix: Add midline (skeleton) values and displacements    PositionMatX = repmat(sm_xx,WormMatrixWidth,1) + DisplacementMatrices.X;    PositionMatY = repmat(sm_yy,WormMatrixWidth,1) + DisplacementMatrices.Y;    %% Angle Output    THETA_ang       = single(THETA_ang_rad/pi*180);    Midline.Angle   = single(THETA_ang + 90);   % 'THETA_ang' is the angle of the normal to the midline while 'Midline.Angle' is the body midline angle:                                                             % The angles in 'Midline.Angle' are defined as the COUNTERCLOCKWISE DISPLACEMENT FROM THE +X AXIS.                                                               %       [0 90 180 270] corresponds to [+X +Y -X -Y], respectively.  end%% Asign output variables% Head and tailsm_xx_edge = round(sm_xx([1 end]));sm_xx_edge(sm_xx_edge<1)=1;sm_xx_edge(sm_xx_edge>ImageSize(1))=ImageSize(1);sm_yy_edge = round(sm_yy([1 end]));sm_yy_edge(sm_yy_edge<1)=1;sm_yy_edge(sm_yy_edge>ImageSize(2))=ImageSize(2);Head_Tail = single([sm_xx_edge', sm_yy_edge']);     % [x(start) y(start); x(end) y(end)]% midline coordinates and flagMidline.X_coordinates       = single(sm_xx);Midline.Y_coordinates       = single(sm_yy);Midline.Flag                = Flag;Midline.X_coordinates_short = single(sm_xx_short);Midline.Y_coordinates_short = single(sm_yy_short);% midline linear indicessm_xx_short_for_ind                                     = round(sm_xx_short);sm_yy_short_for_ind                                     = round(sm_yy_short);sm_xx_short_for_ind(sm_xx_short_for_ind == 0)           = 1; sm_yy_short_for_ind(sm_yy_short_for_ind == 0)           = 1; sm_xx_short_for_ind(sm_xx_short_for_ind > ImageSize(1)) = ImageSize(1); sm_yy_short_for_ind(sm_yy_short_for_ind > ImageSize(2)) = ImageSize(2); Midline.LinearIndices                                   = single( sub2ind(ImageSize, sm_xx_short_for_ind, sm_yy_short_for_ind) );  %% PLOTSif plotfig    plot_all = 0;        if plot_all            SKEL_MAT = zeros(ImageSize);        SKEL_MAT(Skeleton_LinearIndices)=1;         figure; imshow(SKEL_MAT); hold on; plot(yy,xx,'b.')            figure; plot(1:length(xx),xx,'b.'); hold on; plot(1:length(xx),yy,'r.'); plot(long_vec,sm_xx,'b-'); plot(long_vec,sm_yy,'r-');                 xlabel('running index'); legend('x','y','sx','sy');        figure; plot(xx,yy,'b.'); hold on; plot(sm_xx,sm_yy,'r-'); xlabel('x'); ylabel('y');          if exist('THETA_ang_rad','var')                        figure; plot(THETA_ang_rad,'r'); title('Angle of skeleton Normals')                    ylabel(['Counterclockwise angular displacement from X coordinate]',char(10),'(X coordinate  = Y axis in an ''imshow'' image)']);                     xlabel('Index in Worm Matrix');        end                if exist('THETA_ang_rad','var')                        % Colormap Display of worm skeleton with normals on BigMatrix            load ('D:\MicroFluidics\Matlab_Temporary_Files\AutoFluorescence\MyColorMap.mat','MyRedGreenMap');            BigMat_X      = (1:Delta:ImageSize(1));            % THETA_MAT     = ones(length(BigMat_X),length(BigMat_X))*90;            THETA_MAT     = zeros(length(BigMat_X),length(BigMat_X));            sm_xx_index   = round(sm_xx*length(BigMat_X)/ImageSize(1));            sm_yy_index   = round(sm_yy*length(BigMat_X)/ImageSize(1));            THETA_MAT(sub2ind(size(THETA_MAT), sm_xx_index, sm_yy_index)) = THETA_ang;            figure; imagesc(THETA_MAT);             colorbar; set(gca,'CLim',[-90 90])            colormap(MyRedGreenMap); % colormap(redgreencmap)               end    else        figure; plot(xx,yy,'b.'); hold on; plot(sm_xx,sm_yy,'r-'); xlabel('x'); ylabel('y');          if exist('THETA_ang_rad','var')                       figure; plot(THETA_ang_rad,'r');                 if isempty(THETA_PEAKS)                    title('Angle of skeleton Normals');                else                    title('Angle of skeleton Normals - CORRECTED !!');                end                ylabel(['Counterclockwise angular displacement from X coordinate]',char(10),'(X coordinate  = Y axis in an ''imshow'' image)']);                 xlabel('Index in Worm Matrix Index');        end    end               endreturnfunction  Midline = CaluclateMidlineProperties(Midline, MidlineCalculationParams)  plotme = false;InterpolationFactorBodyAngle = MidlineCalculationParams.InterpolationFactorBodyAngle  ;  % for csaps spline function of midline angles. More smoothed!long_vec                     = 1 : (MidlineCalculationParams.WormMatrixLength-1)      ;NumOfWorms                   = length(Midline.Length);Midline.Angle                = cell(1,NumOfWorms);Midline.AngleFirstPoint      = single(zeros(1,NumOfWorms)*NaN);Midline.AngleLastPoint       = single(zeros(1,NumOfWorms)*NaN);Midline.NumOfBends_HighRes   = uint8(zeros(1,NumOfWorms));Midline.NumOfBends_LowRes    = uint8(zeros(1,NumOfWorms));for wi=1:NumOfWorms    if Midline.FlagTrueIfReliable(wi)        X = Midline.X_coordinates{wi};        Y = Midline.Y_coordinates{wi};                %% Calculating the angle of the normals to the worms skeleton (using increased sampling rate)          THETA       = cart2pol(diff(X),diff(Y));   % THETA is a counterclockwise angular displacement in radians from the positive x-axis        % FIXING SINGULAR POINTS        THETA_PEAKS = find(abs(diff(THETA))> pi); % indices BEFORE the 2pi 'jump'        for p_ind = 1:length(THETA_PEAKS)            StartIndex = THETA_PEAKS(p_ind);                if THETA(StartIndex) < THETA(StartIndex+1) % Expect a sudden increase of 2*pi                 THETA((StartIndex+1):end) =  THETA((StartIndex+1):end) - 2*pi;            else                                       % Expect a sudden deccrease of 2*pi                 THETA((StartIndex+1):end) =  THETA((StartIndex+1):end) + 2*pi;            end        end        THETA_PEAKS_OK = isempty(find(abs(diff(THETA))> pi , 1, 'first')); % indices BEFORE the 2pi 'jump'        if ~ THETA_PEAKS_OK            disp('WARNING: singularities were found in angles calculation');            Midline.FlagTrueIfReliable(wi)=false;            Flag=false        end        % ADDITIONAL SMOOTHING OF THE ANGLE VECTOR                pp                          = csaps(long_vec', double(THETA)', InterpolationFactorBodyAngle);         THETA_smoothed              = single(fnval(pp,long_vec));                        pp                          = csaps(long_vec', double(THETA)', InterpolationFactorBodyAngle/100);                                                      THETA_ForBendsCount_HighRes = single(fnval(pp,long_vec));                pp                          = csaps(long_vec', double(THETA)', InterpolationFactorBodyAngle/10000);                                                      THETA_ForBendsCount_LowRes  = single(fnval(pp,long_vec));       %         figure; plot(long_vec,THETA,'b.'); hold on; plot(long_vec,THETA_smoothed,'r:'); plot(long_vec,THETA_ForBendsCount_HighRes,'r-'); plot(long_vec,THETA_ForBendsCount_LowRes,'g-');                        %% Angle Output        % The angles in 'Midline.Angle' are defined as the COUNTERCLOCKWISE DISPLACEMENT FROM THE +X AXIS. i.e. [0 90 180 270] corresponds to [+X +Y -X -Y], respectively.          THETA_ang                     = THETA_smoothed/pi*180;        THETA_ang_ForBendCount_HighRes= THETA_ForBendsCount_HighRes/pi*180;        THETA_ang_ForBendCount_LowRes = THETA_ForBendsCount_LowRes/pi*180;        Midline.Angle{wi}             = single(THETA_ang);           Midline.AngleFirstPoint(wi)   = THETA_ang(1);          % The head direction is: 360- Midline.AngleFirstPoint        Midline.AngleLastPoint(wi)    = THETA_ang(end);        % The tail direction is:      Midline.AngleLastPoint                %% bending output:         %   one bend == the curvature of the body is always to the same direction            %   2 bends  == the curvature of the body switches direction 1 time           %   3 bends  == the curvature of the body switches direction 2 times           %   4 or more bends are NOT ALLOWED and considered as errors. Midline.FlagTrueIfReliable will be corrected appropriately.                     % HIGH RESOLUTION        THETA_RelativeToHead                = THETA_ang_ForBendCount_HighRes - THETA_ang_ForBendCount_HighRes(1);       % This is the angle relative to the head orientation;        CurvatureDirection                  = sign(diff(THETA_RelativeToHead));                         % (1) for counterclockwise, (-1) for clockwise.        CurvatureDirectionSwitchingPoints   = find(diff(CurvatureDirection)~=0);        NumOfBends                          = 1+length(CurvatureDirectionSwitchingPoints);              Midline.NumOfBends_HighRes(wi)      = NumOfBends;                    % LOW RESOLUTION        THETA_RelativeToHead                = THETA_ang_ForBendCount_LowRes - THETA_ang_ForBendCount_LowRes(1);       % This is the angle relative to the head orientation;        CurvatureDirection                  = sign(diff(THETA_RelativeToHead));                         % (1) for counterclockwise, (-1) for clockwise.        CurvatureDirectionSwitchingPoints   = find(diff(CurvatureDirection)~=0);        NumOfBends                          = 1+length(CurvatureDirectionSwitchingPoints);              Midline.NumOfBends_LowRes(wi)       = NumOfBends;                            if plotme            figure; plot(long_vec,THETA,'b.'); hold on; plot(long_vec,THETA_smoothed,'r:'); plot(long_vec,THETA_ForBendsCount_HighRes,'r-'); plot(long_vec,THETA_ForBendsCount_LowRes,'g-');             figure;             plot(X,Y,'r'); hold on; plot(X(1),Y(1),'r*')            title(['(',num2str(Midline.NumOfBends_LowRes(wi)),',',num2str(Midline.NumOfBends_HighRes(wi)), ') bends at (low/high) resolution.  First Angle= ',num2str(mod(360+Midline.AngleFirstPoint(wi),360)),'.  Last Angle= ',num2str(mod(360+Midline.AngleLastPoint(wi),360))]);            pause;              close; close;        end                end                                                      endfor wi=find(Midline.FlagTrueIfReliable==0)    Midline.Angle{wi}               = [];   endreturnfunction [xx_sorted, yy_sorted, Flag] = Resort_into_monotonic_Line_bwtraceboundary_v02 (Skeleton_LinearIndices, ImageSize, xx,yy, plotfig_in)InitialPointCorrection = false;Tolerance  = 1;    % Allow changes of up to 1 pixel between raw data midline and monotonic-detected midline  plotfig   = false;StopAtEnd = false;if exist('plotfig_in','var')    if plotfig_in        plotfig = true;    endendSKEL_MAT                        = false(ImageSize);SKEL_MAT(Skeleton_LinearIndices)= true; % FIRST guess: first [xx, yy] point.% Note that the first point that is always taken as the smallest yy point. trial = 1;InitialPoint                       = [xx(1) yy(1)]; [xx_sorted, yy_sorted, SameLength] = ResortMidlineCoordinates (SKEL_MAT, xx, yy, InitialPoint, Tolerance);% If there is an error in calculation (not same length), try to fix it for cases of bad guess of the initial point if ~SameLength     InitialPointCorrection = true;            % SECOND guess: Try the highest xx that is in the range if relatively small yy (Boundary function is going 'WEST')      trial = 2;    PossibleIndicesY = find(yy<=prctile(yy,50));  % == median    [~,I]            = max(xx(PossibleIndicesY));    InitialIndex     = PossibleIndicesY(I);    InitialPoint     = [xx(InitialIndex)  yy(InitialIndex)];     if isempty(InitialPoint)        disp('Script is stopped for debugging using ''keyboard'' at Resort_into_monotonic_Line_bwtraceboundary_v02');        keyboard;    end    [xx_sorted, yy_sorted, SameLength] = ResortMidlineCoordinates (SKEL_MAT, xx, yy, InitialPoint, Tolerance);    if ~SameLength         % THIRD guess: Try the highest xx in all yy range           trial = 3;        [~,InitialIndex] = max(xx);        InitialPoint     = [xx(InitialIndex)  yy(InitialIndex)];         [xx_sorted, yy_sorted, SameLength] = ResortMidlineCoordinates (SKEL_MAT, xx, yy, InitialPoint, Tolerance);                                    if ~SameLength             % FOURTH guess: Try the highest yy in all yy range               trial = 4;            [~,InitialIndex] = max(yy);            InitialPoint     = [xx(InitialIndex)  yy(InitialIndex)];             [xx_sorted, yy_sorted, SameLength] = ResortMidlineCoordinates (SKEL_MAT, xx, yy, InitialPoint, Tolerance);                % It is possible to try call my distance matrix algorithm as a fifth guess, if necessary.           end            endend% Flag the result: false= bad; true= good;Y_is_monotonic = isempty(find(abs(diff(yy_sorted))>1,1));X_is_monotonic = isempty(find(abs(diff(xx_sorted))>1,1));Flag           =  X_is_monotonic && Y_is_monotonic && SameLength;% Plotsif plotfig    figure; plot(xx,yy,'b*-'); hold on; plot(xx_sorted,yy_sorted,'r.:');     UniqueLength_sorted   = length(unique(xx_sorted + 1000*yy_sorted));    UniqueLength_unsorted = length(unique(xx        + 1000*yy));    title(['Worm length: new = ',num2str(UniqueLength_sorted),', old = ',num2str(UniqueLength_unsorted),...           ' . Flag = ',num2str(Flag),' . Correction = ',num2str(InitialPointCorrection),' . Trial = ',num2str(trial)]);endreturnfunction [xx_sorted, yy_sorted, SameLength] = ResortMidlineCoordinates (SKEL_MAT, xx, yy, InitialPoint, Tolerance)try    B  = bwtraceboundary(SKEL_MAT, InitialPoint, 'W');  catch    B  = bwtraceboundary(SKEL_MAT, InitialPoint, 'S');end    xx_sorted = B(1:ceil(end/2),1)';yy_sorted = B(1:ceil(end/2),2)';% Is the new vector the same length, or are we missing some elements?UniqueLength_sorted   = length(unique(xx_sorted + 1000*yy_sorted));UniqueLength_unsorted = length(unique(xx        + 1000*yy));SameLength            =   UniqueLength_sorted >= (UniqueLength_unsorted - Tolerance);     % Tolerance is the number of pixel of difference allowed.returnfunction [Tracks, TrackArena] = AssociateTracksToArenas_inline (Tracks, File, PlotFigure) %% Input argumaents:% Tracks% File% PlotFigure        logical. optional (default = false). If true, figure will be plot showing the mean track position in a per-arena color code  % %% Output argumanets:% Tracks            - now it includes arena ID and vectors indicating for each track and frame whether the centroid is "IN BOUND"  % TrackArena        A vector of length(tracks) that specify the arena in which the track was detected  % NOTE: Here I assume that each track is within a single arena. NO OVERLAPPING ARENAS!   %% For each track, find the arena for which at least point in the track is within its defined borders.%  All tracks will be assigned an arenas ID, except of tracks for which all points are out-of-bound of all arenas.   if ~exist('PlotFigure','var')    PlotFigure = false;endNumArenas             = File.NumArenas;TrackBoxAxis          = File.TrackBoxAxis;        % Arenas are FULLY IMBEDDED within the TrackBoxAxisInBoundBoxAxis        = File.InBoundBoxAxis;      % In bound areas corresponding to each arena.  InBoundBoxAxis <= TrackBoxAxis.TrackArena            = zeros(1,length(Tracks));  % arena number per track indexfor tr = 1:length(Tracks)           % run over all frames    TrackCoordinates = Tracks(tr).Path;        for ar = 1: NumArenas        InArena = inpolygon(TrackCoordinates(:,1), TrackCoordinates(:,2), TrackBoxAxis(ar,1:2), TrackBoxAxis(ar,3:4));        if find(InArena,1)         % At least one point was found inside the arena boundaries            TrackArena(tr)     = ar;            Tracks(tr).ArenaID = ar;            InBound                = inpolygon(TrackCoordinates(:,1), TrackCoordinates(:,2), InBoundBoxAxis(ar,1:2), InBoundBoxAxis(ar,3:4));   % Frames with the centroid located inside the "IN BOUND" box            Tracks(tr).OutOfBounds = ~InBound';            break        end    end             endTracksToDelete        = find(TrackArena==0);   % These are tracks that were not found within any arena and will therefore be deletedTrackArena            = TrackArena(TrackArena~=0);Tracks(TracksToDelete)=[];%% Optional Tracks position Figureif PlotFigure     XY_Coordinates = cell(1,NumArenas);    Indices       = zeros(1,NumArenas);    for tr = 1:length(Tracks) %   OutOfBoundTracks      % Undefined_Tracks        X       = mean(Tracks(tr).Path(:,1));        Y       = mean(Tracks(tr).Path(:,2));        ArenaID = TrackArena(tr);        Indices(ArenaID) = Indices(ArenaID)+1;        XY_Coordinates{ArenaID}(Indices(ArenaID),1:2) = [X Y];     end    figure;    COLORCODE = {'r','b','g','k'};    for ar = 1:NumArenas               plot(XY_Coordinates{ar}(:,1),XY_Coordinates{ar}(:,2),'*','color',COLORCODE{ar}); hold on;    endendreturn%% Currently unused but important functionsfunction BW_Matrix = Create_BW_Matrix_from_images(Worm_PROPS, OriginalFrameSize)    BW_Matrix = false (OriginalFrameSize);for wi = 1:length(Worm_PROPS.Area)    UpperLeft_Coordinate_Dim2 = Worm_PROPS.BoundingBox(wi,1)-0.5;      UpperLeft_Coordinate_Dim1 = Worm_PROPS.BoundingBox(wi,2)-0.5;      IM = Worm_PROPS.Image{wi};          % Full worm BW image    [I,J]         = find(IM==1);          Coordinates   = [J + UpperLeft_Coordinate_Dim2, I + UpperLeft_Coordinate_Dim1]; % Matrix of [x y] locations of the skeleton ?? CHECK IT     linearInd     = sub2ind(OriginalFrameSize, Coordinates(:,2), Coordinates(:,1));    BW_Matrix (linearInd) = true;endfigure; imagesc(BW_Matrix);returnfunction BW_Matrix = Create_BW_Matrix_from_PixelsList(Worm_PROPS, OriginalFrameSize, PixelsField, ObjectIndices)    BW_Matrix = false (OriginalFrameSize);if ~exist('PixelsField','var')    PixelsField = 'PixelIdxList';   % Worms area. Other options: Skeleton_PixelIdxList , HeadTail_PixelIdxListendPixelsCell = Worm_PROPS.(PixelsField);if ~exist('ObjectIndices','var')    ObjectIndices = 1:length(PixelsCell);   % Worms areaendPixelsCell = PixelsCell(ObjectIndices);if ~ strcmpi(PixelsField,'HeadTail_PixelIdxList')    for wi = 1:length(PixelsCell)        BW_Matrix (PixelsCell{wi}) = true;    endelse    All_indices = Worm_PROPS.HeadTail_PixelIdxList(ObjectIndices,:);    BW_Matrix(All_indices(:)) = true;    endfigure; imagesc(BW_Matrix);returnfunction Plot_PixelList_on_Frame(Worm_PROPS, OriginalFrameSize, PixelsField, ObjectIndices, COLOR)    if ~exist('COLOR','var')    COLOR   = 'r';endLINESTYLE   = 'none'; % for PixelIdxList and HeadTail_PixelIdxListMARKER      = '.';    % for PixelIdxListif ~exist('PixelsField','var')    PixelsField = 'PixelIdxList';          % Worms area elseif strcmpi(PixelsField,'Skeleton_PixelIdxList') || strcmpi(PixelsField,'Perimeter_PixelIdxList')%     LINESTYLE   = '-';    %     MARKER      = 'none';   elseif strcmpi(PixelsField,'HeadTail_PixelIdxList')    MARKER      = '*';  endPixelsCell = Worm_PROPS.(PixelsField);if ~exist('ObjectIndices','var') || isempty(ObjectIndices)    ObjectIndices = 1:length(PixelsCell);   % Worms areaendPixelsCell = PixelsCell(ObjectIndices);if ~ strcmpi(PixelsField,'HeadTail_PixelIdxList')    for wi = 1:length(PixelsCell)        [I,J] = ind2sub(OriginalFrameSize,PixelsCell{wi});        hold on;        plot(J,I,'color',COLOR,'marker',MARKER,'linestyle',LINESTYLE,'markersize',5);     endelse    All_indices = Worm_PROPS.HeadTail_PixelIdxList(ObjectIndices,:);    [I,J] = ind2sub(OriginalFrameSize,All_indices);    hold on;    plot(J,I,'color',COLOR,'marker',MARKER,'linestyle',LINESTYLE,'markersize',10); endreturn
function PlotsAndStats_ZebrafishOT_LoomingResponse_Fig7
%  
%  Plots of zebrafish OT calcium responses to looming visual stimuli 
% 
%  Written by Sagi Levy, September 2019
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% load processed data generated by the function 'ProcessZebrafishOT_LoomingResponse_Fig7'  
load('D:\Fish Looming Data\Data_ZebrafishImaging_Processed.mat');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Plot stimulus dynamics, its derivative and fold-change
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      
%%% Stimulus dynamics. Figure S7A, middle panels
figure('position',[681   353   560   131]); 
subplot(1,3,1); hold on; plot(Time, Stimulus{2},'k'); plot(Time, Stimulus2{2},'k:'); xlim([0 15]); xlabel('Time [sec]'); title('Fast'); ylabel('S')
subplot(1,3,2); hold on; plot(Time, Stimulus{3},'k'); plot(Time, Stimulus2{3},'k:'); xlim([0 15]); xlabel('Time [sec]'); title('Intermediate')
subplot(1,3,3); hold on; plot(Time, Stimulus{1},'k'); plot(Time, Stimulus2{1},'k:'); xlim([0 15]); xlabel('Time [sec]'); title('Slow')

%%% Initial visual stimulus amplitude. Figure S7A lower panels
figure('position',[ 680   770   250   208],'name','initial stimulus size'); 
h=bar(1:3, [StimulusMat1([2 3 1],1) StimulusMat2([2 3 1],1)]); xlim([0.5 3.5]); ylim([22 35])
set(h,'edgecolor','k'); set(h(1),'facecolor','k'); set(h(2),'facecolor','none'); 

%%% Signal, derivative and fold-change (fish 1-8). Figure S7B. Derivative diverges at t=0 due to stimulus step  
figure('position',[680   186   402   792]); 
subplot(3,1,1); hold on; plot([-1 0   TimeLong], [0 0       StimulusMatLong1(2,:)],'k');  
                         plot([-1 0   TimeLong], [0 0       StimulusMatLong1(3,:)],'-','color',[0.5 0 0]);       
                         plot([-1 0   TimeLong], [0 0       StimulusMatLong1(1,:)],'r'); xlim([-0.4 15]); ylim([-5 150]);  ylabel('S')
subplot(3,1,2); hold on; plot([-1 0 0 TimeLong], [0 0 NaN DerivativeMatLong1(2,:)],'k');  
                         plot([-1 0 0 TimeLong], [0 0 NaN DerivativeMatLong1(3,:)],'-','color',[0.5 0 0]);  
                         plot([-1 0 0 TimeLong], [0 0 NaN DerivativeMatLong1(1,:)],'r'); xlim([-0.4 15]); ylim([-4.5 130]); ylabel('dS/dt')
subplot(3,1,3); hold on; plot([-1 0 0 TimeLong], [0 0 NaN    FoldChangeLong1(2,:)],'k');  
                         plot([-1 0 0 TimeLong], [0 0 NaN    FoldChangeLong1(3,:)],'-','color',[0.5 0 0]);  
                         plot([-1 0 0 TimeLong], [0 0 NaN    FoldChangeLong1(1,:)],'r'); xlim([-0.4 15]); ylim([-0.1 3.5]); ylabel('(dS/dt)/S'); xlabel('Time [sec]')

% %%%% Low temporal resolution plots 
% figure('position',[680   186   402   792]); 
% subplot(3,1,1); hold on; plot(Time, Stimulus{2},'k');    plot(Time, Stimulus{3},'-','color',[0.5 0 0]);    plot(Time, Stimulus{1},'r'); xlim([-1 15]); ylim([-5 150])
% subplot(3,1,2); hold on; plot(Time, Derivative{2},'k');  plot(Time, Derivative{3},'-','color',[0.5 0 0]);  plot(Time, Derivative{1},'r'); xlim([-1 15]); ylim([-4.5 130])
% subplot(3,1,3); hold on; plot(Time, FoldChange{2},'k');  plot(Time, FoldChange{3},'-','color',[0.5 0 0]);  plot(Time, FoldChange{1},'r'); xlim([-1 15]); ylim([-0.1 3.5])

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plot processed neuronal activity of all neurons, to 3 stimuli speeds, Figure S7A
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PlotMatrices(Time, ProcessedMAT_All,  [], [0 1]);       % @3Hz
PlotMatrices(TimeLong, ProcessedMAT_Long_All,  [], [0 1]) % @30Hz
GreenColormap      = ones(64,3);          % initialization
GreenColormap(:,1) = linspace(1,0,64);
GreenColormap(:,3) = linspace(1,0,64);
GreenColormap(:,2) = linspace(1,0.5,64);
set(gcf,'colormap',GreenColormap)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Plot latency and stimulus features at the time of neuronal activation. Related to Figure S7C and left panels in Figures 7A and S7E
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   
%%% Example for latency extraction. Figure S7B, upper panel 
neuron_index = 986; PlotTraceWithLatency(TimeLong, ProcessedMAT_Long_All, ActivationTimes, neuron_index);
xlabel('Time [sec]'); ylabel('\DeltaF/F'); title(''); ylim([-0.03 1.03])

%%% Plots and statistics of for latency, and stimulus features at neuron activation time. Figure S7C and left panels in Figures 7A and S7E 
NaNMode = 1;  % The choice of how to deal with NaNs has negligible effect on results (see description in 'PlotPerSpeed_median' function).   
% All fish
Stats = PlotPerSpeed_median(ActivationTimes, false, NaNMode);            ylabel('Latency [sec]')
Stats = PlotPerSpeed_median(StimulusAtActivationTime, false, NaNMode);   ylabel('Signal');       ylim([33 45])
Stats = PlotPerSpeed_median(DerivativeAtActivationTime, false, NaNMode); ylabel('Derivative')
Stats = PlotPerSpeed_median(FoldChangeAtActivationTime, false, NaNMode); ylabel('Fold change')

% % only Fish 1-8
% Stats = PlotPerSpeed_median(ActivationTimes(1:TotalNumberOfNeurons,:), false, NaNMode);            ylabel('Latency [sec]')
% Stats = PlotPerSpeed_median(StimulusAtActivationTime(1:TotalNumberOfNeurons,:), false, NaNMode);   ylabel('Signal')
% Stats = PlotPerSpeed_median(DerivativeAtActivationTime(1:TotalNumberOfNeurons,:), false, NaNMode); ylabel('Derivative')
% Stats = PlotPerSpeed_median(FoldChangeAtActivationTime(1:TotalNumberOfNeurons,:), false, NaNMode); ylabel('Fold change')
% 
% % Only Fish 9-10
% Stats = PlotPerSpeed_median(ActivationTimes((TotalNumberOfNeurons+1):end,:), false, NaNMode);            ylabel('Latency [sec]')
% Stats = PlotPerSpeed_median(StimulusAtActivationTime((TotalNumberOfNeurons+1):end,:), false, NaNMode);   ylabel('Signal')
% Stats = PlotPerSpeed_median(DerivativeAtActivationTime((TotalNumberOfNeurons+1):end,:), false, NaNMode); ylabel('Derivative')
% Stats = PlotPerSpeed_median(FoldChangeAtActivationTime((TotalNumberOfNeurons+1):end,:), false, NaNMode); ylabel('Fold change')

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  ACT model plots
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Adaptive threshold steady state function. Figure S7D bottom
X = 0:0.5:150;
Y = A + (Alpha-(2*A)/X0)*X + (A/X0^2)*X.^2 ;   % B = (Alpha-(2*A)/X0);  C = (A/X0^2);  
figure('name','Steady state function'); 
plot(X,Y,'k'); ylim([0 200]); set(gca,'xtick',0:50:200,'ytick',0:50:200)
xlabel('S'); ylabel('F(S)')

%%% Adaptive threshold dynamics during stimulus exposure. Figure S7D     
figure('position',[779   130   384   420],'name','Fast, intermediate and slow signals (rows, black) and corresponding adaptive thresholds (red)' ); 
row=0;
for speed_ind = [2 3 1]
    row = row+1;
    subplot(3,2,row*2-1); hold on;
    plot(TimeLong, StimulusMatLong1(speed_ind,:),'k');
    plot(TimeLong, squeeze(ACTmodelStructure.ACT_MAT1(A_ind, Alpha_ind, X0_ind, Tao_ind, speed_ind, :)),'r');
    ylim([0 200])
    if speed_ind==1, xlabel('Time [sec]'); end
    
    subplot(3,2,row*2); hold on;
    plot(TimeLong, StimulusMatLong2(speed_ind,:),'k');
    plot(TimeLong, squeeze(ACTmodelStructure.ACT_MAT2(A_ind, Alpha_ind, X0_ind, Tao_ind, speed_ind, :)),'r');        
    ylim([0 200])
    if speed_ind==1, xlabel('Time [sec]'); end
end

%%% Comparison between observations and adaptive threshold model predictions. Figures 7A and S7E   
PlotComparison_Data_vs_ACT_Model(StimulusAtActivationTime, ActivationTimes, ACTmodelStructure, TotalNumberOfNeurons, TotalNumberOfNeurons2, X0, A, Alpha, tao)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Other useful Plots, not for paper
% % Matrices
% PlotMatrices(Time, RawMAT,  Stimulus, [0 4])
% PlotMatrices(Time, RawMAT2, Stimulus2,[0 4])
% 
% % Smoothed Matrices
% PlotMatrices(Time, SmoothedMAT,  Stimulus)
% PlotMatrices(Time, SmoothedMAT2, Stimulus2)
% 
% % Normalized Smoothed Matrices
% PlotMatrices(Time, NormSmoothedMAT,  [], [0 1])
% PlotMatrices(Time, NormSmoothedMAT2, [],[0 1])
% 
% % Smoothed matrices, exclude outlier traces 
% CurrentMAT = SmoothedMAT; CurrentMAT(NeglectMatrix(:))=NaN;
% PlotMatrices(Time, CurrentMAT,  Stimulus)
% CurrentMAT = SmoothedMAT2; CurrentMAT(NeglectMatrix2(:))=NaN;
% PlotMatrices(Time, CurrentMAT,  Stimulus2)
% 
% % Normalized Smoothed matrices, exclude outlier traces 
% PlotMatrices(Time, ProcessedMAT,  [], [0 1])
% PlotMatrices(Time, ProcessedMAT2,  [], [0 1])
% PlotMatrices(Time, ProcessedMAT_All,  [], [0 1])
% 
% % Threshold of 0.2
% CurrentMAT = ProcessedMAT > 0.2;
% PlotMatrices(Time, CurrentMAT,  Stimulus)
% CurrentMAT = ProcessedMAT2 > 0.2;
% PlotMatrices(Time, CurrentMAT,  Stimulus2)
% 
%%%%  Plot ACT model Screen Results
% Plot_ACTmodel_ScreenResults(ACTmodelStructure, StimulusAtActivationTime, TotalNumberOfNeurons, TotalNumberOfNeurons2)

return


function PlotMatrices(Time, MAT, stim_timecourse, Climits)
% Plot matrices with OT sensory responses to looming stimuli of different speeds 

figure; 
subplot(1,3,1); imagesc(Time, 1:size(MAT,1), squeeze(MAT(:,2,:))); title('Fast'); if exist('Climits','var'), set(gca,'clim',Climits); end
subplot(1,3,2); imagesc(Time, 1:size(MAT,1), squeeze(MAT(:,3,:))); title('Intermediate'); if exist('Climits','var'), set(gca,'clim',Climits); end
subplot(1,3,3); imagesc(Time, 1:size(MAT,1), squeeze(MAT(:,1,:))); title('Slow'); if exist('Climits','var'), set(gca,'clim',Climits); end

if exist('stim_timecourse','var') && ~isempty(stim_timecourse)
    figure('position',[681   353   560   131]); 
    subplot(1,3,1); plot(Time, stim_timecourse{2}); xlim([Time(1)-0.5 Time(end)+0.5]); title('Fast')
    subplot(1,3,2); plot(Time, stim_timecourse{3}); xlim([Time(1)-0.5 Time(end)+0.5]); title('Intermediate')
    subplot(1,3,3); plot(Time, stim_timecourse{1}); xlim([Time(1)-0.5 Time(end)+0.5]); title('Slow')
end

return

function Plot_ACTmodel_ScreenResults(ACTmodelStructure, StimulusAtActivationTime,TotalNumberOfNeurons, TotalNumberOfNeurons2)
 
A_vec     = ACTmodelStructure.ScreenParams.A_vec;
Alpha_vec = ACTmodelStructure.ScreenParams.Alpha_vec;
X0_vec    = ACTmodelStructure.ScreenParams.X0_vec;
Tao_vec   = ACTmodelStructure.ScreenParams.Tao_vec;

ModelDistanceFromData               = ones(length(A_vec), length(Alpha_vec), length(X0_vec), length(Tao_vec), 'single');
ModelDistanceFromData_AbsoluteValue = ones(length(A_vec), length(Alpha_vec), length(X0_vec), length(Tao_vec), 'single');
% For each parameters combination:
%   Measure Dn, For each trace 1<n<N
%           Dn = [0 to 1], 0 is good fit, 1 is very distant
%           Dn = abs((Sm - Sd)/(Sm + Sd)), where Sm = Signal at activation time for Model, Sd = Signal at activation time for Data
%   Extract mean(Dn) 

% Avoid numerical errors due to zeros and NaNs
StimulusAtActivationTime_ForModelComparison = StimulusAtActivationTime;
StimulusAtActivationTime_ForModelComparison(StimulusAtActivationTime_ForModelComparison==0)     = 0.1; 
StimulusAtActivationTime_ForModelComparison(isnan(StimulusAtActivationTime_ForModelComparison)) = 1000;

for A_ind = 1:length(A_vec)    
    for Alpha_ind = 1:length(Alpha_vec)           
        for X0_ind = 1:length(X0_vec)
            for Tao_ind = 1:length(Tao_vec)            
                PredictedStimuli1 = squeeze(ACTmodelStructure.StimulusAtActivationTime_MAT1(A_ind, Alpha_ind, X0_ind, Tao_ind, :))';
                PredictedStimuli2 = squeeze(ACTmodelStructure.StimulusAtActivationTime_MAT2(A_ind, Alpha_ind, X0_ind, Tao_ind, :))';   
                if any(isnan([ PredictedStimuli1 PredictedStimuli2])) 
                    % if in any conditions there is no activation, flag the parameters as bad predictors 
                    MeanDistance = 1;
                    MaxDistance  = 1;
                else
                    PredictionMatrix  = [repmat(PredictedStimuli1,TotalNumberOfNeurons,1); repmat(PredictedStimuli2,TotalNumberOfNeurons2,1) ] ;   
                    PredictionMatrix_ForModelComparison                                             = PredictionMatrix;
                    PredictionMatrix_ForModelComparison(PredictionMatrix_ForModelComparison==0)     = 0.1;
                    PredictionMatrix_ForModelComparison(isnan(PredictionMatrix_ForModelComparison)) = 1000;

                    DistanceMatrix       = abs( (StimulusAtActivationTime_ForModelComparison - PredictionMatrix_ForModelComparison) ./ (StimulusAtActivationTime_ForModelComparison + PredictionMatrix_ForModelComparison) );            
                    DistancePerCondition = mean(DistanceMatrix,1);
                    MeanDistance         = mean(DistancePerCondition);
                    
                    DistanceMatrix_AbsoluteValue       = abs(StimulusAtActivationTime - PredictionMatrix);            
                    DistancePerCondition_AbsoluteValue = nanmean(DistanceMatrix_AbsoluteValue,1);
                    MeanDistance_AbsoluteValue         = mean(DistancePerCondition_AbsoluteValue);
                end
                ModelDistanceFromData(A_ind, Alpha_ind, X0_ind, Tao_ind) = MeanDistance;            
                ModelDistanceFromData_AbsoluteValue(A_ind, Alpha_ind, X0_ind, Tao_ind) = MeanDistance_AbsoluteValue;                           
            end
        end
    end
end

for X0_ind = 1:length(X0_vec)
    figure('name',['X_0=',num2str(X0_vec(X0_ind)),' . abs((Sm - Sd)/(Sm + Sd))'],'position',get(0,'ScreenSize')); 
    for A_ind = 1:length(A_vec)    
        A = A_vec(A_ind);
        subplot(4,4,A_ind); imagesc(squeeze(ModelDistanceFromData(A_ind,:,X0_ind,:))); set(gca,'clim',[0.16 0.3]); title(A);
        set(gca,'xtick',1:length(Tao_vec),'xticklabel',Tao_vec,'ytick',1:length(Alpha_vec),'yticklabel',Alpha_vec);
        ylabel('\alpha'); xlabel('\tau')
    end
    colorbar
end

for X0_ind = 1:length(X0_vec)
    figure('name',['X_0=',num2str(X0_vec(X0_ind)),' . abs((Sm - Sd))'],'position',get(0,'ScreenSize')); 
    for A_ind = 1:length(A_vec)    
        A = A_vec(A_ind);
        subplot(4,4,A_ind); imagesc(squeeze(ModelDistanceFromData_AbsoluteValue(A_ind,:,X0_ind,:))); set(gca,'clim',[15 30]); title(A);
        set(gca,'xtick',1:length(Tao_vec),'xticklabel',Tao_vec,'ytick',1:length(Alpha_vec),'yticklabel',Alpha_vec);
        ylabel('\alpha'); xlabel('\tau')
    end
    colorbar
end

 


return

function PlotTraceWithLatency(Time, MAT, ActivationTimes, neuron_index)
% Plot sensory activity an mark when it reaches a threshold value

ThresholdForFindingActivationTimeFromPeak = 0.05; 

figure;
XLIMITS = [-1 15];
YLIMITS = [-0.15 1];

hold on; plot(Time,squeeze(MAT(neuron_index,2,:)),'k-'); 
hold on; plot(Time,squeeze(MAT(neuron_index,3,:)),'-','color',[0.5 0 0]); 
hold on; plot(Time,squeeze(MAT(neuron_index,1,:)),'r-'); 
ylim(YLIMITS); xlim(XLIMITS); 
title(neuron_index)
line(XLIMITS, ThresholdForFindingActivationTimeFromPeak *ones(1,2) ,'color','k','linestyle','-')
line(ActivationTimes(neuron_index,2)*ones(1,2),YLIMITS,'color','k','linestyle','-')
line(ActivationTimes(neuron_index,3)*ones(1,2),YLIMITS,'color',[0.5 0 0],'linestyle','-')
line(ActivationTimes(neuron_index,1)*ones(1,2),YLIMITS,'color','r','linestyle','-')            

return

function Stats = PlotPerSpeed_median(Mat, NoFigure, NaNMode)
% Show median of the variable in 'Mat' for different stimulus speeds, and calculate relevant statistics  

Mat = Mat(:,[2 3 1]);       % Speeds: fast(2), intermediate(3), slow(1)

% NaNMode = 0;  % Ignore NaNs
% NaNMode = 1;  % Give NaNs the highest Matrix Value (useful for ON neurons)
                % Example: a non-reponsive ON neuron will have NaN value for stimulus level at activation time.    
                % Yet, the neuron should respond to sufficiently high amplitude stimuli, such as amplitudes higher than ones used in the experiment.  
                % When taking that into account (NaNMode=1), the real median stimulus level at activation time should be more biased towards higher levels.     
% NaNMode = -1; % Give NaNs the lowest Matrix Value (useful for OFF neurons)   
% 
% if NoFigure = true, then results are plotted on gcf
% 
Vec = cell(1,3);
if NaNMode==0
    for speed_ind = 1:3
        Vec{speed_ind} = Mat(~isnan(Mat(:,speed_ind)),speed_ind);
    end
elseif NaNMode==1
    Mat(isnan(Mat)) = max(Mat(:));
    for speed_ind = 1:3
        Vec{speed_ind} = Mat(:,speed_ind);
    end    
elseif NaNMode==-1
    Mat(isnan(Mat)) = min(Mat(:));
    for speed_ind = 1:3
        Vec{speed_ind} = Mat(:,speed_ind);
    end
end
MEDIANs         = nanmedian(Mat,1);    
NumberOfRepeats = sum(~isnan(Mat),1);

q = 0.5;         % quantile = median
LowerConfidenceInterval = ones(1,3);
UpperConfidenceInterval = ones(1,3);
for speed_ind = 1:3    
    SortedVec = sort(Vec{speed_ind});
    n         = NumberOfRepeats(speed_ind); % Number of measurements
    LowerConfidenceInterval(speed_ind) = SortedVec(floor(n*q - 1.96*sqrt(n*q*(1-q))));
    UpperConfidenceInterval(speed_ind) = SortedVec(ceil(n*q  + 1.96*sqrt(n*q*(1-q))));
end
if ~exist('NoFigure','var')|| ~NoFigure
    figure('position',[795   579   187   222]); 
end
LowerBars = MEDIANs - LowerConfidenceInterval;
UpperBars = UpperConfidenceInterval - MEDIANs;

errorbar (1:3, MEDIANs', LowerBars', UpperBars','k.')%,linestyle','none');
xlim([0.5 3.5]);
set(gca,'xtick',1:3,'xticklabel',{'F','I','S'})

Stats.description = {'fast vs. intermediate','intermediate vs. slow','fast vs. slow'};
Stats.Pvalues                        = ones(1,3);
Stats.EffectSize_FastHasSmallerValue = ones(1,3);
Stats.EffectSize_FastHasLargerValue  = ones(1,3);

[p, h, stats, EffectSize_XsmallerthanY] = ranksum_inline(Vec{1},Vec{2}); 
Stats.Pvalues(1)                        = p;
Stats.EffectSize_FastHasSmallerValue(1) = EffectSize_XsmallerthanY;
[p, h, stats, EffectSize_XsmallerthanY] = ranksum_inline(Vec{2},Vec{1});
Stats.EffectSize_FastHasLargerValue(1)  = EffectSize_XsmallerthanY;

[p, h, stats, EffectSize_XsmallerthanY] = ranksum_inline(Vec{2},Vec{3}); 
Stats.Pvalues(2)                        = p;
Stats.EffectSize_FastHasSmallerValue(2) = EffectSize_XsmallerthanY;
[p, h, stats, EffectSize_XsmallerthanY] = ranksum_inline(Vec{3},Vec{2});
Stats.EffectSize_FastHasLargerValue(2)  = EffectSize_XsmallerthanY;

[p, h, stats, EffectSize_XsmallerthanY] = ranksum_inline(Vec{1},Vec{3}); 
Stats.Pvalues(3)                        = p;
Stats.EffectSize_FastHasSmallerValue(3) = EffectSize_XsmallerthanY;
[p, h, stats, EffectSize_XsmallerthanY] = ranksum_inline(Vec{3},Vec{1});
Stats.EffectSize_FastHasLargerValue(3)  = EffectSize_XsmallerthanY;

return

function PlotComparison_Data_vs_ACT_Model(StimulusAtActivationTime, ActivationTimes, ACTmodelStructure, TotalNumberOfNeurons, TotalNumberOfNeurons2, X0, A, Alpha, tao)

A_vec     = ACTmodelStructure.ScreenParams.A_vec;
Alpha_vec = ACTmodelStructure.ScreenParams.Alpha_vec;
X0_vec    = ACTmodelStructure.ScreenParams.X0_vec;
Tao_vec   = ACTmodelStructure.ScreenParams.Tao_vec;

X0_ind    = find(X0_vec>(X0-1e-5),1,'first');
A_ind     = find(A_vec>(A-1e-5),1,'first');
Tao_ind   = find(Tao_vec>(tao-1e-5),1,'first');
Alpha_ind = find(Alpha_vec>(Alpha-1e-5),1,'first');

% Stimulus Size
PredictedStimuli1 = squeeze(ACTmodelStructure.StimulusAtActivationTime_MAT1(A_ind, Alpha_ind, X0_ind, Tao_ind, :))';
PredictedStimuli2 = squeeze(ACTmodelStructure.StimulusAtActivationTime_MAT2(A_ind, Alpha_ind, X0_ind, Tao_ind, :))';   
PredictionMatrix  = [repmat(PredictedStimuli1,TotalNumberOfNeurons,1); repmat(PredictedStimuli2,TotalNumberOfNeurons2,1) ] ;  

figure('position',[487 600 416 178],'name',['Stimulus size. X_0 = ',num2str(X0),' , A = ',num2str(A),' , \tau = ',num2str(tao),' , \alpha = ',num2str(Alpha) ]); 
subplot(1,2,1); PlotPerSpeed_median(StimulusAtActivationTime, true, 1); ylim([30 50]); title('Data'); ylabel('S, (all data)');
subplot(1,2,2); PlotPerSpeed_median(PredictionMatrix, true, 1);         ylim([30 50]); title('Model'); % title(['X_0 = ',num2str(X0),'  , A = ',num2str(A),'  , \tau = ',num2str(tao),'  , \alpha = ',num2str(Alpha) ])

% Latency
PredictedStimuli1 = squeeze(ACTmodelStructure.PredictedActivationTime_MAT1(A_ind, Alpha_ind, X0_ind, Tao_ind, :))';
PredictedStimuli2 = squeeze(ACTmodelStructure.PredictedActivationTime_MAT2(A_ind, Alpha_ind, X0_ind, Tao_ind, :))';   
PredictionMatrix  = [repmat(PredictedStimuli1,TotalNumberOfNeurons,1); repmat(PredictedStimuli2,TotalNumberOfNeurons2,1) ] ;   

figure('position',[930 277 416 653],'name',['Latency. X_0 = ',num2str(X0),' , A = ',num2str(A),' , \tau = ',num2str(tao),' , \alpha = ',num2str(Alpha) ]); 
subplot(3,2,1); PlotPerSpeed_median(ActivationTimes, true, 1);                                  ylim([-0.4 6.5]); title('Data'); ylabel('Latency [sec], (all data)')
subplot(3,2,2); PlotPerSpeed_median(PredictionMatrix, true, 1);                                 ylim([-0.4 6.5]); title('Model'); % title(['X_0=',num2str(X0),' , A=',num2str(A),' , \tau=',num2str(tao),' , \alpha=',num2str(Alpha)])
subplot(3,2,3); PlotPerSpeed_median(ActivationTimes(1:TotalNumberOfNeurons,:), true, 1);        ylim([-0.4 6.5]); ylabel('Latency [sec], p1')
subplot(3,2,4); PlotPerSpeed_median(PredictionMatrix(1:TotalNumberOfNeurons,:), true, 1);       ylim([-0.4 6.5]);                 % title(['X_0=',num2str(X0),' , A=',num2str(A),' , \tau=',num2str(tao),' , \alpha=',num2str(Alpha)])
subplot(3,2,5); PlotPerSpeed_median(ActivationTimes((TotalNumberOfNeurons+1):end,:), true, 1);  ylim([-0.4 6.5]); ylabel('Latency [sec], p2')
subplot(3,2,6); PlotPerSpeed_median(PredictionMatrix((TotalNumberOfNeurons+1):end,:), true, 1); ylim([-0.4 6.5]);                 % title(['X_0=',num2str(X0),' , A=',num2str(A),' , \tau=',num2str(tao),' , \alpha=',num2str(Alpha)])

return

function [p, h, stats, EffectSize_XsmallerthanY] = ranksum_inline(x,y,varargin)
%RANKSUM Wilcoxon rank sum test for equal medians. Modified from original Matlab function 'ranksum'   
%   P = RANKSUM(X,Y) performs a two-sided rank sum test of the hypothesis
%   that two independent samples, in the vectors X and Y, come from
%   distributions with equal medians, and returns the p-value from the
%   test.  P is the probability of observing the given result, or one more
%   extreme, by chance if the null hypothesis ("medians are equal") is
%   true.  Small values of P cast doubt on the validity of the null
%   hypothesis.  The two sets of data are assumed to come from continuous
%   distributions that are identical except possibly for a location shift,
%   but are otherwise arbitrary.  X and Y can be different lengths.
%   RANKSUM treats NaNs in X or Y as missing values, and removes them.
%   The two-sided p-value is computed by doubling the most significant
%   one-sided value.
%
%   The Wilcoxon rank sum test is equivalent to the Mann-Whitney U test.
%
%   [P,H] = RANKSUM(...) returns the result of the hypothesis test,
%   performed at the 0.05 significance level, in H.  H=0 indicates that
%   the null hypothesis ("medians are equal") cannot be rejected at the 5%
%   level. H=1 indicates that the null hypothesis can be rejected at the
%   5% level.
%
%   [P,H] = RANKSUM(...,'alpha',ALPHA) returns the result of the hypothesis
%   test performed at the significance level ALPHA.
%
%   [P,H] = RANKSUM(...,'method',M) computes the p-value exactly if M is
%   'exact', or uses a normal approximation if M is 'approximate'.  If you
%   omit this argument, RANKSUM uses the exact method for small samples and
%   the approximate method for larger samples.
%
%   [P,H] = RANKSUM(...,'tail',TAIL) performs the test against the
%   alternative hypothesis specified by TAIL:
%       'both'  -- "medians are not equal" (two-tailed test, default)
%       'right' -- "median of X is greater than median of Y" (right-tailed test)
%       'left'  -- "median of X is less than median of Y" (left-tailed test)
%   TAIL must be a single string.
%
%   [P,H,STATS] = RANKSUM(...) returns STATS, a structure with one or two
%   fields.  The field 'ranksum' contains the value of the rank sum
%   statistic for X.  For the 'approximate' method, the field 'zval'
%   contains the value of the normal (Z) statistic.
%
%   See also SIGNTEST, SIGNRANK, KRUSKALWALLIS, TTEST2.

%   References:
%      [1] Hollander, M. and D. A. Wolfe.  Nonparametric Statistical
%          Methods. Wiley, 1973.
%      [2] Gibbons, J.D.  Nonparametric Statistical Inference,
%          2nd ed.  M. Dekker, 1985.


% Check that x and y are vectors
if ~isvector(x) || ~isvector(y)
   error(message('stats:ranksum:InvalidData'));
end

% Remove missing data
x = x( ~isnan(x) );
y = y( ~isnan(y) );
if isempty(x) || isempty(y)
	error(message('stats:signrank:NotEnoughData'));
end

% Determine value for 'alpha' and parse inputs
alpha = 0.05;   % default
if nargin>2 && isnumeric(varargin{1})
   % Grandfathered syntax:  ranksum(x,y,alpha)
   alpha = varargin{1};
   varargin(1) = [];
end
%
oknames = {'alpha' 'method' 'tail'};
dflts   = {alpha   ''   'both'};
[alpha,method,tail] = internal.stats.parseArgs(oknames,dflts,varargin{:});

% Check value of 'alpha'
if ~isscalar(alpha) || ~isnumeric(alpha) || isnan(alpha) || (alpha <= 0) || (alpha >= 1)
   error(message('stats:ranksum:BadAlpha'));
end

% Check value of 'tail'
tail = internal.stats.getParamVal(tail, {'both'  'right'  'left'}, '''tail''');

% Determine and check value for 'method'
nx = numel(x);
ny = numel(y);
ns = min(nx,ny);
if isempty(method)
   if (ns < 10)  &&  ((nx+ny) < 20)
      method = 'exact';
   else
      method = 'approximate';
   end
elseif strcmpi(method, 'oldexact')
	method = 'oldexact';
else   % method not recognized, throw error
   method = internal.stats.getParamVal(method,{'exact' 'approximate'},'''method''');
end

% Determine computational 'technique'
switch method
	case 'approximate'
		technique = 'normal_approximation';
	case 'oldexact'
		technique = 'full_enumeration';
	case 'exact'
		if (nx+ny) < 10
			technique = 'full_enumeration';
		else
			technique = 'network_algorithm';
		end
end

%      %      %      %      %      %      %      %      %      %
% Calculations for Rank Sum Test

x = x(:);   % ensure columns
y = y(:);
if nx <= ny
   smsample = x;
   lgsample = y;
   same_order = true;
else
   smsample = y;
   lgsample = x;
   same_order = false;
end

% Compute the rank sum statistic based on the smaller sample
[ranks, tieadj] = tiedrank([smsample; lgsample]);
srank = ranks(1:ns);
w = sum(srank);


switch technique
	case 'full_enumeration'
		allpos = nchoosek(ranks,ns);   % enumerate all possibilities
		sumranks = sum(allpos,2);
		np = size(sumranks, 1);
		
		switch tail
			case 'both'
				plo = sum( sumranks <= w) / np ;
				phi = sum( sumranks >= w) / np ;
				p_tail = min(plo,phi);
				p = min(2*p_tail, 1);   % 2-sided, p>1 means middle is double-counted
				
			case 'right'
				switch same_order
					case true
						p = sum( sumranks >= w) / np ;
					case false
						p = sum( sumranks <= w) / np;
				end
				
			case 'left'
				switch same_order
					case true
						p = sum( sumranks <= w) / np ;
					case false
						p = sum( sumranks >= w) / np;
				end
				
		end
		
		%     %     %     %     %     %     %      %      %      %
		
	case 'network_algorithm'
		[p_net, pvals] = exactprob(smsample, lgsample, w);
		
		if any(isnan(p_net)) || any(isnan(pvals))
			warning(message('stats:ranksum:NanResult'));
			p = NaN;
			
		else
			switch tail
				case 'both'   % two-tailed test
					p = min(2*p_net, 1);   % p>1 means the middle is double-counted
					
				case 'right'   % right-tail test
					switch same_order
						case true
							p =  pvals(2) + pvals(3);
						case false
							p = pvals(2) + pvals(1);
					end
					
				case 'left'   % left-tail test
					switch same_order
						case true
							p =  pvals(2) + pvals(1);
						case false
							p = pvals(2) + pvals(3);
					end
					
			end   % conditional on 'tail'
		
		end
		
		%     %     %     %     %     %     %      %      %      %
				
	case 'normal_approximation'
		wmean = ns*(nx + ny + 1)/2;
		tiescor = 2 * tieadj / ((nx+ny) * (nx+ny-1));
		wvar  = nx*ny*((nx + ny + 1) - tiescor)/12;
		wc = w - wmean;

		% compute z-value, including continuity correction
		switch tail
			case 'both'
				z = (wc - 0.5 * sign(wc))/sqrt(wvar);
				if ~same_order
					z = -z;
				end
				p = 2*normcdf(-abs(z));
				
			case 'right'
				if same_order
					z = (wc - 0.5)/sqrt(wvar);
				else
					z = -(wc + 0.5)/sqrt(wvar);
				end
				
				p = normcdf(-z);
				
			case 'left'
				if same_order
					z = (wc + 0.5)/sqrt(wvar);
				else
					z = -(wc - 0.5)/sqrt(wvar);
				end
				
				p = normcdf(z);
		end


		if (nargout > 2)   % handle additional outputs
			stats.zval = z;
		end
		
end   % conditional on 'technique'



% Handle additional outputs
if nargout > 1,
   h = (p<=alpha);

   if (nargout > 2)
	   if same_order
		   stats.ranksum = w;
	   else
		   stats.ranksum = sum( ranks(ns+1:end) );
	   end
   end   
end

%% Calculate effect size
try
    [X,Y]                   = meshgrid(single(x),single(y));
    MAT_XsmallerthanY       = Y-X; 
    Fraction_XsmallerthanY  = length(find(MAT_XsmallerthanY(:)>0)) / length(MAT_XsmallerthanY(:));    % another way: 1-2*(length(find(~MAT_XsmallerthanY(:)))/2)/ (length(x)*length(y))
catch
    disp('Large vectors- calculating effect size in loop');
    NumberXsmallerthanY = 0;
    for ind=1:length(x)
        NumberXsmallerthanY = NumberXsmallerthanY + length(find(x(ind)<y));
    end   
    Fraction_XsmallerthanY = NumberXsmallerthanY/(length(x)*length(y));
end

EffectSize_XsmallerthanY = 2*Fraction_XsmallerthanY - 1;   % FractionSmaller- FractionHigher.  [-1 1]
    
return

function [p1, pvals] = exactprob(x,y,w)
%EXACTPROB Exact P-values for Wilcoxon Mann Whitney nonparametric test
%   [P1,PVALS]=EXACTPROB(X,Y,W) computes the p-value P for the test
%   statistic W in a Wilcoxon-Mann-Whitney nonparametric test of the
%   hypothesis that X and Y come from distributions with equal medians.

% Create a contingency table with element (i,j) indicating how many
% times u(j) appears in sample i
u = unique([x(:); y(:)]);
t = zeros(2,length(u));
t(1,:) = histc(x,u)';
t(2,:) = histc(y,u)';

% Compute weights for wmw test
colsum = sum(t,1);
tmp = cumsum(colsum);
wts = [0 tmp(1:end-1)] + .5*(1+diff([0 tmp]));

% Compute p-value using network algorithm for contingency tables
[p1, pvals] = statctexact_SL(t,wts,w);
return









